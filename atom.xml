<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>samwei12&#39;s blog</title>
  <icon>https://www.gravatar.com/avatar/8d458a4b390f1a6b8d90043372e6cfd3</icon>
  <subtitle>Stay hungry, stay foolish.</subtitle>
  <link href="http://blog.samwei12.cn/atom.xml" rel="self"/>
  
  <link href="http://blog.samwei12.cn/"/>
  <updated>2024-08-17T03:56:08.431Z</updated>
  <id>http://blog.samwei12.cn/</id>
  
  <author>
    <name>samwei12</name>
    <email>dongxiaosen@icloud.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Hexo-Github 自动部署方案</title>
    <link href="http://blog.samwei12.cn/2024/08/17/Utilities/Writing/Hexo-Github-%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2%E6%96%B9%E6%A1%88/"/>
    <id>http://blog.samwei12.cn/2024/08/17/Utilities/Writing/Hexo-Github-%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2%E6%96%B9%E6%A1%88/</id>
    <published>2024-08-17T02:44:43.000Z</published>
    <updated>2024-08-17T03:56:08.431Z</updated>
    
    <content type="html"><![CDATA[<p>前阵子因为很久没有捡起来写博客，导致电脑的 node 环境各种版本问题，本地压根运行不起来，所以折腾了一下 Hugo 方案，感觉 Hugo 相较于 Hexo 还是有很多优势的，让我印象比较深的是：</p><ol><li>整个环境较为独立，不再像 Hexo 需要依赖电脑 Node 版本，各种插件需要独立版本，随着 Hexo 或者 Node 版本升级还需要考虑插件版本问题，减少了很多折腾的工作。<ol><li>Hugo 搭建和配置非常简单， <img src="https://learner.oss-cn-hangzhou.aliyuncs.com/img/202408171050885.png" alt="202408171050885"></li><li>Hexo 的环境依赖：<br><img src="https://learner.oss-cn-hangzhou.aliyuncs.com/img/202408171049445.png" alt="202408171049445"></li></ol></li><li>其次就是 Hugo 速度真的是非常快，比 Hexo 快非常多</li><li>然后就是直接配置 Github Action 就可以完成部署，不再需要像 Hexo 那样安装 git 部署插件，参考： <a href="https://blog.samwei12.cn/2015/09/01/Utilities/Writing/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-Hexo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/#Git-1">如何使用 Hexo 搭建个人博客 | samwei12’s blog</a> 这点感觉能节省很多时间，不再需要每次写完文章手动敲命令行部署。</li></ol><span id="more"></span><p>不过后面折腾半天之后，觉得 Hugo 上确实找不到一款比较合心意的主题（可能是因为使用 Hugo 的大多是后端开发），另外就是需要把之前折腾的一堆插件，例如评论、时长统计、站点统计、RSS 等全部折腾一遍，想想这个工作就觉得有点过于浪费时间了，毕竟还是要以写作为主，不应该花费太多时间在折腾工具上。<br>刚好后面发现 GitHub 的部署居然会提示我插件版本升级，于是按照对应的插件版本提示，修复了版本冲突问题，节省了我大量的时间，很赞。</p><p><img src="https://learner.oss-cn-hangzhou.aliyuncs.com/img/202408171101402.png" alt="202408171101402"></p><p>接下来就是思考 Hexo 是否也有类似的自动部署方案，因为我是 15 年开始使用 Hexo 的，当时 Github Action 还没有推出。<br>简单检索了一下，发现确实还真有，但找到几个现成的 Action 都无法使用，对应的 Node 版本已经过时，例如  <a href="https://github.com/marketplace/actions/hexo-github-action">Hexo GitHub Action · Actions · GitHub Marketplace</a> 。 </p><p>后来觉得这种没道理官方不出对应的方案，没必要找别人已经加工过的。于是搜到了 <a href="https://hexo.io/docs/github-pages">GitHub Pages | Hexo</a>。发现官方文档写的更加完整，建议大家直接去网站上查看，这里只写一下自己在实际使用过程中可能会遇到的问题：</p><h3 id="分支问题"><a href="#分支问题" class="headerlink" title="分支问题"></a>分支问题</h3><p>这里官方给到的示例是直接使用 <code>main</code> 分支，包括 yaml 配置中使用的也是这个，但对于我目前的工程来说，并没有把 Markdown 文件跟生成的网页拆分成两个工程（理论上来说拆开比较合适，更加安全，可以把草稿文件等隐藏起来不对外公开），而是通过两个不同的 git 分支来进行分离，hexo 分支存放原始的 <code>sources</code> 文件，而 <code>master</code> 分支用来存放暴露的静态站点。所以这里花了一点时间来研究 Action 配置中的 git 分支应该填哪个。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">Pages</span> <span class="comment"># 这里可以改成你自定义的Action名称</span></span><br><span class="line"></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">branches:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">hexo</span> <span class="comment"># 这里如果你像我一样拆分了两个不同分支，那么应该填你的 source 分支，对于我来说就是 hexo</span></span><br></pre></td></tr></table></figure><h3 id="版本问题"><a href="#版本问题" class="headerlink" title="版本问题"></a>版本问题</h3><p>这个比较简单，确认你本地的Hexo和对应的Node版本，设置成一样的即可，确保不会出现插件跟Node版本不一致问题</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Use</span> <span class="string">Node.js</span> <span class="number">18</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/setup-node@v4</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="comment"># Examples: 20, 18.19, &gt;=16.20.2, lts/Iron, lts/Hydrogen, *, latest, current, node</span></span><br><span class="line">          <span class="comment"># Ref: https://github.com/actions/setup-node#supported-version-syntax</span></span><br><span class="line">          <span class="attr">node-version:</span> <span class="string">&quot;18&quot;</span></span><br></pre></td></tr></table></figure><h3 id="Github-Page-设置"><a href="#Github-Page-设置" class="headerlink" title="Github Page 设置"></a>Github Page 设置</h3><p><img src="https://learner.oss-cn-hangzhou.aliyuncs.com/img/202408171146444.png" alt="202408171146444"></p><p>在 Github 中开启 Actions 即可</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="https://learner.oss-cn-hangzhou.aliyuncs.com/img/202408171148869.png" alt="202408171148869"></p><p>至此，基本上就完成了自动部署，之后只需要提交完 Markdown 之后完成推送，Actions 就会自动帮我们构建网站，不用手动敲命令行了。</p><p>这里还告诉我们一个道理，也是陈皓老师多次提到的，我们要尽可能的学习一手资料，而不是别人咀嚼过的，可以通过检索别人的文章博客来简单了解一下某个知识，但想要实际学习其中的细节或者遇到问题能够钻研解决，还是需要直接找官方文档或者论文，不然可能只能照抄别人的流程，中间遇到跟他不一样的环境、配置，就傻眼了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;前阵子因为很久没有捡起来写博客，导致电脑的 node 环境各种版本问题，本地压根运行不起来，所以折腾了一下 Hugo 方案，感觉 Hugo 相较于 Hexo 还是有很多优势的，让我印象比较深的是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;整个环境较为独立，不再像 Hexo 需要依赖电脑 Node 版本，各种插件需要独立版本，随着 Hexo 或者 Node 版本升级还需要考虑插件版本问题，减少了很多折腾的工作。&lt;ol&gt;
&lt;li&gt;Hugo 搭建和配置非常简单， &lt;img src=&quot;https://learner.oss-cn-hangzhou.aliyuncs.com/img/202408171050885.png&quot; alt=&quot;202408171050885&quot;&gt;&lt;/li&gt;
&lt;li&gt;Hexo 的环境依赖：&lt;br&gt;&lt;img src=&quot;https://learner.oss-cn-hangzhou.aliyuncs.com/img/202408171049445.png&quot; alt=&quot;202408171049445&quot;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;其次就是 Hugo 速度真的是非常快，比 Hexo 快非常多&lt;/li&gt;
&lt;li&gt;然后就是直接配置 Github Action 就可以完成部署，不再需要像 Hexo 那样安装 git 部署插件，参考： &lt;a href=&quot;https://blog.samwei12.cn/2015/09/01/Utilities/Writing/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-Hexo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/#Git-1&quot;&gt;如何使用 Hexo 搭建个人博客 | samwei12’s blog&lt;/a&gt; 这点感觉能节省很多时间，不再需要每次写完文章手动敲命令行部署。&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="Utilities" scheme="http://blog.samwei12.cn/categories/Utilities/"/>
    
    
    <category term="Hexo" scheme="http://blog.samwei12.cn/tags/Hexo/"/>
    
    <category term="Blog" scheme="http://blog.samwei12.cn/tags/Blog/"/>
    
  </entry>
  
  <entry>
    <title>认知觉醒-4-改变才是根本</title>
    <link href="http://blog.samwei12.cn/2024/08/15/Reading/%E8%AE%A4%E7%9F%A5%E8%A7%89%E9%86%92-4-%E6%94%B9%E5%8F%98%E6%89%8D%E6%98%AF%E6%A0%B9%E6%9C%AC/"/>
    <id>http://blog.samwei12.cn/2024/08/15/Reading/%E8%AE%A4%E7%9F%A5%E8%A7%89%E9%86%92-4-%E6%94%B9%E5%8F%98%E6%89%8D%E6%98%AF%E6%A0%B9%E6%9C%AC/</id>
    <published>2024-08-15T00:43:19.000Z</published>
    <updated>2024-08-17T02:44:09.440Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是成长权重"><a href="#什么是成长权重" class="headerlink" title="什么是成长权重"></a>什么是成长权重</h2><p>《认知觉醒》提到了一个个人成长中的概念，叫做成长权重对比，作者周岭认为学习、思考、行动、改变在个人成长中的权重占比是不一样的。并不是说学的越多，成长就会越快，相反，盲目的学习只会让自己陷入焦虑怪圈，因为我们都会默认收获需要正比于付出，当自己花了大量精力学习但没有得到任何收货时，只会更加焦虑。</p><p>作者提出了成长权重对比，即改变量 &gt; 行动量 &gt; 思考量 &gt; 学习量。<br><img src="https://learner.oss-cn-hangzhou.aliyuncs.com/img/202408150846166.png" alt="202408150846166"></p><span id="more"></span><h2 id="为什么作者会这么说？"><a href="#为什么作者会这么说？" class="headerlink" title="为什么作者会这么说？"></a>为什么作者会这么说？</h2><p>他说的对吗？我们把这个观点拆解开来分析。</p><h3 id="思考量-学习量"><a href="#思考量-学习量" class="headerlink" title="思考量 &gt; 学习量"></a>思考量 &gt; 学习量</h3><p>“学而不思则罔”。普通的看书听课如果没有进行自己的思考，那么就是盲目的被动学习，即使花费了大量的时间，每年读了几十上百本书，但没有经过自己的认真思考，也只会读完就忘，没有办法给自己带来收益。花大量时间学习但不进行思考其实就是使用简单的阅读看书来代替困难的思考改变，这也是人类的趋易避难的天性决定的（参见：<a href="https://blog.samwei12.cn/2024/07/29/Reading/%E8%AE%A4%E7%9F%A5%E8%A7%89%E9%86%92-1-%E5%A4%A7%E8%84%91%E7%9A%84%E6%9E%84%E9%80%A0/">认知觉醒-1-大脑的构造 | samwei12’s blog</a>）。例如掌握英语是一个非常复杂困难的问题，包括读、写、听说等，而转换为每天背 10 个单词当然要简单多了，但哪怕坚持背 5 年单词也无法达到与母语者沟通交流的地步，这样做无疑是低效的。</p><h3 id="行动量-思考量"><a href="#行动量-思考量" class="headerlink" title="行动量 &gt; 思考量"></a>行动量 &gt; 思考量</h3><p>“纸上得来终觉浅，绝知此事要躬行”。这很好理解，就像你熟读一本菜谱，哪怕翻来覆去的背诵，不实际尝试几次也永远不可能学会如何做这道菜。光知道是不够的，离实际做到还差了非常远的距离，如何做到知行合一始终是贯穿我们终生的问题。</p><h3 id="改变量-行动量"><a href="#改变量-行动量" class="headerlink" title="改变量 &gt; 行动量"></a>改变量 &gt; 行动量</h3><p>我自己的看法是这句话分为两层含义。1. 行动是外在的，改变是内在的。如果只是盲目行动，那么可能很难坚持，也很难长期对自己有所帮助，参考 <a href="https://blog.samwei12.cn/2024/08/14/Reading/%E8%AE%A4%E7%9F%A5%E8%A7%89%E9%86%92-3-%E6%88%90%E4%B8%BA%E9%95%BF%E6%9C%9F%E4%B8%BB%E4%B9%89%E8%80%85/">认知觉醒-3-成为长期主义者 | samwei12’s blog</a> ，马拉松比赛中用百米冲刺的速度肯定是无法到达终点的，只有我们由内向外先产生思维上的改变，设法给行动赋予意义，才能够长期坚持行动，让自己真正的快速成长。 2. 改变是长期行动产生的结果。例如当我们每天坚持锻炼一段时间后，大脑会通过多巴胺奖励我们的行为，让我们真正爱上这项活动，做到自发的热爱锻炼，这也代表我们真正发生了由内而外的改变。</p><p>改变是最困难的，盲目的学习是简单但低效的，所以制定所谓的阅读完成 x 本书这种目标没有任何意义，不如改为输出 x 篇读书笔记，养成一个好习惯。</p><h2 id="有哪些类似的观点？"><a href="#有哪些类似的观点？" class="headerlink" title="有哪些类似的观点？"></a>有哪些类似的观点？</h2><p>宋代儒学家陆九渊说过：“六经注我，我注六经”。有一种解读是我们在阅读和思考时候，都要把自己当做第一位，思考作者的观点能够给自己带来什么帮助和改变，哪怕整本书只有一个观点给自己带来了触动，让自己产生了一些改变，也比读十本书没有任何思考来的有价值。从另一个角度思考，这个观点也能解决“收藏家谬论”，并不是说看到非常好的文章就要进我的收藏夹吃灰，而是认真思考它是否能给我带来改变，比如看到一篇高深的算法论文，学术界高度赞扬，但实际上我根本看不懂它，那它可以说对我毫无价值，并不值得收藏，等自己真正涉及到相关的领域，或者知识积累到能看懂它的地步，它才可能对我有所帮助。</p><p>前两天看语者的公众号  <a href="https://mp.weixin.qq.com/s/rMnKG8ZDq4qClGV0xPGMDA">尝试提问，让自己从被动阅读变成主动阅读</a> 里面也提到了他是如何将被动阅读转换为主动阅读的，核心点就在于多提问，同时他还提出了几类不同的问题，包括概念型、应用型、分析型和评估型。这也是在帮助我们尽可能提升学习到思考到行动的漏斗，提升学习阅读的效率。这个方法不只适用于阅读，在平时的工作学习、日常思考中都非常适用。</p><h2 id="总结-对自己有什么帮助或产生了什么改变？"><a href="#总结-对自己有什么帮助或产生了什么改变？" class="headerlink" title="总结-对自己有什么帮助或产生了什么改变？"></a>总结-对自己有什么帮助或产生了什么改变？</h2><p>了解到了这个概念之后，我改变了自己之前的文献笔记模板，参考作者的触动笔记和语者的模板，更新为发现对自己有触动的内容后：</p><ol><li>用自己的话概括复述汇总一遍，这里需要对这个知识点本身有一定的了解和抽象才能概括复述。</li><li>努力跟自己已有的知识点进行关联，跟我之前学过的 xx 可以联系到一起；可以作为 xx 主题的写作素材</li><li>按照概念型、应用型、分析型、评估型模板，多提一些问题，例如这个观点对吗？有什么类似的观点？或者相冲突的观点？有哪些示例可以佐证？适用于哪些场景？有什么缺点？如何在自己的生活工作中使用？</li><li>罗列出给自己带来了哪些改变。例如，修改了自己的日记模板、在 xx 主题写作中使用到了这个观点、补充了每日冥想到自己的习惯清单中等等</li></ol><p>按照这个顺序仔细思考完之后，可能作者一句话的观点就能让自己扩散出几百字的反思和总结，把自己之前学习到的 N 个知识点串联在了一起，加深印象。并且通过反复不断的提问可以一层层的深入细节，让自己的思路更加清晰，必然能大幅度提升学习效率。</p><p>综上，我们不管是在看书还是刷网络文章的过程中，都要以对自己产生改变作为衡量标准，只有对自己产生改变的知识或者观点才是有价值的，与自己无关的或者看完就丢一边的内容，哪怕对别人价值千金，对自己也毫无意义。避免让自己成为“看了很多书，懂了很多大道理，还是过不好这一生”的人。还是那句话，走马观花的看完十本书，还不如真正实践哪怕是一本书的一个观点给自己带来的改变和帮助大，与君共勉。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;什么是成长权重&quot;&gt;&lt;a href=&quot;#什么是成长权重&quot; class=&quot;headerlink&quot; title=&quot;什么是成长权重&quot;&gt;&lt;/a&gt;什么是成长权重&lt;/h2&gt;&lt;p&gt;《认知觉醒》提到了一个个人成长中的概念，叫做成长权重对比，作者周岭认为学习、思考、行动、改变在个人成长中的权重占比是不一样的。并不是说学的越多，成长就会越快，相反，盲目的学习只会让自己陷入焦虑怪圈，因为我们都会默认收获需要正比于付出，当自己花了大量精力学习但没有得到任何收货时，只会更加焦虑。&lt;/p&gt;
&lt;p&gt;作者提出了成长权重对比，即改变量 &amp;gt; 行动量 &amp;gt; 思考量 &amp;gt; 学习量。&lt;br&gt;&lt;img src=&quot;https://learner.oss-cn-hangzhou.aliyuncs.com/img/202408150846166.png&quot; alt=&quot;202408150846166&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Reading" scheme="http://blog.samwei12.cn/categories/Reading/"/>
    
    
    <category term="认知觉醒" scheme="http://blog.samwei12.cn/tags/%E8%AE%A4%E7%9F%A5%E8%A7%89%E9%86%92/"/>
    
    <category term="读书笔记" scheme="http://blog.samwei12.cn/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    <category term="主动学习" scheme="http://blog.samwei12.cn/tags/%E4%B8%BB%E5%8A%A8%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="知行合一" scheme="http://blog.samwei12.cn/tags/%E7%9F%A5%E8%A1%8C%E5%90%88%E4%B8%80/"/>
    
  </entry>
  
  <entry>
    <title>认知觉醒-3-成为长期主义者</title>
    <link href="http://blog.samwei12.cn/2024/08/14/Reading/%E8%AE%A4%E7%9F%A5%E8%A7%89%E9%86%92-3-%E6%88%90%E4%B8%BA%E9%95%BF%E6%9C%9F%E4%B8%BB%E4%B9%89%E8%80%85/"/>
    <id>http://blog.samwei12.cn/2024/08/14/Reading/%E8%AE%A4%E7%9F%A5%E8%A7%89%E9%86%92-3-%E6%88%90%E4%B8%BA%E9%95%BF%E6%9C%9F%E4%B8%BB%E4%B9%89%E8%80%85/</id>
    <published>2024-08-14T01:04:15.000Z</published>
    <updated>2024-08-15T01:08:55.583Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://blog.samwei12.cn/2024/08/14/Reading/%E8%AE%A4%E7%9F%A5%E8%A7%89%E9%86%92-3-%E6%88%90%E4%B8%BA%E9%95%BF%E6%9C%9F%E4%B8%BB%E4%B9%89%E8%80%85/">原文链接</a></p></blockquote><p>我们为什么做事情总是容易半途而废呢？哪怕自己明知道阅读、运动对自己是有好处的，但总是坚持不了几天就会放弃，背后的原因到底是什么呢？真的只是因为自己没有足够的耐心吗？</p><h2 id="什么是耐心？"><a href="#什么是耐心？" class="headerlink" title="什么是耐心？"></a>什么是耐心？</h2><p>想要解答这个问题，我们首先需要定义什么是耐心？<br>周岭在《认知觉醒》中提出的观点是本能脑和情绪脑天生就是缺乏耐心的，而理智脑才是真正让我们能长期坚持做某件无法立竿见影事情的关键。最直观的例子是在婴幼儿时期，理智脑的发育是很不健全的，所以小孩子的任何行为都想要立马得到回应，否则就会立刻哭闹。另一个案例是大家都熟知的<a href="https://zh.wikipedia.org/zh-cn/%E6%A3%89%E8%8A%B1%E7%B3%96%E5%AE%9E%E9%AA%8C">棉花糖实验 - 维基百科，自由的百科全书</a>，能够坚持 15 分钟，领取两份奖励的小孩在未来的成就通常会高于立刻领取奖励的那些孩子，这从另一个方面说明延迟满足能力强的人在人生道路上有可能会走的更远。<br>因此作者说， 耐心不是毅力带来的结果，而是具有长远目光的结果。</p><span id="more"></span><h2 id="我们为什么总是会半途而废？"><a href="#我们为什么总是会半途而废？" class="headerlink" title="我们为什么总是会半途而废？"></a>我们为什么总是会半途而废？</h2><p>那么绝大部分普通人为什么都会显得十分没有耐心呢？这里作者从内外两个角度分析这个问题：</p><p>向内，由大脑的发展历程我们可以知道，急于求成、即时满足是刻在人类的天性中的，如果没有经过刻意练习，绝大多数人在拿起手机打开短视频的那一刻开始，就已经完全忘记自己的学习目标了，只会盲目跟从本能不断的划到另一个视频中，完全被吸引走了注意力，玩累了之后才会突然惊觉已经过了好几个小时，于是开始内疚焦虑。</p><p>向外，绝大多数对我们长期有帮助的事情都是无法立竿见影的。例如通常需要坚持 6 个月我们才可以在一门新的语言学习中突破平台期，在这之前的 5 个月每天听练也很有可能会陷入瓶颈而产生放弃的想法。非常类似于挖井，地下水在 100 米，哪怕明知道继续挖一定能挖到水，绝大多数人在挖到 99 米之前放弃的话，也会一无所获。</p><p><img src="https://learner.oss-cn-hangzhou.aliyuncs.com/img/202408142312108.png" alt="202408142312108"></p><p>正是因为我们天性就是即时满足的，同时大多数长期来看对自己有利的事情，短期内都无法给自己带来足够的正向反馈，所以才会导致我们半途而废。</p><h2 id="如何培养耐心？或者如何成为长期主义者？"><a href="#如何培养耐心？或者如何成为长期主义者？" class="headerlink" title="如何培养耐心？或者如何成为长期主义者？"></a>如何培养耐心？或者如何成为长期主义者？</h2><p>那么如何克服这些困难，让我们能够有足够耐心做长期对自己有意义的事情呢？</p><p>首先，接纳自己，允许自己失败。我们都知道了缺乏耐心、即时满足是刻在我们天性中的，所以我们要先能接受自己的失败。比如我经常在工作日的时候间歇式努力，到了周末只想在家躺着玩手机，然后开始焦虑；自己建立的各种打卡习惯，到了周末也经常坚持不下来，痛恨自己。但明白了深层的原因之后，现在我会反过来想，我好歹努力了 5 个工作日，已经很不错了，继续加油，焦虑感立马减轻了很多。</p><p>其次，设法与大脑进行沟通，将奖励推迟。在我们打算努力看书的时候，大脑中突然冒出来一个刷会手机吧这种想法，此时如果我们用意志克服它，告诉自己，玩游戏、刷短视频是浪费时间的行为，是不被允许的，偶尔一两次可能还会奏效，时间长了大脑会很抵触这种行为，因为他会给我们带来痛苦，甚至慢慢改变我们的奖赏回路，在每次想要看书的时候，大脑就会通过产生痛苦感来阻止我们。反过来，我们并不抵触玩游戏玩手机的想法，而是告诉自己，把这章看完就允许自己玩一会手机，大脑就会慢慢适应我们的节奏，随着延迟的时间越来越长，我们可以做到完成今天的工作之后再玩游戏，慢慢到周末有空再玩游戏，逐步达到我们的预期。<br>切身体会的例子就是自己已经实践了一个月左右不带手机进卧室的小习惯，睡觉前想玩手机的时候告诉自己明早起来再玩，早上醒来想刷手机，告诉自己洗漱完了再去。随着逐步适应，摆脱了之前睡前半小时，早起躺床上半小时刷手机的时间，感觉非常有效。<br>包括平时工作的时候，顶多偶尔喝水上厕所的时候看一眼通知，其他时候告诉自己下班再玩，或者午休再玩，每天吃过中饭休息的时候允许自己花 10-20 分钟专门用来玩手机。</p><p>第三个办法是，赋予自己的行动一些目标感，把当下自己在做的事情和未来关联起来。例如，在跑步的时候想象自己坚持跑步 3 年后，已经取得了什么样的成绩，例如减了 20 斤，身材更好了，更有自信了，于是追到了自己喜欢的女生；练习英语时，想象自己未来能够在公开场合流利的用英语跟他人进行交流，在公司的外派中大放光彩，或者进入到了心仪的外企等等。</p><p>最后还有一个最理想的解决办法，在《游戏改变世界》中提到的观点，将自己的人生目标与游戏关联起来。游戏有几个明显的特征： 非常明确的目标（例如打倒 boss）、简单清晰的规则（血条清空就会死）、即时满足（每次打击碰撞都会掉血）。发现没有，我们喜欢玩游戏的原因正是因为我们的大脑天性就是如此。所以将我们的人生目标游戏化，拆分成足够清晰的一堆小目标，并且在每次有进步的时候给自己一些正常反馈，慢慢的就会让我们像爱上游戏一样爱上成长。当然，这很难做到，我目前尝试过一些游戏化人生目标的软件，例如非常知名的<a href="https://habitica.com/static/home">Habitica - Gamify Your Life</a>、还有我的小目标等，都没能坚持下来。</p><p>总结一下，本文主要是对认知觉醒中关于耐心这章的一些思考和补充，我们需要先明确耐心是什么，有什么用。然后再深入探究一下为什么我们总是会半途而废，从自身内部和外部因素找原因。最后探讨我们应该如何延迟满足，如何成为一个长期主义者。当然，我也还在“间歇性努力”挣扎中，希望完整精读实践完本书能做出进一步的改变。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.samwei12.cn/2024/08/14/Reading/%E8%AE%A4%E7%9F%A5%E8%A7%89%E9%86%92-3-%E6%88%90%E4%B8%BA%E9%95%BF%E6%9C%9F%E4%B8%BB%E4%B9%89%E8%80%85/&quot;&gt;原文链接&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们为什么做事情总是容易半途而废呢？哪怕自己明知道阅读、运动对自己是有好处的，但总是坚持不了几天就会放弃，背后的原因到底是什么呢？真的只是因为自己没有足够的耐心吗？&lt;/p&gt;
&lt;h2 id=&quot;什么是耐心？&quot;&gt;&lt;a href=&quot;#什么是耐心？&quot; class=&quot;headerlink&quot; title=&quot;什么是耐心？&quot;&gt;&lt;/a&gt;什么是耐心？&lt;/h2&gt;&lt;p&gt;想要解答这个问题，我们首先需要定义什么是耐心？&lt;br&gt;周岭在《认知觉醒》中提出的观点是本能脑和情绪脑天生就是缺乏耐心的，而理智脑才是真正让我们能长期坚持做某件无法立竿见影事情的关键。最直观的例子是在婴幼儿时期，理智脑的发育是很不健全的，所以小孩子的任何行为都想要立马得到回应，否则就会立刻哭闹。另一个案例是大家都熟知的&lt;a href=&quot;https://zh.wikipedia.org/zh-cn/%E6%A3%89%E8%8A%B1%E7%B3%96%E5%AE%9E%E9%AA%8C&quot;&gt;棉花糖实验 - 维基百科，自由的百科全书&lt;/a&gt;，能够坚持 15 分钟，领取两份奖励的小孩在未来的成就通常会高于立刻领取奖励的那些孩子，这从另一个方面说明延迟满足能力强的人在人生道路上有可能会走的更远。&lt;br&gt;因此作者说， 耐心不是毅力带来的结果，而是具有长远目光的结果。&lt;/p&gt;</summary>
    
    
    
    <category term="Reading" scheme="http://blog.samwei12.cn/categories/Reading/"/>
    
    
    <category term="认知觉醒" scheme="http://blog.samwei12.cn/tags/%E8%AE%A4%E7%9F%A5%E8%A7%89%E9%86%92/"/>
    
    <category term="读书笔记" scheme="http://blog.samwei12.cn/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    <category term="延迟满足" scheme="http://blog.samwei12.cn/tags/%E5%BB%B6%E8%BF%9F%E6%BB%A1%E8%B6%B3/"/>
    
  </entry>
  
  <entry>
    <title>认知觉醒-2-焦虑的根源</title>
    <link href="http://blog.samwei12.cn/2024/08/13/Reading/%E8%AE%A4%E7%9F%A5%E8%A7%89%E9%86%92-2-%E7%84%A6%E8%99%91%E7%9A%84%E6%A0%B9%E6%BA%90/"/>
    <id>http://blog.samwei12.cn/2024/08/13/Reading/%E8%AE%A4%E7%9F%A5%E8%A7%89%E9%86%92-2-%E7%84%A6%E8%99%91%E7%9A%84%E6%A0%B9%E6%BA%90/</id>
    <published>2024-08-13T15:00:35.000Z</published>
    <updated>2024-08-14T01:04:57.711Z</updated>
    
    <content type="html"><![CDATA[<p>今天读完了《认知觉醒》中作者关于焦虑的思考和总结，提到了焦虑的 5 种形式，包括：</p><ol><li>完成焦虑：尤其是在当下工作环境中，牛马打工人每天被迫完成大量任务，被各种 Deadline 逼得焦头烂额的时候还要经常处理来自老板们的打断，插入一堆高优先级事项。</li><li>定位焦虑：俗话说，“没有对比就没有伤害”，看着同学们一个个飞黄腾达，内心难免会觉得自己掉队了。</li><li>选择焦虑：对于很多个人规划或者说很多重要不紧急的事情，我们经常会无法决策该先做什么，决策本身是一件很消耗精力的事情。</li><li>环境焦虑：尤其是对于人到中年，不得不面临各种家庭琐事的时候，想要深造技术或者搞副业会面临各种各样的困难。比如你打算静下心来写文章、发视频，却不得不临时被打断去收拾家务、辅导小孩等。</li><li>难度焦虑：例如啃算法、看论文，面对超过自己当前认知水平的难题，不知道该如何下手时，自然会无比焦虑。</li></ol><p>而《麦肯锡结构化战略思维》作者周国元对焦虑的定义比较简单直接，焦虑的根源是不确定性，尤其是在面对“百万美元问题”时，不管是公司决策还是个人规划，我们总是担心决策错误，但又无法掌控所有细节，面对这些模糊或者不确定性，就会产生焦虑。 </p><p>结合周岭的 5 种不同焦虑形式，不得不佩服王小波的概括是真的非常到位，“人的一切痛苦，本质上都是对自己无能的愤怒”，可以同时涵盖上面提到的各种焦虑形式。因为发现跟同龄人差距越来越大，对自己一事无成的愤怒；因为选择太多，无法决策的迷茫；因为环境的限制而产生的无力感；因为任务太困难，不知道如何下手的困惑，这些通通都可以归结为对自己无能产生的愤怒。</p><p>回到自己身上来，回顾过去，发现自己经常会陷入“间歇性努力”的困境，每当迷茫徘徊一段时间之后，总会突然觉得自己应该做出改变，从而开始制定计划，健身、阅读、写作、编程、冥想等等，总感觉对于自己来说这些都非常重要，总是觉得时间不够用，但经常坚持不了几天就会回到之前刷短视频、玩游戏的老路上。究其原因还是没有耐心，急于求成，发现无法得到正反馈之后就顺从大脑趋易避难的天性，自动选择那些不需要消耗大量脑力的事情上。同时每次放弃努力还会让自己产生愧疚、焦虑不安，还不如彻底躺平来的痛快。</p><p>目前看下来，这本书非常契合自己当下的现状，先放下自己之前各种不成功的案例，别想太多，按照作者的思路实践一段时间。大不了再间歇努力一次 :)​</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天读完了《认知觉醒》中作者关于焦虑的思考和总结，提到了焦虑的 5 种形式，包括：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;完成焦虑：尤其是在当下工作环境中，牛马打工人每天被迫完成大量任务，被各种 Deadline 逼得焦头烂额的时候还要经常处理来自老板们的打断，插入一堆高优先级事项。&lt;</summary>
      
    
    
    
    <category term="Reading" scheme="http://blog.samwei12.cn/categories/Reading/"/>
    
    
    <category term="元认知" scheme="http://blog.samwei12.cn/tags/%E5%85%83%E8%AE%A4%E7%9F%A5/"/>
    
    <category term="认知觉醒" scheme="http://blog.samwei12.cn/tags/%E8%AE%A4%E7%9F%A5%E8%A7%89%E9%86%92/"/>
    
    <category term="读书笔记" scheme="http://blog.samwei12.cn/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    <category term="焦虑" scheme="http://blog.samwei12.cn/tags/%E7%84%A6%E8%99%91/"/>
    
  </entry>
  
  <entry>
    <title>认知觉醒-1-大脑的构造</title>
    <link href="http://blog.samwei12.cn/2024/07/29/Reading/%E8%AE%A4%E7%9F%A5%E8%A7%89%E9%86%92-1-%E5%A4%A7%E8%84%91%E7%9A%84%E6%9E%84%E9%80%A0/"/>
    <id>http://blog.samwei12.cn/2024/07/29/Reading/%E8%AE%A4%E7%9F%A5%E8%A7%89%E9%86%92-1-%E5%A4%A7%E8%84%91%E7%9A%84%E6%9E%84%E9%80%A0/</id>
    <published>2024-07-29T15:18:43.000Z</published>
    <updated>2024-08-08T15:12:56.748Z</updated>
    
    <content type="html"><![CDATA[<p>最近重新开始审视自己的生活和规划，无意间在微信读书上看到了《认知觉醒》这本书评价挺不错的，所以通过听书和看书的方式进行了学习，感觉对自己的现状很有启发，简单记录一下自己的读书心得。</p><h2 id="大脑的构造导致了你就是不爱学习"><a href="#大脑的构造导致了你就是不爱学习" class="headerlink" title="大脑的构造导致了你就是不爱学习"></a>大脑的构造导致了你就是不爱学习</h2><p>本书提到，人类的大脑是由三部分构成的，可以分别称为本能脑、情绪脑、理智脑，它们是在人类演化过程中逐步发展起来的，其中本能脑大约是 3.6 亿年前开始出现，情绪脑大约是 2 亿年前，理智脑是最晚出现的，大约在 250 万年前。</p><p>人类之所以能够在地球上各个生物之中脱颖而出，靠的就是我们的思考和认知能力，也就是理智脑。</p><p><img src="https://learner.oss-cn-hangzhou.aliyuncs.com/img/202407292323504.png" alt="202407292323504"></p><span id="more"></span><blockquote><p>这里作者提到理智脑是人类独有的，其他动物没有，我简单考证了一下，几乎所有的哺乳动物都有新皮层（也就是理智脑），其中灵长类的结构与人类非常相似，只是人类的新皮层尤为发达而已。</p></blockquote><h3 id="避难趋易和急于求成"><a href="#避难趋易和急于求成" class="headerlink" title="避难趋易和急于求成"></a>避难趋易和急于求成</h3><p>同时，另一个知识点是由于它们的演化时间是完全不成比例的，所以导致理智脑对于身体的掌控是不足的，我们日常生活中的绝大部分行为都是受本能脑和情绪脑所控制的。例如你从来不用考虑自己是如何呼吸的，也不需要刻意控制自己的走路方式，早上出门刷牙洗脸也不需要有专门的思考。<br>在人类漫长的演化过程中，本能脑和情绪脑占据主导地位，帮助我们趋利避害在资源短缺的时代生存了下来。但在当下的时代，本能脑这种工作方式无疑对我们的学习和成长造成了困扰。因为本能脑还认为我们需要尽可能的节约能量，所以会尽可能的挑那些简单的、舒适的工作，而不让我们的理智脑参与工作，因为理智脑工作会消耗大量的能量；同时因为在过去，人们需要随时提防身边的危险，当然也没有必要进行长期的规划，从而造成了我们需要获取即时反馈的特性，如果某件事做了之后没有能立马看到效果，就会被迅速放弃掉换下一个任务。<br>用作者的说法，虽然现在我们生活在现代社会的高楼大厦中，西装革履的进行工作，但本质上我们的天性仍然还是那个目光短浅、随时准备战斗或及时享乐的“原始人”。</p><h3 id="对我们的帮助"><a href="#对我们的帮助" class="headerlink" title="对我们的帮助"></a>对我们的帮助</h3><p>知道了这个以后对我们有什么帮助呢？我们可以从脑科学的角度分析一些平时我们觉得非常不理智的行为，毕竟改变的第一步是我们先要有所察觉。</p><p>例如，当我们在跟别人吵架的时候，很容易一上头说了很多气话，做出很多过激的、不理智的行为，事后想想会觉得自己怎么这么傻？如果我们在愤怒的时候能够意识到自己已经被情绪脑所掌控了，稍微冷静一下，也许就会对我们有很大帮助。<br>再比如，很多时候，早上醒来第一件事就是拿起手机，完全是一个无意识行为，但一旦打开手机之后，看看天气、看看微信有没有新消息、刷刷新闻，因为手机上的各种软件背后的产品每天都在研究如何让你始终能快速获得反馈，很容易让你产生“时间黑洞”，突然发现已经过去了半小时，匆忙洗漱吃饭赶去上班。如果我们能察觉到自己这种行为是被本能控制了，提高我们的认知能力，学会如何打破这种惯性的力量，对我们的工作学习效率无疑是有很大提升的。</p><p>成功人士无一不是理性脑占据主导，有自己长远的规划和很强的延迟满足能力。我们如果也想要让自己的理智脑占据更多的主动，不愿意被本能和情绪控制，那首先我们就需要对脑科学有所了解，明白为什么我们会表现出现在的特点，只有升级了自己的认知，有所察觉，才能进行后续的改变。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近重新开始审视自己的生活和规划，无意间在微信读书上看到了《认知觉醒》这本书评价挺不错的，所以通过听书和看书的方式进行了学习，感觉对自己的现状很有启发，简单记录一下自己的读书心得。&lt;/p&gt;
&lt;h2 id=&quot;大脑的构造导致了你就是不爱学习&quot;&gt;&lt;a href=&quot;#大脑的构造导致了你就是不爱学习&quot; class=&quot;headerlink&quot; title=&quot;大脑的构造导致了你就是不爱学习&quot;&gt;&lt;/a&gt;大脑的构造导致了你就是不爱学习&lt;/h2&gt;&lt;p&gt;本书提到，人类的大脑是由三部分构成的，可以分别称为本能脑、情绪脑、理智脑，它们是在人类演化过程中逐步发展起来的，其中本能脑大约是 3.6 亿年前开始出现，情绪脑大约是 2 亿年前，理智脑是最晚出现的，大约在 250 万年前。&lt;/p&gt;
&lt;p&gt;人类之所以能够在地球上各个生物之中脱颖而出，靠的就是我们的思考和认知能力，也就是理智脑。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://learner.oss-cn-hangzhou.aliyuncs.com/img/202407292323504.png&quot; alt=&quot;202407292323504&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Reading" scheme="http://blog.samwei12.cn/categories/Reading/"/>
    
    
    <category term="元认知" scheme="http://blog.samwei12.cn/tags/%E5%85%83%E8%AE%A4%E7%9F%A5/"/>
    
    <category term="认知觉醒" scheme="http://blog.samwei12.cn/tags/%E8%AE%A4%E7%9F%A5%E8%A7%89%E9%86%92/"/>
    
    <category term="读书笔记" scheme="http://blog.samwei12.cn/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Logseq 系列之同步插件</title>
    <link href="http://blog.samwei12.cn/2022/09/11/Utilities/Logseq/Logseq%20%E7%B3%BB%E5%88%97%E4%B9%8B%E5%90%8C%E6%AD%A5%E6%8F%92%E4%BB%B6/"/>
    <id>http://blog.samwei12.cn/2022/09/11/Utilities/Logseq/Logseq%20%E7%B3%BB%E5%88%97%E4%B9%8B%E5%90%8C%E6%AD%A5%E6%8F%92%E4%BB%B6/</id>
    <published>2022-09-11T14:37:13.000Z</published>
    <updated>2024-07-31T18:16:36.790Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原文地址： <a href="https://blog.samwei12.cn/2022/09/11/Utilities/Logseq/Logseq%20%E7%B3%BB%E5%88%97%E4%B9%8B%E5%90%8C%E6%AD%A5%E6%8F%92%E4%BB%B6/">Logseq 系列之同步插件 | samwei12’s blog</a></p></blockquote><p>前些天看到群友们讨论 Logseq 要是能够在不同设备间同步插件和主题就好了，目前 Logseq 官方同步已经在小规模测试中，预计再有一两个月就会发布，未来大概率会出同步插件的功能。不过考虑到官方同步的免费使用空间肯定不会很大，如果有大量的本地图片或者其他文档类文件，就不适合免费用了，且主要是现在的 Git 同步方案已经非常好用（重点是免费！），所以还是考虑完善一下现有的方案，短时间内不迁移官方同步。</p><span id="more"></span><p>因为之前在 <a href="https://blog.samwei12.cn/2022/08/28/Utilities/Logseq%20%E7%B3%BB%E5%88%97%E4%B9%8B%E6%96%87%E6%A1%A3%E7%AE%A1%E7%90%86/#more">Logseq 系列之文档管理 | samwei12’s blog</a> 已经分享过个人的文档管理方案，细心的同学可能会发现，我的资源文件中有一个 ebooks 的软链接文件夹，我用它来存放各种电子书，这样的话就可以在不同步电子书到 Git 仓库的同时还能直接使用 Logseq 的本地 PDF 标注功能，这一部分后面有机会可以详细说说。</p><p>我这里主要是想提一下系统的文件软链接这个功能，尤其是对于 *nix（包括 Mac）系统来说，软链接几乎可以当作原始文件来使用，由于系统层面的抽象工作做的非常好，对于上层使用的软件来说，可以做到完全无感，这也是上面非 assets 目录下 PDF 标注功能能使用的前提。正因为之前使用过这个功能，所以在考虑插件同步方案的时候，我第一时间就想到了是否可以尝试用软链接来解决呢？答案是肯定的。</p><p>对于 Logseq 来说，基本的配置信息都在用户目录下的一个隐藏文件夹 <code>.logseq</code> 中，如图：</p><p><img src="https://learner.oss-cn-hangzhou.aliyuncs.com/img/20220911225437.png" alt="20220911225437"></p><p>其中， plugins 目录存放的就是我们下载的各种插件，以及各种主题； settings 目录则是这些插件的配置信息，而 preferences.json 这个文件则记录了我们的各种配置信息，包括使用的是什么主题、启用了哪些插件等等，graphs 文件夹存放的是各个笔记库的一些数据索引信息，通常我们不需要关心，git 文件夹是开启 git 自动提交使用的，也不需要关心。我们只需要确保 plugins settings 和 preferences.json 这几个文件和目录在不同电脑上内容一致即可。</p><p>这里我的思路是，将这几个我们需要同步的目录内容拷贝到自己的 Logseq 文件夹中，使用 git 进行同步，然后在每台电脑上，使用软链接将 <code>.logseq</code> 中这几个文件关联到我们 git 仓库中这一份，这样就做到了不同设备之间的插件和配置同步，流程大概长这样：</p><p><img src="https://learner.oss-cn-hangzhou.aliyuncs.com/img/20220911230219.png" alt="20220911230219"></p><p>确定了方案之后，具体的执行其实就很简单了：</p><ol><li>把用户目录下的 <code>.logseq</code> 中的内容拷贝到你的 git 仓库中，移除 graphs git 这两个我们不需要的目录。</li><li>删除 <code>.logseq</code> 中 plugins settings preferences.json 文件</li><li>进入到 <code>.logseq</code> 目录中，创建对应的软链接</li></ol><p>命令如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ln</span> -s xxx/.logseq/preferences.json preferences.json</span><br><span class="line"><span class="built_in">ln</span> -s xxx/.logseq/plugins plugins</span><br><span class="line"><span class="built_in">ln</span> -s xxx/.logseq/settings settings</span><br></pre></td></tr></table></figure><p>把其中的 xxx 替换为你电脑上 git 仓库的目录即可，之后在新的设备上重复上述操作。</p><p>至此，我们就实现了多设备间插件、主题以及用户配置的同步，而且继续保持我们的优良传统，免费自建，希望本文对你有所帮助～</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;原文地址： &lt;a href=&quot;https://blog.samwei12.cn/2022/09/11/Utilities/Logseq/Logseq%20%E7%B3%BB%E5%88%97%E4%B9%8B%E5%90%8C%E6%AD%A5%E6%8F%92%E4%BB%B6/&quot;&gt;Logseq 系列之同步插件 | samwei12’s blog&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;前些天看到群友们讨论 Logseq 要是能够在不同设备间同步插件和主题就好了，目前 Logseq 官方同步已经在小规模测试中，预计再有一两个月就会发布，未来大概率会出同步插件的功能。不过考虑到官方同步的免费使用空间肯定不会很大，如果有大量的本地图片或者其他文档类文件，就不适合免费用了，且主要是现在的 Git 同步方案已经非常好用（重点是免费！），所以还是考虑完善一下现有的方案，短时间内不迁移官方同步。&lt;/p&gt;</summary>
    
    
    
    <category term="Utilities" scheme="http://blog.samwei12.cn/categories/Utilities/"/>
    
    
    <category term="Logseq" scheme="http://blog.samwei12.cn/tags/Logseq/"/>
    
    <category term="Git" scheme="http://blog.samwei12.cn/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Logseq 系列之文档管理</title>
    <link href="http://blog.samwei12.cn/2022/08/28/Utilities/Logseq%20%E7%B3%BB%E5%88%97%E4%B9%8B%E6%96%87%E6%A1%A3%E7%AE%A1%E7%90%86/"/>
    <id>http://blog.samwei12.cn/2022/08/28/Utilities/Logseq%20%E7%B3%BB%E5%88%97%E4%B9%8B%E6%96%87%E6%A1%A3%E7%AE%A1%E7%90%86/</id>
    <published>2022-08-28T10:07:05.000Z</published>
    <updated>2024-08-01T02:41:41.860Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要是介绍一下我自己在使用 Logseq 进行文档管理时遇到的一些问题以及解决方案。</p><h2 id="现状"><a href="#现状" class="headerlink" title="现状"></a>现状</h2><p>目前 Logseq 针对各种文档、图片等外部资源的管理形式比较简单，统一放到 <code>assets</code> 这里目录下进行管理，在实际使用中通过相对路径进行引入，大概是下图这样：</p><p><img src="https://learner.oss-cn-hangzhou.aliyuncs.com/img/20220828181355.png" alt="20220828181355"></p><span id="more"></span><p>可以看到，这里面包含了 PDF 标注文件、音频文件、视频文件、各种图片资源等，这样做的好处非常明显，可以统一管控全部资源，做到各平台体验一致，包括在移动端上也能够正常查看图片、音频等，例如下图的思维导图，引入之后，点击链接电脑上可以打开进行文件编辑等，比较方便。</p><p><img src="https://learner.oss-cn-hangzhou.aliyuncs.com/img/20220828182234.png" alt="20220828182234"></p><p><img src="https://learner.oss-cn-hangzhou.aliyuncs.com/img/20220828182126.png" alt="20220828182126"></p><p>同样的，这样做的缺点也比较明显，你在 Logseq 中使用的全部资源都会拷贝一份到它自己的资源目录中，如果是截图这种偶尔使用一下的资源还好，如果是工作学习中使用到的文档，就会很不方便，无法进行管理，毕竟你并不是只在 Logseq 中使用这些文档。</p><h3 id="问题一：文件检索管理"><a href="#问题一：文件检索管理" class="headerlink" title="问题一：文件检索管理"></a>问题一：文件检索管理</h3><p>首先，Logseq 本身并不是一个用于管理文档的软件，只有最基本的检索和打开功能，一旦文件变多了之后，没有目录层级、没有标签，文档的检索会成为一个很严重的问题，当然你可以通过单独建立一个 page，把相关文档都放在其中，以实现打标等功能，但操作路径会比较别扭且略有成本。</p><p>同时当你拖拽文档进入 Logseq 之后，你的电脑中存放了两份相同内容的文档，且以后你只能以 Logseq 中这一份为准，之前的拷贝必须删掉，不然你就会面临更新编辑无法同步到 Logseq 的问题。之后，当你想要进行文件编辑的时候，只能通过 Logseq 点击打开进行，因为当你的 assets 文件夹中包含了成千上万截图、文档资料的时候，你几乎不可能在文件夹中进行查看管理。<br>有时候你可能并不是想编辑，而仅仅是想要分享给同事，你会发现，如何在本地文件中找到并发给他并不容易，我目前想到的路径是找到该资源对应的 block，点击查看 Logseq 进行改动后的文件名，然后把相对链接拼接你本地 Logseq 的路径，转换成绝对路径，这样就可以在系统资源管理器中打开了，毫无疑问，这个操作成本非常高（这里也可以考虑使用一些类似 Spotlight 或Alfred 这样的软件进行文件索引，相对成本低很多）。</p><h3 id="问题二：同步问题"><a href="#问题二：同步问题" class="headerlink" title="问题二：同步问题"></a>问题二：同步问题</h3><p>第二个问题，就是随着你的长期使用，assets 的大小会逐步膨胀，这在多设备之间同步的时候就会慢慢变成一个你无法忽视的问题。如果你用的是同步盘，这个问题还稍微好点（不过同步盘自身就有很大问题）。如果你像我一样，使用的是 Git 同步 （参考<br><a href="https://blog.samwei12.cn/2022/08/12/Utilities/Logseq%E7%B3%BB%E5%88%97%E4%B9%8BGit%E5%90%8C%E6%AD%A5/">Logseq 系列之 Git 同步 | samwei12’s blog</a> ），你会发现随着你的使用，你的 Logseq 文件夹膨胀速度比你想象中的快很多。这是因为 git 本身的原理是基于记录你每次提交的文件变化来进行跟踪，当你使用文本文件的时候（也就是非二进制文件），通常每次提交 git 会准确的把其中几行改动记录下来以便进行版本管理；但当你使用的是二进制文件，由于本身比对改动非常不方便（即使把改动的二进制变化贴给你你也看不懂，自然也就失去了意义），所以很多时候都会直接把改动前后的版本都记录下来，这也就意味着，假如你有一个 100MB 大小的 PS 文件，即使你只改动了其中一个像素，那么提交的时候也会把改动后的这 100MB 大小的新文件提交上去，不难想象，随着你改动的文档以及频次变多，你的 assets 文件夹会轻松变为一个几十 GB 的庞然大物，让你的同步变得非常困难。</p><blockquote><p>注： Git 本身提供了对于大文件管理的专用方案，<a href="https://git-lfs.github.com/">Git Large File Storage | Git Large File Storage (LFS) replaces large files such as audio samples, videos, datasets, and graphics with text pointers inside Git, while storing the file contents on a remote server like GitHub.com or GitHub Enterprise.</a>，但有一定的使用成本。</p></blockquote><h2 id="个人解决方案"><a href="#个人解决方案" class="headerlink" title="个人解决方案"></a>个人解决方案</h2><p>那么如何解决这些问题呢？首先，我们需要一个专门的文件管理软件，它能够进行正常的文件目录、标签、检索、预览编辑等操作，同时，我们还需要能够在 Logseq 中插入对应的文件链接，以便在笔记中进行引用。</p><p>针对上面的诉求，我第一时间想到的就是 <a href="https://www.devontechnologies.com/apps/devonthink">DEVONtechnologies | DEVONthink, professional document and information management for the Mac and iOS</a> 这款软件，它同时支持苹果全家桶，是专业的个人知识文档管理软件，不光能够进行检索、标签，甚至还可以进行网页抓取，防止网址失效，可以说是目前 Mac 平台里面最专业的最好用的管理工具了，唯一的问题大概就是价格过于高昂，当然可能这不是它的问题。</p><p>有了文档管理软件之后，我们再解决文件链接引用的问题，这里我们引入一个术语，URI scheme， 可以通过 <a href="https://en.wikipedia.org/wiki/List_of_URI_schemes">List of URI schemes - Wikipedia</a> 了解一下， 简单点来说就是一种约定好的资源标识链接格式，通过这个链接以及一些约定好的参数，就可以通过跳转链接来唯一定位软件中资源，然后就可以实现一些功能。 最常用的例子就是文件管理器中的文件路径，例如，文件管理器规范为 <code>file://[host]/path</code>， 这是大家统一约定好的，路径大概长这样 <code>file:///Users/samwei12/Downloads/docker/Dockerfile</code>，通过这个路径就能唯一定位到文件夹中的这个文件。</p><p><img src="https://learner.oss-cn-hangzhou.aliyuncs.com/img/20220828204040.png" alt="20220828204040"></p><p>通过 URI Scheme，我们就可以在 Logseq 中引入文件链接来做到点击跳转，跟普通使用一个网址没有什么区别，就像这样： </p><p><img src="https://learner.oss-cn-hangzhou.aliyuncs.com/img/20220828204645.png" alt="20220828204645"></p><p>同样的， Devonthink 也支持 URI Scheme，而且支持的更好。它的 Scheme 格式长这样 <code>x-devonthink-item://C81BB953-8659-4AE7-9E89-143C4F6036BC</code> ，看起来就是普通的 UUID，但它比 Finder 强大太多了，除了能够直接点击定位以外，它最大的优势就是<strong>可以在文件位置变更之后依然能够定位到文件</strong>！有没有感觉很棒？ 试想一下，当你的文件夹位置稍微有所调整，所有已经引用的文件路径全部作废，有没有很难受？这时候你就会发现 DevonThink 是多么的强大，甚至改了名字之后，这个链接依然有效！包括搜索的时候，不光可以名字搜索、标签搜索、文件夹搜索，还会根据你的文档使用和打开频率给他们打分，把分数高的排在前面，非常的方便。基本上使用了它之后，你就不会再想用系统文件夹进行文件管理了。</p><p><img src="https://learner.oss-cn-hangzhou.aliyuncs.com/img/20220828223456.png" alt="20220828223456"></p><p>那么我们的第一个问题，文件资源管理器以及引用就解决了，那么现在来解决第二个同步问题，这里目前我的解决方案还不是很完美，但基本满足我个人的诉求了。</p><p><img src="https://learner.oss-cn-hangzhou.aliyuncs.com/img/20220828224142.png" alt="20220828224142"></p><p>DevonThink 支持两种方式建立索引，方式一是 Import，也就是类似 Logseq 这种，把文档全部拷贝到自己的管理系统中统一处理，这样做的好处就是可以使用它自己的一整套管理体系，包括数据同步、客户端等，但也会受限于它的服务器连接速度，可以说各有利弊，毕竟自由控制跟统一管理总是没法同时满足需求的，想要做到统一的体验，就需要牺牲一些东西。如果你不愿意把自己限定在 DevonThink 的体系里面，它很人性的提供了方式二，也就是 Index 这种，它的使用方式是你自己提供一个已有的本地文件夹，它仅仅通过检索文件信息来进行管理，这样做最大的好处就是既能够享受它强大的标签、索引系统，还可以自己本地保留管理的权利，不必 Lock-in 在这个软件里面，如果你选择了方式一，想要自己手动进行管理会麻烦很多。</p><p>我选择使用方式二，我借鉴了 PARA 的概念，本地专门有一个名为 Resources 的文件夹，它的作用就是用于管理我的全部个人文档，可以使用树状目录，也可以使用 DevonThink 的标签系统，或者 Finder 的标签系统，然后使用方式二把它添加索引，拷贝链接到 Logseq 中进行使用即可。如果你需要的话，只要把这个文档文件夹使用同步盘进行同步，就可以做到跨电脑使用，而 Logseq 目录中仅包含文本文件，体积非常可控。不过日常使用中为了方便，图片资源我还是都使用 assets 文件夹，而 pdf 文件，我有单独的管理方式，也可以认为不在 assets 中，后面有机会再分享。这样做的好处就是我整个包含了全部笔记的 Logseq 文件夹，也就不到 500MB，对 Git 的压力就非常小了。<br>当然，有利就有弊，方式二最大的问题就是多平台体验会不一致，由于文档文件本身还是在电脑设备上，通过云盘还可以做到跨电脑使用，但移动端就不可用了，原因是 iOS 端苹果的系统限制，软件通常只能访问自己应用目录下的文件，无法跨应用进行访问，DevonThink 移动端也只能访问方式一那种自己管理的数据，不过由于我个人在移动端仅仅是查看笔记居多，几乎也没有这方面的诉求，所以这个影响可以忽略不计。</p><h3 id="提效小-tips"><a href="#提效小-tips" class="headerlink" title="提效小 tips"></a>提效小 tips</h3><p>这里不得不赞一下国外软件的开放特性，通常大家都是在思考如何把自己的功能做的标准化，可以让更多的软件融入进来，而国内软件大部分都是思考如何让自己的软件封闭化，全部功能只靠自己就可以做到，好像做开放一点自己的用户就会被其他人抢走一样，思考一下你平时用的国产软件有多少支持 URI Scheme？又有多少国外软件支持 URI Scheme？<br>扯远了，回到正题，DevonThink 有一款 Alfred 插件。Alfred 同样是一款非常棒的软件，类似于 Windows 下的 everything，但功能要强大太多了。不光可以替代掉各种剪切板软件、计算器、文本替代软件，还提供了非常棒的插件功能。 </p><p><img src="https://learner.oss-cn-hangzhou.aliyuncs.com/img/20220828230343.png" alt="20220828230343"></p><p>安装了这个插件之后，可以直接在 Alfred 中输入 dnt 或者 dnw 缩写，即可实现与检索本地的 DevonThink 软件相同的功能，非常方便，详见 <a href="https://github.com/mpco/AlfredWorkflow-DEVONthink-Search">mpco&#x2F;AlfredWorkflow-DEVONthink-Search: Powerful Tool for Searching in DEVONthink.</a> 。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>至此，本文就介绍完了我自己如何在 Logseq 中进行文档的管理和使用，虽然是依托了 DevonThink 这个非常棒的软件，但整体思路是不受限于此的，但凡是可以提供稳定 URI Scheme 的软件均可以替换掉它，比如 Obsidian 也很棒。只是说在文档管理本身上功能略有偏差，但对于减负 Logseq 来说足够用了，再配合一个同步盘，可以做到多设备同步。<br>如果本文对你有所帮助或者你有其他方式，欢迎留言交流~</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文主要是介绍一下我自己在使用 Logseq 进行文档管理时遇到的一些问题以及解决方案。&lt;/p&gt;
&lt;h2 id=&quot;现状&quot;&gt;&lt;a href=&quot;#现状&quot; class=&quot;headerlink&quot; title=&quot;现状&quot;&gt;&lt;/a&gt;现状&lt;/h2&gt;&lt;p&gt;目前 Logseq 针对各种文档、图片等外部资源的管理形式比较简单，统一放到 &lt;code&gt;assets&lt;/code&gt; 这里目录下进行管理，在实际使用中通过相对路径进行引入，大概是下图这样：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://learner.oss-cn-hangzhou.aliyuncs.com/img/20220828181355.png&quot; alt=&quot;20220828181355&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Utilities" scheme="http://blog.samwei12.cn/categories/Utilities/"/>
    
    
    <category term="Logseq" scheme="http://blog.samwei12.cn/tags/Logseq/"/>
    
  </entry>
  
  <entry>
    <title>十步学习法与程序员延寿指南</title>
    <link href="http://blog.samwei12.cn/2022/08/20/Reading/%E5%8D%81%E6%AD%A5%E5%AD%A6%E4%B9%A0%E6%B3%95%E4%B8%8E%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BB%B6%E5%AF%BF%E6%8C%87%E5%8D%97/"/>
    <id>http://blog.samwei12.cn/2022/08/20/Reading/%E5%8D%81%E6%AD%A5%E5%AD%A6%E4%B9%A0%E6%B3%95%E4%B8%8E%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BB%B6%E5%AF%BF%E6%8C%87%E5%8D%97/</id>
    <published>2022-08-20T13:47:28.000Z</published>
    <updated>2024-07-31T18:16:36.786Z</updated>
    
    <content type="html"><![CDATA[<p>最近一直在思考如何制定自己的个人目标，凑巧某天开车的时候在微信读书上听到了<a href="https://book.douban.com/subject/36044253/">《软技能：代码之外的生存指南》</a> 这本书，里面提到的关于程序员职业生涯规划部分十分受用，后来到喜马拉雅上找了个更好的版本，快速把第一篇听了一遍，并且趁周末仔细的阅读了一下电子版。</p><p>目前整本书还没有读完，我挑了其中个人比较感兴趣的职业篇和学习篇阅读完了，其中职业篇有介绍到设置一个人生目标，而学习篇则介绍了作者本人总结的一套学习方法，他称之为 “十步学习法”，本篇文章主要就是我自己使用十步学习法进行个人目标设置和规划的一些实践。</p><span id="more"></span><h2 id="什么是十步学习法？"><a href="#什么是十步学习法？" class="headerlink" title="什么是十步学习法？"></a>什么是十步学习法？</h2><p>作者说自己 33 岁就已经实现了财务自由，且同时还是一个健身博主、营销专家，本书的序其中还有 Robert C. Martin 这样的大牛，说明作者本身在编程领域也有很深的造诣，这些跟他自己的学习方法关系密切。同时他还利用自己总结的这套学习方法在一年内开发了超过 30 个适合开发人员的长期培训课程。当然，很多这种所谓的成功学都是有很多水分的，我们只需要借鉴其中个人觉得有价值的东西即可。</p><p>这里我先直接上一张书里面的图： </p><p><img src="https://learner.oss-cn-hangzhou.aliyuncs.com/img/20220821101304.png" alt="20220821101304"></p><p>十步学习法的基本思想就是先对自己所需要学习的内容有一个基本的了解，知道自己有哪些不会的知识点，再根据这个圈定好的范围明确目标和计划的制定。</p><p>整个方法分为十步，所以被称为“十步学习法”，其中，1-6 是一次性解决的问题，7-10 则是需要重复训练学习的部分。从整个大的流程来看，十步学习法跟 PDCA 工作法或者费曼学习法有很多共通之处，作者应该也是受了相关方法论的影响总结出的更加适合自己的方法。比如在学习之前，先明确自己的整体目标，开始学习之后，不要一头扎进去，而是要边玩边学，把自己实践过程中遇到的问题记录下来，汇总部分问题之后再回头看书学习解决问题。这与 PDCA 中，制定计划、执行、定期检查的流程基本类似；而十步学习法的最后是乐为人师，这应该也是借鉴学习金字塔或者费曼学习法而来，掌握知识或者技能的最好的办法就是教会他人自己所学到的东西，既可以在整理准备的过程中回顾自己学到的内容，又可以从他人的反馈中知道自己哪些地方还没有吃透。</p><p>对我个人而言，这套方法中最有价值的地方在于作者单独把 1-6，也就是如何制定目标和计划的部分加以抽象总结，这是我之前未在其他方法中看到过的。尤其是其中关于学习资源的部分，非常适用于当前这个知识大爆炸的时代，很多时候，人们并不是找不到资源，而是资源实在太多了，很容易淹没在信息大海里面，忘记了本身的初衷。</p><h2 id="个人实践心得"><a href="#个人实践心得" class="headerlink" title="个人实践心得"></a>个人实践心得</h2><p>我自己最近在思考的一个个人目标就是如何健康的长寿，不光要活得健康，最好还能活得久，读了这本书刚好练习学习方法的时候制定一下自己的长寿计划。在具体练习的过程中，我发现十步学习法稍微有点冗余。每次制定学习计划时，如果都 1-10 这么来一遍，过于繁琐，且很多时候你会发现按照 1-10 这种方式挨个执行，自己都不知道自己当前在第几步，这里指的主要是前面 1-6 的部分。 比如了解全局，如何了解呢？大多数人肯定还是网上搜索资料，那这一步跟 4 寻找资源有啥区别和联系？ 2. 确定范围 跟 3. 定义目标，本身感觉也容易边界不那么清晰。当然，作者本人也提到，并不一定非要按照他这个步骤来，这些步骤本身并不重要，重点是读者需要开发出一套适合自己的自学体系。</p><p>我把这十步划分为了四个大的部分，这样边界更加清晰，比较适合操作，跟原有的方法对应关系如图 </p><p><img src="https://learner.oss-cn-hangzhou.aliyuncs.com/img/20220821174104.png" alt="20220821174104"></p><h3 id="一、制定计划前的准备工作。"><a href="#一、制定计划前的准备工作。" class="headerlink" title="一、制定计划前的准备工作。"></a>一、制定计划前的准备工作。</h3><blockquote><p>你不知道哪些你不知道的事。</p></blockquote><p>这里包括原方法的 1-4 以及 6，重点是如何快速了解一个自己不知道或者不熟悉的主题，并且能够制定一个有明确目标的学习计划。我把筛选资源这一步也归类到准备工作中，原因是我个人觉得，在检索资源的同时，就应该利用自己的鉴别能力对资源进行筛选，只利用其中优质的资源进行计划的设定，把筛选步骤放在前面好过制定完学习计划之后发现这个信息源不靠谱，需要推倒重来。</p><p>为了能够制定一个学习计划，我们需要明确以下几个问题：</p><ol><li>我需要掌握哪些基本知识？</li><li>我现在学的东西有多宏大？我应该怎么做？</li><li>哪些是属于学习了就能满足 80% 日常使用的内容？</li></ol><p>以健康长寿计划为例，这里首先需要明确需要研究的主题是什么，此时因为对主题缺乏足够的了解，所以有一个模糊的概念即可。我比较关心的是如何健康长寿的生活，所以直接检索 “长寿” “健康” “不生病” 等关键词，以便对于这个主题有一定了解。</p><blockquote><p>关于信息检索，由于目前互联网发布信息的门槛过低，以及大量 <a href="https://zh.wikipedia.org/zh-my/%E5%85%A7%E5%AE%B9%E8%BE%B2%E5%A0%B4">内容农场 - 维基百科，自由的百科全书</a> 的存在，很有可能你检索到的信息会把你往沟里带，具体例子可以参考 <a href="https://zh.wikipedia.org/wiki/%E9%AD%8F%E5%88%99%E8%A5%BF%E4%BA%8B%E4%BB%B6">魏则西事件 - 维基百科，自由的百科全书</a>，这里强烈推荐使用 Google 或者 DuckDuckGo 引擎，同时，如果你英文水平尚可的话，优先使用英文进行检索，尤其适用于一些专业度非常高的主题（比如计算机、医学等）。</p></blockquote><p>在你检索得到一大堆结果之后，如何快速获取自己需要的主题信息以及如何进行筛选是另外一个很重要的工作。目前网络上的资源包括各种自媒体文章、视频、音频、书籍等等，很容易就让你眼花缭乱，忘记了自己想要做什么。在这里，我的一个小建议是，优先选用一些领域专家出版的书籍作为信息源，而不是各种自媒体文章或者其他信息。这样做的原因包括： </p><ol><li>通常来说，领域专家在他们自己的领域内，可信度较高，他们已经在各自领域积累了大量的知识。当然，非他们领域发表的观点可以忽视。</li><li>相对于自媒体文章来说，发表书籍成本更高一点，能够过滤掉大多非专业人士转载或者半懂不懂的观点。</li><li>一般书籍都会标明引用来源，所以往往一本好书会给你推荐更多此主题的好书。<br>当然，这同样带来了一个弊端，那就是书籍通常迭代速度比较慢，对于一些非常前沿的领域，往往通过书籍获取不到太多有用的信息。不过，对于绝大部分人来说，可能一辈子也没有多少学习这些前沿知识的机会，所以这个弊端可以接受。</li></ol><p>另一个关于了解主题的建议是，快速翻阅找到的这些书籍的目录。通常来说，作者在编写书籍目录的时候都是经过深思熟虑的，某主题的书籍目录，往往涵盖了这个主题大部分内容，且一般是由浅入深，带你逐步了解熟悉这个主题。所以翻阅目录能够让你在最短的时间内知道这个主题所涵盖的大部分知识，便于你选取自己的学习目标，制定计划。</p><p>拿我研究的长寿计划举例，在检索了相关关键词之后，我得到了一大堆文章，同时，我还在豆瓣、亚马逊等地方检索有关这些关键词的书籍，得到了一堆书籍，包括《管理你的健康》、 《人体的故事》、《端粒》、《长寿》、《人为什么会生病》等等。通过翻阅这些书籍的简介和目录，我大概知道了影响一个人健康和长寿的主要因素包括身体健康和心理健康，涉及到了医学、心理学、营养学等等内容。</p><p><img src="https://learner.oss-cn-hangzhou.aliyuncs.com/img/20220821181049.png" alt="20220821181049"></p><p>之后就是对这些资料进行筛选，同时慢慢对自己要研究的目标有了逐步清晰的认识，同时从 <a href="https://github.com/geekan/HowToLiveLonger">geekan&#x2F;HowToLiveLonger: 程序员延寿指南 | A programmer’s guide to live longer</a> 了解到了什么是全因死亡率。同时根据个人情况逐步对已有资料进行剔除，比如自我感觉心理状态还可以，可以先跳过心理健康相关书籍和资源；目前还比较年轻，同时也没有家族遗传病史，所以疾病学相关知识也可以先略过，等以后再研究。最终，明确我的目标变成了制定一个降低自己全因死亡率的初步计划（暂不包括心理健康、疾病学相关主题）。</p><p>检索资料和筛选的过程，就是逐步发现自己的目标，一步步靠近的过程，这里最实用的原则就是 ”二八定律“（也就是<a href="https://zh.wikipedia.org/wiki/%E5%B8%95%E7%B4%AF%E6%89%98%E6%B3%95%E5%88%99">帕累托法则 - 维基百科，自由的百科全书</a>）。个人精力是有限的，你不可能做到面面俱到，尤其是在你对一个新主题不了解的情况下，这时候如何根据自己当前的情况，明确自己下一步的目标就非常重要了。既能够节约你大量的时间，又能够让你摆脱知识焦虑。当你逐步达成了现有的目标之后再回过头来查漏补缺，对这个主题其他目标发动攻击。</p><h3 id="二、制定学习计划。"><a href="#二、制定学习计划。" class="headerlink" title="二、制定学习计划。"></a>二、制定学习计划。</h3><p>当你有了一个比较清晰的目标之后，接下来就是要制定一个可执行的学习计划，目标就像是航海中的目的地，而计划就是航线，没有目标或者航线你就会迷失在大海之中。制定计划的过程中最重要的原则就是 <a href="https://zh.wikipedia.org/wiki/SMART%E5%8E%9F%E5%88%99">SMART原则 - 维基百科，自由的百科全书</a>，其中我感觉最受用的就是可衡量 M、可达成 A、和时限 T。时限，不用多说，通常情况下，你的学习计划都需要一个截止时间，所谓的 deadline 是第一生产力一定程度上非常准确，大部分人制定的计划也都会包含这一点，但很多计划中缺失了可衡量和可达成原则。可达成不必多说，如果你给自己设定的目标压根完不成，那计划自然也就失去了意义，比如你希望自己长生不死，这违反了已知的自然规律，自然也就无法执行落地。可衡量的重要意义在于你需要明确的知道自己到底有没有达到这个目标，比如说你的目标是锻炼，那么每周锻炼三次或者今天锻炼 45 分钟都是一个非常好的目标，今天练到爽就是一个不可衡量的目标，因为爽的定义非常难，你今天觉得练得很爽，下次相同的练习就未必了。</p><p>降低自己的全因死亡率显然只是一个很粗略的目标，我们需要更加详细的执行计划，不过由于这个目标的特殊性，它并不是每个阶段产出结果的，我们只需要确保过程中的小目标都是可衡量，有时限的即可。</p><p>我自己的计划设定中，很多信息都是来源于 <a href="https://github.com/geekan/HowToLiveLonger">geekan&#x2F;HowToLiveLonger: 程序员延寿指南 | A programmer’s guide to live longer</a> ，推荐大家也都去了解一下。结合我自身的情况，以及是否可衡量，对已有的这些影响全因死亡率的因素进行过滤。比如，其中吸烟、喝酒等习惯我都没有，可以忽略；刷牙由于目前基本每天执行，也没必要放到计划中；同时，我尽量挑选那些影响比较大的因素（二八定律），所以少喝或不喝甜味饮料、多吃植物蛋白等也排除掉。得到一个可执行的计划：<br><img src="https://learner.oss-cn-hangzhou.aliyuncs.com/img/20220821184129.png" alt="20220821184129"></p><h3 id="三、在学习和实践中反复练习。"><a href="#三、在学习和实践中反复练习。" class="headerlink" title="三、在学习和实践中反复练习。"></a>三、在学习和实践中反复练习。</h3><p>有了一个可量化可执行的计划之后，接下来还需要解决一个很重要的问题，那就是目标追踪，也就是说你如何跟进你的进度，如何知道自己什么时候应该调整计划。现在这类目标跟踪软件网上非常多了，我自己最近在使用 Vision，这个是买断制软件，同时支持 iOS 和 Mac平台，买断价格是 88￥，感觉还是很良心的。<br><img src="https://learner.oss-cn-hangzhou.aliyuncs.com/img/20220821184541.png" alt="20220821184541"><br>我选择这款软件的原因有：</p><ol><li>买断制，一次付费就可以。</li><li>同时支持 iOS+Mac</li><li>进度展示非常明确，支持累计次数、平均值、最大值等统计方式，定期打卡即可看到自己的进度变化，很有成就感</li><li>支持日历同步，配合系统日历提醒，确保不会遗忘</li></ol><p>不过这个软件针对我目前这种需要重复完成的目标支持的不是很好，比如我想要完成每天早起的目标，因为目标必须要有起止时间，那么我还得计算这个周期内总共有多少天，我需要完成多少次，略有点繁琐，除此之外整体使用体验还不错。</p><p>这部分另外一个重要的内容就是在学习和实践中掌握平衡，反复练习，这里不得不佩服孔子在两千多年前就提出了”学而不思则罔，思而不学则殆“，理念十分类似，类似的理论还有王阳明提出的知行合一。 如果明确目标之后，就一头扎进去看书学习，而不进行实践，你会发现自己很容易学完就忘；而如果稍微看一点就开始不断尝试，你会花费大量的时间，很可能尝试了几天都未能解决的问题，就在你要学习的下一章提到了。所以如何边学边练是这一部分的重中之重。</p><p>对于降低全因死亡率这样的计划来说，并不能像学习新的编程语言或者学习如何搭建一个 SpringBoot 应用实操性那么强，不是很能体现学习和实践的紧密关系，但也是适用的。经过初步的了解之后，可以深入到各个子主题里面学习，比如如何提高自己的睡眠质量、如何提高自己的心肺功能、如何增肌等等，更具体的例子是学习了一个新的健身动作，如何通过看视频、听教练指导一步步矫正自己的动作，过程中你还可以通过录像查看自己的动作是否标准，并与学习视频逐一对照修改，直到动作十分熟练，形成肌肉记忆。</p><h3 id="四、乐为人师，融会贯通。"><a href="#四、乐为人师，融会贯通。" class="headerlink" title="四、乐为人师，融会贯通。"></a>四、乐为人师，融会贯通。</h3><p>跟原有方法保持一致，参考<a href="https://wiki.mbalib.com/wiki/%E8%B4%B9%E6%9B%BC%E5%AD%A6%E4%B9%A0%E6%B3%95">费曼学习法 - MBA智库百科</a>，比如通过写博客的形式把我自己的实践经验分享出来，本文不再展开。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>这次的研究课题其实不是很适合用这个学习法，实操性比较差，后面的步骤介绍的不是很好，不过十步学习法中的重点还是在于如何检索资源、筛选资源，并且利用二八定律快速制定一个可执行性较强的学习计划，关于这部分，我感觉还是非常有用且在我制定自己计划中起到了重要帮助的，把之前可能已经在用的一些思路、原则很清晰的提炼总结了出来。<br>希望也能对你起到一定作用~</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近一直在思考如何制定自己的个人目标，凑巧某天开车的时候在微信读书上听到了&lt;a href=&quot;https://book.douban.com/subject/36044253/&quot;&gt;《软技能：代码之外的生存指南》&lt;/a&gt; 这本书，里面提到的关于程序员职业生涯规划部分十分受用，后来到喜马拉雅上找了个更好的版本，快速把第一篇听了一遍，并且趁周末仔细的阅读了一下电子版。&lt;/p&gt;
&lt;p&gt;目前整本书还没有读完，我挑了其中个人比较感兴趣的职业篇和学习篇阅读完了，其中职业篇有介绍到设置一个人生目标，而学习篇则介绍了作者本人总结的一套学习方法，他称之为 “十步学习法”，本篇文章主要就是我自己使用十步学习法进行个人目标设置和规划的一些实践。&lt;/p&gt;</summary>
    
    
    
    <category term="Reading" scheme="http://blog.samwei12.cn/categories/Reading/"/>
    
    
    <category term="读后感" scheme="http://blog.samwei12.cn/tags/%E8%AF%BB%E5%90%8E%E6%84%9F/"/>
    
    <category term="健康" scheme="http://blog.samwei12.cn/tags/%E5%81%A5%E5%BA%B7/"/>
    
    <category term="元学习" scheme="http://blog.samwei12.cn/tags/%E5%85%83%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="目标管理" scheme="http://blog.samwei12.cn/tags/%E7%9B%AE%E6%A0%87%E7%AE%A1%E7%90%86/"/>
    
    <category term="十步学习法" scheme="http://blog.samwei12.cn/tags/%E5%8D%81%E6%AD%A5%E5%AD%A6%E4%B9%A0%E6%B3%95/"/>
    
    <category term="方法论" scheme="http://blog.samwei12.cn/tags/%E6%96%B9%E6%B3%95%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>Logseq 系列之 Git 同步</title>
    <link href="http://blog.samwei12.cn/2022/08/12/Utilities/Logseq%E7%B3%BB%E5%88%97%E4%B9%8BGit%E5%90%8C%E6%AD%A5/"/>
    <id>http://blog.samwei12.cn/2022/08/12/Utilities/Logseq%E7%B3%BB%E5%88%97%E4%B9%8BGit%E5%90%8C%E6%AD%A5/</id>
    <published>2022-08-12T13:25:40.000Z</published>
    <updated>2024-07-31T18:16:36.791Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章主要介绍一下我自己使用 Git 同步 Logseq 的一些心得。前置知识是需要你懂一些基本的 Git 操作，或者起码有一定的动手能力。如果你没听过 Git，那可能本文不太适合你。</p><p>随着 Logseq 的 iOS 版本发布及更新，手机上也能够快速的访问甚至随手自己的笔记了，这无疑是一个非常棒的事情。当然，由于 iOS 系统本身的特点，我们只能使用iCloud 进行 PC 和手机之间同步，这本身并没有什么问题，甚至为了手机端同步，我花了一点时间把放到自己 NAS 里面的笔记全部迁到了 iCloud，并且重新订阅起了 iCloud 的服务（每月 6 元最低档）。</p><p>然而，经过一段时间的使用，我发现事情并没有想象中的那么简单。</p><span id="more"></span><h2 id="为什么要使用-Git-进行同步？"><a href="#为什么要使用-Git-进行同步？" class="headerlink" title="为什么要使用 Git 进行同步？"></a>为什么要使用 Git 进行同步？</h2><p>使用云盘这类服务首先需要面对的一个问题就是版本控制，当然不是说云盘无法做到版本控制，目前大部分云盘都已经支持历史版本（虽然有不少都是需要额外付费），其中做的比较好的当属坚果云，可以比较方便的查看某个文件的多个历史版本，可以恢复到指定版本。由于个人原因，我无法使用坚果云同步笔记，在迁移到 iCloud 之前使用的是自己的 NAS 同步，基本也能满足需求，但也只限于基础需求了。如果我想知道今天新增了哪些笔记、 某个笔记最近都修改了哪些内容，那么普通的版本管理就很不够用了，更别提 iCloud 的版本管理甚至不如 NAS 的同步盘。</p><p>如果仅仅是这个问题，倒也还能忍，但 iCloud 时不时的文件冲突就让人很烦躁了，而且这种同步盘有一个设计感觉使用起来很难受，那就是文件冲突的时候并不是提示你修复冲突，而是自作主张就帮你选好了一个版本，同时舍弃的版本还重命名一下，于是使用一段时间之后你就会发现文件夹里面多了 n 多相同前缀的重复文件，后缀以不同时间戳之类的命名。</p><p>iCloud 另一个非常让人难受的地方就是同步稳定性，照理说服务器都在国内，同步速度应该非常顺畅才对，但有时候它的同步逻辑就非常迷，就是有个别文件迟迟不同步，什么时候同步看它心情，这方面网上文章非常多了，可以搜一下解决办法。但偶尔在手机上查看某文件的时候发现不是最新就非常难受了。</p><p>其他一些易用性的问题也非常多，比如，不希望同步指定文件夹，例如 Logseq 的 bak 文件夹，或者部分隐藏文件等，在 iCloud 或者一般的同步盘里面都是非常难看到的功能，顺便一提，NAS 同步盘倒是支持，而且还支持通配符，很不错。</p><p>总之，云盘的同步功能比起 git 来简直是天上地下，如果你对 git 稍微有点了解的话，应该知道版本控制、断网提交、忽略指定文件等等在云盘上非常难看到或者难用的功能在 git 这里可以说是最基本的本领了，在官方同步版本迟迟未更新的时候，对于稍微有点动手能力的同学来说，选择使用 git 无疑是一个非常省心的决定。</p><blockquote><p>不了解的朋友可以看下官方介绍，对于人均程序员的 Logseq 用户来说相信不存在这个问题~ <a href="https://git-scm.com/about/branching-and-merging">About - Git</a></p></blockquote><h2 id="如何搭建一个-Git-服务？"><a href="#如何搭建一个-Git-服务？" class="headerlink" title="如何搭建一个 Git 服务？"></a>如何搭建一个 Git 服务？</h2><p>接下来我们聊一下如何搭建一个 git 服务。</p><p>最简单的方案就是使用现成的免费服务，例如 <a href="https://github.com/">GitHub</a>， 或者 <a href="https://about.gitlab.com/">The One DevOps Platform | GitLab</a> 以及 <a href="https://gitee.com/">Gitee - 基于 Git 的代码托管和研发协作平台</a>，对于有能力使用外网的同学，推荐使用 GitHub，相信网速也并不是问题，愿意选择国内服务的话，gitee 也还不错。这些服务也都支持个人免费使用，同时支持私有仓库，也就是说你推送的内容，除了你别人都看不到。</p><p>但有部分人会担心自己的笔记放在他人的服务商会不安全，存在隐私泄漏问题，尤其还是个人笔记这种十分隐私的内容。我自己也是这么想的，所以我选择第二种方案，自己搭建一个 git 服务器。</p><p>搭建一个 Git 服务器非常简单，甚至你安装好 git 命令行之后可以在几分钟之内搭建一个自己本地的仓库，从笔记文件夹提交到另一个仓库文件夹中。由于本文篇幅有限，就不展开介绍 git 命令以及搭建了。我自己由于家里有一台 NAS，本着资源利用最大化的思想，就在 NAS 的 Docker 中安装了 <a href="https://gitea.io/zh-cn/">Gitea</a>， 这里你也可以选择使用 Gitlab 等服务，群晖系统可以直接在套件中心下载安装，比较简单省心。 但我个人比较推荐使用 Gitea，除了它是开源免费以外，最主要的原因就是轻量级，它的功能基本已经能够满足小型团队所有的日常开发工作，包括权限管理、自动化等等，这种情况下它的安装包只有 148 MB，占用的内容更是非常少，如果换成 Gitlab 这种庞然大物，起码是 2GB 内存起步。</p><p><img src="https://learner.oss-cn-hangzhou.aliyuncs.com/img/20220812221641.png" alt="感受一下"></p><p>这里简单说两个安装过程中遇到的问题吧，使用 Docker Compose 安装的话，mysql 的创建速度会比较慢，此时直接配置 gitea 会导致报错，提示无法连接 mysql。最简单的解决方案就是安装的时候多等一会，可以通过执行 <code>docker logs -f xx</code> 查看 mysql 的日志输出情况，提示 mysql 创建完成之后，再进入到配置页面进行配置。</p><p>另一个问题就是关于 ssh 配置的问题，为了安全起见，ssh 端口号最好不要使用默认，而是自己改一下，注意修改完之后，docker 配置里面必须使用相同的端口号，且域名中不能带 http，这样会导致克隆的时候没有办法使用 ssh，只能使用 http 方式。</p><p><img src="https://learner.oss-cn-hangzhou.aliyuncs.com/img/20220812221404.png" alt="20220812221404"></p><h2 id="如何在电脑上使用-Git？"><a href="#如何在电脑上使用-Git？" class="headerlink" title="如何在电脑上使用 Git？"></a>如何在电脑上使用 Git？</h2><p>首先你需要一个 Git 仓库，有了服务器之后这一步非常简单了，比如直接在 GitHub 或者 Gitea 的控制台页面，新建一个仓库即可，然后这里有个两种方案：</p><p>方案一： 可以先本地克隆一下仓库到一个新的文件夹中，例如，PKM， 然后把你之前的所有笔记拷贝到这个仓库中，注意，直接从根目录进行拷贝也就是说，PKM 的文件夹里面长这样</p><p><img src="https://learner.oss-cn-hangzhou.aliyuncs.com/img/20220812234557.png" alt="20220812234557"></p><p>之后，选择提交本地改动到远程，就可以了。 注意这里挪动过文件位置之后，需要打开 Logseq 重新定位一下新的库。</p><p>方案二： 如果不想 reindex 的话，可以直接打开 Logseq 配置中的版本管理，Logseq 会自动帮你创建一个本地仓库，之后再把这个本地仓库关联到自己的远程仓库即可。</p><p><img src="https://learner.oss-cn-hangzhou.aliyuncs.com/img/20220813000731.png" alt="20220813000731"></p><p>如上图，打开这个开关，然后重启 Logseq，此时，进入到你的笔记文件夹中，打开显示隐藏文件夹选项，你应该能看到一个 <code>.git</code> 文件夹，说明已经帮你创建好了一个本地仓库，然后使用命令行，进入这个文件夹， 此时输入 <code>git remote -v</code> 应该没有任何反应，之后我们需要把这个本地仓库关联到我们在控制台创建的远程仓库， 输入命令 <code>git remote add orgin 你的仓库地址</code> 即可，之后就可以正常的进行拉取推送了。</p><p><img src="https://learner.oss-cn-hangzhou.aliyuncs.com/img/20220812235217.png" alt="20220812235217"></p><h2 id="如何在-iOS-上使用-Git？"><a href="#如何在-iOS-上使用-Git？" class="headerlink" title="如何在 iOS 上使用 Git？"></a>如何在 iOS 上使用 Git？</h2><p>如果你是安卓手机，那么可以跳过这一章，直接开心的用起来就好了，这里推荐使用 Termux。</p><p>好了，目前你已经有了一个自建的 Git 服务，也能够在电脑上编辑完之后提交推送到远程仓库里面，那么如何在 iOS 上拉取到最新提交呢？</p><p>由于 iOS 的文件夹权限限制，正常的 APP 都只能在自己的创建的文件夹中进行文件操作，除非是 Logseq 自带 Git 支持，否则是无法使用 Git 服务的。我之前也被这个问题困扰许久，直到了解到了 Working Copy 这个神器。 在这里必须要隆重介绍一下这个 Git 仓库 <a href="https://github.com/CharlesChiuGit/Logseq-Git-Sync-101">CharlesChiuGit&#x2F;Logseq-Git-Sync-101: This repo aims to help Logseq users to sync their data with Git and GitHub.</a>， 作者详细的分析了各种同步方式，介绍了 Git 的使用，以及整个工作流，可以说本文大部分内容都是基于这个仓库的，十分感谢原作者 CharlesChiuGit。</p><p>Working Copy 这款软件从 2014 年就上架了，它里面最厉害的一个功能就是能够同步自己内部的一个文件夹和其他 APP 的文件夹，并且这种同步可以做到双向，这样每当你利用 Working Copy 进行 git 拉取的时候，它会自动更新 Logseq 里面的那一份，反之，每当 Logseq 中的内容进行变更的时候，它可以将变更提交到远程仓库。</p><p>整个流程步骤如下：</p><ol><li>使用 Logseq 的 iOS 客户端，在手机本地创建一个文件夹，注意不要选 iCloud 下，而是我的手机下</li><li>使用 Working Copy ，关联该文件夹，并且添加 remote 仓库，这里的仓库需要提前在自己的 git 服务器上或者 GitHub、Gitlab 上建好，推荐使用 ssh 方式</li><li>然后在手机上推送到远程，之后在电脑上克隆同一个仓库，把所有笔记拷贝过去，再次推送</li><li>手机上拉取即可</li></ol><p>其中，3.4 的顺序并不固定，如果你的仓库中已经提交好了笔记，在 2 这里直接拉取也可以。</p><blockquote><p>需要注意的是： Working Copy 链接外部文件夹功能是一个付费功能，但作者非常良心的提供了 10 天的试用期，所以如果只是在手机上查看而不是编辑的话，你可以利用试用期把需要的仓库都克隆到手机上，之后即使试用过期，你也仍然能够使用已有功能。</p></blockquote><p>虽然可以免费使用，但还是建议大家购买正版支持一下作者，终身买断 128 人民币，并不是很贵，而且免费版是无法进行推送的，如果你经常使用 Flashcards 功能的话，就会发现手机上进行复习是非常方便的，这时候不推送是无法保存手机学习记录的。</p><h2 id="提效-tips"><a href="#提效-tips" class="headerlink" title="提效 tips"></a>提效 tips</h2><p>到这里，你已经可以愉快地在手机和电脑上都用上 Logseq 了，并且 git 同步非常的稳定，再也不会出现想要的文件不同步或者是重复文件的情况了，你还能获得一大堆其他 feature， 比如在 <code>.gitignore</code> 中简单配置下面这两行就可以确保不会每次同步一大堆废弃的文件。</p><p><img src="https://learner.oss-cn-hangzhou.aliyuncs.com/img/20220812224040.png" alt="20220812224040"></p><p>又或者，你可以查看自己每天更新的笔记情况，甚至是每个文件的改动情况。</p><p><img src="https://learner.oss-cn-hangzhou.aliyuncs.com/img/20220812224339.png" alt="20220812224339"></p><p>更高阶的玩法包括回滚某次提交、 恢复到指定版本等等等等。</p><h3 id="自动化"><a href="#自动化" class="headerlink" title="自动化"></a>自动化</h3><p>但还有一点点可以提效优化的地方。首先，如果是切换设备之前先在设备 A 提交一次，再去设备 B 拉取一次，那肯定是非常难受的，毕竟连同步盘都能做到后台自动同步呢。所以我们要先把提交变为自动化。</p><p>这里也有两个方案，方案一是通过脚本定时提交，参考 <a href="https://github.com/logseq/git-auto/blob/master/git-auto">git-auto&#x2F;git-auto at master · logseq&#x2F;git-auto</a>， 用起来也很方便，开机之后跑一下脚本就可以了，有一点可以改进一下的就是这个脚本通常只会自动提交并 push，如果切换了设备，是不会自动拉取最新版本的，可以在 66 行这边补一下拉取更新的逻辑，每次提交前先拉取最新版本，就更加好用了； 方案二更加方便，在仓库的隐藏文件夹 <code>.git</code> 中找到 hooks ，从 <a href="https://github.com/CharlesChiuGit/Logseq-Git-Sync-101">CharlesChiuGit&#x2F;Logseq-Git-Sync-101: This repo aims to help Logseq users to sync their data with Git and GitHub.</a> 中下载 git-hooks 中的文件并复制到 hooks 中，记得使用 <code>chmod +x ./pre-commit &amp;&amp; chmod +x ./post-commit</code> 将文件变为可执行文件，这样 hooks 才能生效，之后在 Logseq 的设置中打开版本控制，开启自动提交，重启 Logseq 即可。它的原理是利用了 <a href="https://www.atlassian.com/git/tutorials/git-hooks">Git Hooks | Atlassian Git Tutorial</a> 的能力，在每次自动提交之前拉取一下远程仓库，同时在每次自动提交之后把改动推送到远程仓库中，同时 Logseq 的这个配置项开启之后，内部会启动一个定时器定期检查是否有可提交改动，如果有则触发 commit，如果没有改动则不做任何事情。 个人更加推荐使用方案二，相对来说更加自动化一点，且拉取跟推送的问题都解决掉了，非常完美了。</p><h3 id="iOS-捷径"><a href="#iOS-捷径" class="headerlink" title="iOS 捷径"></a>iOS 捷径</h3><p>另一个可以优化的地方就是 iOS 的操作了，毕竟手机上并没有类似电脑上自动 commit 的功能，每次打开 Logseq 之前还要先去 Working Copy 中选中仓库，然后点击拉取，用完了点击提交推送，还是很麻烦的。我们可以通过系统提供的捷径功能简化操作，不需要打开 Working Copy的情况下，把提交和推送都完成。</p><p>Working Copy 提供的捷径已经非常简单易懂了，我这里直接上两个截图，分别是拉取更新和提交更新的步骤，正常没有冲突的情况下基本都够用了。</p><img src="https://learner.oss-cn-hangzhou.aliyuncs.com/img/20220812230743.png" width="30%" height="30%"> <img src="https://learner.oss-cn-hangzhou.aliyuncs.com/img/20220812231820.jpg" width="30%" height="30%"><p>如果有冲突需要解决，最好还是去 Working Copy 里面进一步进行处理。</p><p>之后再把这两个捷径添加到桌面上，放到 Logseq 旁边，这样，每次打开 Logseq 前点一下拉取，编辑完再点一下提交，能满足绝大部分需求了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>至此，整个 Logseq 的 Git 同步方案就完成了，应该说如果跳过自建 Gitea 的步骤，还是比较简单的，但用上之后就真的停不下来了，可以说好的同步方式能够解决大部分 Logseq 的使用问题，让 Logseq 变得更加好用~ 希望本文能够对你有所帮助。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;这篇文章主要介绍一下我自己使用 Git 同步 Logseq 的一些心得。前置知识是需要你懂一些基本的 Git 操作，或者起码有一定的动手能力。如果你没听过 Git，那可能本文不太适合你。&lt;/p&gt;
&lt;p&gt;随着 Logseq 的 iOS 版本发布及更新，手机上也能够快速的访问甚至随手自己的笔记了，这无疑是一个非常棒的事情。当然，由于 iOS 系统本身的特点，我们只能使用iCloud 进行 PC 和手机之间同步，这本身并没有什么问题，甚至为了手机端同步，我花了一点时间把放到自己 NAS 里面的笔记全部迁到了 iCloud，并且重新订阅起了 iCloud 的服务（每月 6 元最低档）。&lt;/p&gt;
&lt;p&gt;然而，经过一段时间的使用，我发现事情并没有想象中的那么简单。&lt;/p&gt;</summary>
    
    
    
    <category term="Utilities" scheme="http://blog.samwei12.cn/categories/Utilities/"/>
    
    
    <category term="Logseq" scheme="http://blog.samwei12.cn/tags/Logseq/"/>
    
    <category term="Git" scheme="http://blog.samwei12.cn/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>简悦+Logseq 搭建本地化个人知识库</title>
    <link href="http://blog.samwei12.cn/2022/03/21/Utilities/%E7%AE%80%E6%82%A6-Logseq-%E6%90%AD%E5%BB%BA%E6%9C%AC%E5%9C%B0%E7%9F%A5%E8%AF%86%E5%BA%93/"/>
    <id>http://blog.samwei12.cn/2022/03/21/Utilities/%E7%AE%80%E6%82%A6-Logseq-%E6%90%AD%E5%BB%BA%E6%9C%AC%E5%9C%B0%E7%9F%A5%E8%AF%86%E5%BA%93/</id>
    <published>2022-03-21T14:14:04.000Z</published>
    <updated>2024-08-01T02:43:43.680Z</updated>
    
    <content type="html"><![CDATA[<p>最近在少数派上看到了 <a href="https://sspai.com/post/72022">简悦 +Logseq 个人知识库搭建 | 从零开始完全指南 - 少数派</a>， 一时间感觉打开了新世界，其实我很早就买了简悦 2.0，但由于一直没有很好的使用场景，外加配置实在过于复杂， 始终吃灰。直到看到这篇文章，发现原来简悦也可以直接跟 Logseq 打通，那么稍后读的最大弊端终于有了完美的解决方案。</p><p>不过实际按照教程配置的过程中，发现原作者是基于坚果云搭建的，不符合我本地化的思路（主要是公司不允许用云盘），因此尝试摸索一个本地任意文件夹均可实现的方案，过程中踩了非常多的坑，记录下来，希望对大家有帮助。</p><span id="more"></span><h2 id="核心配置步骤"><a href="#核心配置步骤" class="headerlink" title="核心配置步骤"></a>核心配置步骤</h2><p>因为原文已经写的非常详细了，所以这里我不再一一列举配置，而是仅把本地化配置需要注意的事项标注出来。</p><h3 id="安装同步与导出工具"><a href="#安装同步与导出工具" class="headerlink" title="安装同步与导出工具"></a>安装同步与导出工具</h3><p>这里坚果云不再是必选项，而是任意本地目录即可，注意必须要保证目录结构为 <code>xx/SimpRead</code> 才行，这个是硬性要求，否则会无法使用简悦的本地知识库功能。其实只需要在同步文件夹里选择一个名为 SimpRead 的文件夹即可，导出部分使用默认</p><p><img src="https://learner.oss-cn-hangzhou.aliyuncs.com/img/20220321222459.png" alt="20220321222459"></p><p><img src="https://learner.oss-cn-hangzhou.aliyuncs.com/img/20220321222627.png" alt="20220321222627"></p><p>详细服务设定参考原文，全部打开。</p><blockquote><p>关于简悦知识库相关内容，可以查阅官方文档 <a href="https://kb.simpread.pro/#/page/%E5%BB%BA%E7%AB%8B%E7%9F%A5%E8%AF%86%E5%BA%93">建立知识库</a></p></blockquote><h3 id="通用-高级"><a href="#通用-高级" class="headerlink" title="通用&amp;高级"></a>通用&amp;高级</h3><ul><li>自动同步相关参考原文，不需要做改动（也不需要覆盖本地配置文件这一步）</li><li>标注部分保持一致，确保导出时候一定要选 <code>全文（含标注）+标注</code></li></ul><h3 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h3><p>这里是配置大头，也是容易出错的地方，重点说一下。</p><p>【授权】</p><ul><li>因为没有用坚果云，这里可以不用关心授权</li></ul><p>【定制导出】</p><ul><li>自定义标题一定要开，这个也是知识库使用的前提，同时标题必须要保证是 <code>&#123;&#123;id&#125;&#125;&#123;&#123;un_title&#125;&#125;&#123;&#123;mode&#125;&#125;</code>  (这个主要是为了后面稍后读能够加载本地文件)</li><li>模板部分，我个人做了一定的改动，这个可以自定义</li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">tags:: #[[SimpRead]] &#123;&#123;tags&#125;&#125;</span><br><span class="line">type:: [[Literature Notes]]</span><br><span class="line">time:: [[&#123;&#123;date<span class="emphasis">_format|now|yyyy-MM-dd&#125;&#125; ]]</span></span><br><span class="line"><span class="emphasis">source:: [<span class="string">&#123;&#123;title&#125;&#125;</span>](<span class="link">&#123;&#123;url&#125;&#125;</span>) </span></span><br><span class="line"><span class="emphasis">desc:: &#123;&#123;desc&#125;&#125;</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">&#123;&#123;#each&#125;&#125;</span></span><br><span class="line"><span class="emphasis">- &gt; [<span class="string">📌</span>](<span class="link">&lt;&#123;&#123;an_int_uri&#125;&#125;&gt;</span>) &#123;&#123;an_</span>html&#125;&#125;</span><br><span class="line">  </span><br><span class="line">&#123;&#123;  - |an<span class="emphasis">_note&#125;&#125;&#123;&#123;an_</span>tags&#125;&#125;</span><br><span class="line">&#123;&#123;/each&#125;&#125;</span><br></pre></td></tr></table></figure><p>主要改动包括：</p><ul><li>添加部分元数据，用于 Logseq 的 query 功能，例如： type、tags、time 等</li><li>标注部分把原文放在前面，同时加引文标识，自己的话放在后面，且添加缩进</li></ul><p>效果图：</p><p><img src="https://learner.oss-cn-hangzhou.aliyuncs.com/img/20220321223653.png" alt="20220321223653"></p><p>这里一定要注意，<code>[[&#123;&#123;date_format|now|yyyy-MM-dd&#125;&#125; ]]</code> 后面是有一个空格的，它不是作者笔误，而是必须要这样才能正常添加时间戳，参见： <a href="http://ksria.com/simpread/docs/#/%E5%AE%9A%E5%88%B6%E5%8C%96%E5%AF%BC%E5%87%BA?id=markdown">定制导出</a> ，<img src="https://learner.oss-cn-hangzhou.aliyuncs.com/img/20220321224231.png" alt="image-20220321224231231"></p><h3 id="增强导出（保持原文配置）"><a href="#增强导出（保持原文配置）" class="headerlink" title="增强导出（保持原文配置）"></a>增强导出（保持原文配置）</h3><h3 id="自动化"><a href="#自动化" class="headerlink" title="自动化"></a>自动化</h3><p>这里有一个坑花了我三天时间，必须要重点讲一下。</p><blockquote><p>但这里更建议是保存为 <a href="http://textbundle.org/">Textbundle </a>格式，因为离线 HTML 需要将图片转译为 Base64 的代码，碰到多图杀猫的文章很容易卡顿或失败。</p></blockquote><p>因此在自动化中，我导出了 HTML、Markdown、Textbundle，结果就是，尝试了各种方案，包括数次卸载重装、排查本地端口占用、卸载同步助手重装等，都无法成功在本地使用 <code>http://localhost:7026/reading/</code> 跳转文件，一直提示 404，<img src="https://user-images.githubusercontent.com/12758352/158979936-06fa9e67-8a68-4fd8-ab13-e854377e87e9.png">，中间尝试了各种方案，一度怀疑是否只能使用坚果云才能用知识库功能。 结果发现全部卸载重装之后，坚果云也无法使用，中间联系简悦作者 <strong><a href="https://github.com/Kenshin">Kenshin</a></strong> 排查了很久，最终发现是因为同步助手无法识别 <code>.textbundle</code> 文件，导致不能正常建立索引。</p><p>这个问题有两种解决方案： 1. 放弃 Textbundle，改为使用离线 HTML  2. 通过文件规则，将 <code>.textbundle</code> 格式文件移动到其他目录下。我选择了第二种，原因就是离线 HTML 下载容易造成卡顿。不过遇到了另一个问题，那就是 <strong>Hazel</strong> 实在是太快了，在简悦刚开始创建 Textbundle 文件的时候，就已经把文件夹挪到了其他文件，导致此时简悦正在下载的图片找不到存放目录，引发大量报错。这个问题也卡了我不少时间，具体解决方案稍后单独介绍。</p><p>关于这部分，Kenshin 戏称说这个 issue 的长度可以在 2000 个 issue 里面排到前五，过程确实比较曲折，我中间走了非常多的弯路（不然也不会花掉一个周末的时间折腾），一度都想卸载简悦放弃了。有兴趣的同学可以看一下 <a href="https://github.com/Kenshin/simpread/issues/3554">自定义导出无法使用稍后读加载本地缓存文件 · Issue #3554 · Kenshin&#x2F;simpread</a></p><p>第二个坑，这里原文作者也有提到，那就是稍后读的自动化流程，必须要在阅读模式下才可以，否则不生效， 参考： <a href="https://github.com/Kenshin/simpread/discussions/2362">部分操作方式加入稍后读时，无法触发自动化 · Discussion #2362 · Kenshin&#x2F;simpread</a></p><h3 id="开放平台（本地方案不需要，跳过）"><a href="#开放平台（本地方案不需要，跳过）" class="headerlink" title="开放平台（本地方案不需要，跳过）"></a>开放平台（本地方案不需要，跳过）</h3><h3 id="定制导出"><a href="#定制导出" class="headerlink" title="定制导出"></a>定制导出</h3><ul><li>这里一定要注意： 必须要跟原作者保持一致， <code>http://localhost:7026/reading/</code> 路径是简悦知识库必须的配置，否则会导致链接无法跳转以及稍后读无法使用本地缓存文件。</li><li>另一个问题就是简悦存在 bug，刷新完一定要检查一下配置是否符合预期</li></ul><h3 id="稍后读后台设置"><a href="#稍后读后台设置" class="headerlink" title="稍后读后台设置"></a>稍后读后台设置</h3><ul><li>基本保持一致，唯一一个小改动点就是 <img src="https://learner.oss-cn-hangzhou.aliyuncs.com/img/20220321225751.png" alt="image-20220321225751261">，因为我只用简悦来进行深度阅读，并不需要在这里查看标注，所以通常都是进入阅读模式。</li></ul><h3 id="MD-文件自动移动（保持一致，使用-Hazel-即可，实际上后面我放弃了使用-Hazel）"><a href="#MD-文件自动移动（保持一致，使用-Hazel-即可，实际上后面我放弃了使用-Hazel）" class="headerlink" title="MD 文件自动移动（保持一致，使用 Hazel 即可，实际上后面我放弃了使用 Hazel）"></a>MD 文件自动移动（保持一致，使用 Hazel 即可，实际上后面我放弃了使用 Hazel）</h3><p>至此，整个核心配置基本就已经完成了，我们实现的功能包括：</p><ol><li>添加标注自动保存 HTML、Markdown 到 output 文件夹</li><li>标注文件自动移动到 Logseq 目录中</li><li>稍后读自动加载本地缓存 HTML 文件 <img src="https://learner.oss-cn-hangzhou.aliyuncs.com/img/20220321230602.png" alt="image-20220321230602224"></li></ol><h2 id="优化点"><a href="#优化点" class="headerlink" title="优化点"></a>优化点</h2><h3 id="Textbundle永久保存方案（Mac、Linux-适用）"><a href="#Textbundle永久保存方案（Mac、Linux-适用）" class="headerlink" title="Textbundle永久保存方案（Mac、Linux 适用）"></a>Textbundle永久保存方案（Mac、Linux 适用）</h3><p>接着上面提到的，详细展开一下如何处理 Textbundle 文件。</p><p>首先，我一下子想到的就是利用 Hazel，新建一个规则就可以，当我实际上这么操作的时候，发现遇到了简悦写入图片时文件夹已经被移动导致报错问题。</p><p>此时，我的思路是，如果有办法能够延长移动文件夹的速度就好了。但简悦跟 Hazel 是相互不知道的，很可惜的是 Hazel 中也没有配置延迟操作或者定时任务这一功能，那么我们只能想办法自己动手了（当然这里还有一条路，希望简悦后续的文件写入能够先把图片下载完，之后再生成文件夹）。</p><p>我想到的解决方案是使用 *nix 系统的 cron 功能，不了解的小伙伴可以看一下 <a href="https://serverfault.com/questions/449651/why-is-my-crontab-not-working-and-how-can-i-troubleshoot-it">linux - Why is my crontab not working, and how can I troubleshoot it? - Server Fault</a> ，非常详细的介绍了 cron crontab 分别是什么， 如何使用，以及如何排查错误，受益匪浅。</p><p>这里需要做的事情非常简单，将所有后缀为 <code>.textbundle</code> 的文件移动到另一个目录中，实际操作起来并不简单，因为 <code>mv</code> 命令无法直接移动文件夹，而 textbundle 其实是一个文件夹而不是文件，包括了 json、图片以及 markdown，所以第一步就卡住了。我改为使用 <code>rsync</code> 来实现这个功能，可以很方便的把某个目录下所有的 Textbundle 移动到另一个目录。之后我们把源文件夹中的 Textbundle 文件删除。这里由于无法使用 Hazel 实现全部功能，那我干脆把移动 <code>@annotate.md</code> 文件的部分也放在自己的脚本里面实现了。完整的脚本文件如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">cd 你的目录/SimpRead</span><br><span class="line">mv output/*@annote.md  Logseq目录/SimpleRead/</span><br><span class="line">rsync -axvP output/*.textbundle archieves（存放 Textbundle 的目录）</span><br><span class="line">rm -rf output/*.textbundle</span><br></pre></td></tr></table></figure><p>可以直接新建一个 <code>simpread.sh</code> 之后把上面的代码粘贴过去，记得把上面中文说明的部分都替换掉，同时为了手动执行方便，可以 <code>chmod +x simpread.sh</code> 一下。</p><p>然后就是使用 cron 让电脑自动执行这个脚本，这里可以使用 <a href="https://crontab.guru/#*/5_*_*_*_*">Crontab.guru - The cron schedule expression editor</a> 这个网站调试一下定时任务，比如我目前的配置是每隔 5 分钟执行一次脚本。注意不能执行太频繁，否则一样会遇到简悦下载出错（5 分钟也不能保证完全不出错，理论上间隔越久，出错概率越小）。</p><p>具体的添加步骤（我是 Mac，以下请在命令行中执行）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">export EDITOR=&#x27;vi&#x27; (不是必须)</span><br><span class="line">crontab -e</span><br><span class="line"></span><br><span class="line">然后输入</span><br><span class="line">*/5 * * * * /bin/sh 你的简悦目录/SimpRead/simpread.sh</span><br><span class="line">之后输入 :wq 保存即可</span><br></pre></td></tr></table></figure><p>提示： <img src="https://learner.oss-cn-hangzhou.aliyuncs.com/img/20220321232144.png" alt="image-20220321232140468"></p><p>就代表定时任务添加成功，可以把 Hazel 卸载掉了。</p><h3 id="快速进入稍后读"><a href="#快速进入稍后读" class="headerlink" title="快速进入稍后读"></a>快速进入稍后读</h3><p>看到简悦同步助手里面有如何快速打开稍后读的方式，参见： <a href="http://ksria.com/simpread/docs/#/%E7%A8%8D%E5%90%8E%E8%AF%BB?id=%E5%88%9B%E5%BB%BA%E5%BF%AB%E6%8D%B7%E6%96%B9%E5%BC%8F">稍后读</a> ，我就琢磨了一下，感觉效率还可以再提高一下。</p><h3 id="配置快捷方式"><a href="#配置快捷方式" class="headerlink" title="配置快捷方式"></a>配置快捷方式</h3><p>文档中把快捷方式跟独立窗口分开成两步，实际上 Chrome 浏览器支持直接创建一个独立窗口的 PWA 应用（关于 PWA，参考： <a href="https://developer.mozilla.org/en-US/docs/Web/Progressive_web_apps">Progressive web apps (PWAs) | MDN</a>）。</p><p>打开稍后读： <img src="https://learner.oss-cn-hangzhou.aliyuncs.com/img/20220321232814.png" alt="image-20220321232814407"></p><p>选择独立窗口：</p><p><img src="https://learner.oss-cn-hangzhou.aliyuncs.com/img/20220321232832.png" alt="image-20220321232832834"></p><p>然后你可以在用户目录下找到它 </p><p><img src="https://learner.oss-cn-hangzhou.aliyuncs.com/img/20220321232955.png" alt="image-20220321232955685"></p><p>也可以通过 Alfred 或者 Spotlight 找到它 </p><p><img src="https://learner.oss-cn-hangzhou.aliyuncs.com/img/20220321233044.png" alt="image-20220321233044890"></p><h3 id="Manico-配置快速跳转"><a href="#Manico-配置快速跳转" class="headerlink" title="Manico 配置快速跳转"></a>Manico 配置快速跳转</h3><p>这里不得不强推一个效率软件了，官方网站： <a href="https://manico.im/">Manico - macOS 下的快速 App 切换器</a></p><p>基本上可以说这个软件是我目前每天使用频率最高的软件，应该没有之一，大概是 18 年左右 25￥购入。它的主要作用就是快速切换软件，比如你可以配置 option+1 打开 Chrome，option+2 打开微信等等，而且再次点击快捷键可以隐藏该软件，能够极大的节约软件切换的时间。这虽然是一款付费软件，但绝对是我在 Mac 上买过的最物超所值的软件。</p><p>核心配置：快速隐藏应用 <img src="https://learner.oss-cn-hangzhou.aliyuncs.com/img/20220321233606.png" alt="image-20220321233606404"></p><p>如何配置稍后读快速打开隐藏： <img src="https://learner.oss-cn-hangzhou.aliyuncs.com/img/20220321233522.png" alt="image-20220321233522695"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我一般的处理流程是手机浏览公众号或者 RSS 初筛到 Cubox，之后电脑上打开 Cubox，跳转到简悦进行深度阅读，添加标注，同步到 Logseq，之后进行定期整理。</p><p>这样，整个从文章到标注，到 Logseq 整理的过程就打通了。简悦作为一个稍后读软件，最大的亮点就是作为一个粘合剂，可以很好地跟各种笔记类软件打通，称为知识管理工作流中不可或缺的一部分，把浏览阅读到的信息和知识真正的经过深度阅读，让它有机会融入到已有的知识体系中，内化为自己的东西，就这一点已经远远超越了 Evernote、Cubox、Pinbox 等同类剪藏产品。</p><p>不过简悦问题也很明显，太极客了，配置使用成本巨高无比，我身为一个程序员，都好几次尝试无果弃坑了，个人感觉它的功能已经足够强大了，希望作者能够多花点心思在交互跟实际使用体验上，真的不需要再加那么多新功能了，适当的做减法非常有必要。希望我的踩坑经历能够对你有一些帮助。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近在少数派上看到了 &lt;a href=&quot;https://sspai.com/post/72022&quot;&gt;简悦 +Logseq 个人知识库搭建 | 从零开始完全指南 - 少数派&lt;/a&gt;， 一时间感觉打开了新世界，其实我很早就买了简悦 2.0，但由于一直没有很好的使用场景，外加配置实在过于复杂， 始终吃灰。直到看到这篇文章，发现原来简悦也可以直接跟 Logseq 打通，那么稍后读的最大弊端终于有了完美的解决方案。&lt;/p&gt;
&lt;p&gt;不过实际按照教程配置的过程中，发现原作者是基于坚果云搭建的，不符合我本地化的思路（主要是公司不允许用云盘），因此尝试摸索一个本地任意文件夹均可实现的方案，过程中踩了非常多的坑，记录下来，希望对大家有帮助。&lt;/p&gt;</summary>
    
    
    
    <category term="Utilities" scheme="http://blog.samwei12.cn/categories/Utilities/"/>
    
    
    <category term="PKM" scheme="http://blog.samwei12.cn/tags/PKM/"/>
    
    <category term="稍后读" scheme="http://blog.samwei12.cn/tags/%E7%A8%8D%E5%90%8E%E8%AF%BB/"/>
    
    <category term="Logseq" scheme="http://blog.samwei12.cn/tags/Logseq/"/>
    
    <category term="简悦" scheme="http://blog.samwei12.cn/tags/%E7%AE%80%E6%82%A6/"/>
    
  </entry>
  
  <entry>
    <title>万物互联</title>
    <link href="http://blog.samwei12.cn/2022/03/15/Thinking/%E4%B8%87%E7%89%A9%E4%BA%92%E8%81%94/"/>
    <id>http://blog.samwei12.cn/2022/03/15/Thinking/%E4%B8%87%E7%89%A9%E4%BA%92%E8%81%94/</id>
    <published>2022-03-15T14:02:11.000Z</published>
    <updated>2024-07-31T18:16:36.793Z</updated>
    
    <content type="html"><![CDATA[<p>今天在开车回家的路上又听了一遍《人是如何学习的》，当听到其中讲专家具有普通人所没有的几大特征时，其中第一条就是专家具有“心理表征”。这里解释到什么是心理表征的时候，我突然感到最近所阅读和学习的知识全部串在了一起，有一种不吐不快的感觉，于是在车里构思了这篇文章。</p><span id="more"></span><h2 id="什么是心理表征"><a href="#什么是心理表征" class="headerlink" title="什么是心理表征"></a>什么是心理表征</h2><p>维基百科中关于心理表征的描述十分抽象，书中的解释是说，专家能够发现很多普通人注意不到的信息特征和模式。直白点说，当你是这个领域专家的时候，对于这个领域的各种知识已经了然于胸，很多事情可以不过脑子就知道来龙去脉。例如，象棋或者围棋高手，能够在棋局很不明朗的时候一眼就看出哪一方会赢；专业的刑警可以通过扫一眼房间就能获取大量的嫌疑人信息。</p><p>书中关于心理表征的部分并没有什么特别的地方，但听到这里，我的整个大脑感觉就像打开了某个开关一样，不断的有思绪和灵感涌现出来。</p><h2 id="知识是网状的"><a href="#知识是网状的" class="headerlink" title="知识是网状的"></a>知识是网状的</h2><p>首先，涌入我脑中的是很久之前看到过的一个“DIKW模型”[^1]，这里的心理表征不就是Data-Information-Knowledge-Wisdom 中 Wisdom 吗？熟练地掌握各种技能，不光知道如何用，还知道何时使用，内化为个人的某种天赋。</p><p>接着想到了“KSA模型”[^2]，Knowledge-Skills-Abilities 三层中的 abilities 也是类似的东西，知识-技能-天赋，先学习知识，知道是什么，之后开始练习技能，学会为什么，怎么用，通过不断的刻意练习使用技能，明白何时用，做到手中无剑，心中有剑。</p><p>然后回想书中提到的不需要过脑子就本能反应，联想到了《思考，快与慢》中的系统1，这本书中将大脑的思考分为两个系统，一个是靠直觉行事的系统1，比如你看到对面走过去的一个人，立马就能知道他现在是开心还是不开心，通过他的打扮猜测出他的职业等；另一个是靠逻辑思维的系统2，比如做数学题 :)。绝大部分时间，系统2都是不工作的，因为深入思考是需要花费大量精力的，而人的天性是懒惰的，这跟大脑习惯选择系统1是有关系的，尽可能的让系统1工作，让系统2休息，所以很多时候人会做出不理性的行为。比如现在有个赌局，扔一枚硬币，正面会给你130美金，反面你需要给出100美金，你会作何选择，玩还是不玩？绝大多数人的第一反应都是拒绝参与，但冷静下来，通过概率学计算你会明白，你的收益期望是大于 0 的，也就是说你选择玩是有益的，这就是由于没有经过系统2 认真分析，系统 1 由于人的损失厌恶心理而得出了非最优解。<br>系统 1 和系统 2 并不是泾渭分明的，通过训练，你可以将很多系统 2 原本的工作转换为系统 1 的工作。例如，上面提到的刑警迅速看一眼房间就能获取大量信息的过程，也是他们经过大量的刻意练习才能做到的，专家并不是生来就是专家的。包括《刻意练习》这本书中提到的案例，作者找了几个普通大学生，跟我们一样，扫一眼也只能记几位数字，经过两年训练后，他们居然能够参加速记大赛并且获奖，而速记几百个数字对于普通人来说，绝对是远远超过系统 1 工作能力的事情，这也是典型的通过学习和训练将系统 2 的部分能力转换给了系统 1，这不就是开头所提到的“心理表征”吗。</p><p>《思考，快与慢》是一部里程碑式的著作，给后来很多其他心理学相关书籍提供了支持。《穷查理宝典》中提到了查理·芒格所撰写的人类误判心理学，其中绝大部分误判都可以从《思考，快与慢》中找到相关讨论，两本书对照着看理解会更加深刻。</p><p>于是，我发现了最近这段时间看到的、听到的各种知识点相互之间居然都能联系到一起，这些知识形成了一张巨大的网，这不是件很神奇的事情吗？</p><h2 id="大脑也是网状的"><a href="#大脑也是网状的" class="headerlink" title="大脑也是网状的"></a>大脑也是网状的</h2><p>对于脑科学稍微有所了解的朋友应该知道大脑本质就是一个巨大的网络，只有通过神经元之间相互的连接所产生的神奇反应才使得我们能够记忆、学习、思考。所以才会出现上面提到的各个知识点之间形成一张网的情况，因为只有这样，知识才能被更好的记忆理解。而那些孤岛式的知识点早就被遗忘在不知道哪个犄角旮旯了，约等于压根没学过。</p><p>人的大脑记忆是存在一个提取强度的，这个概念的意思是说把你的知识点从大脑中提取出来需要花费多大的力气，提取强度越高，代表这个知识点越难被想起来。所以那些使用越频繁的知识、越是最近学到的知识、跟其他已有知识点关联越紧密，越容易被记起来。<br>说到这里，有没有发现大脑真的很像计算机？计算机会使用缓存把频繁使用到的数据加载起来，所以你会发现经常打开的软件响应很及时，好久没切换过去的软件，处于休眠状态，切换过去的时候通常会先卡顿一阵子，而已经关闭的软件，则需要经历从硬盘加载到内存、缓存的过程，启动时候往往要读条很久（实际上计算机还有不同级别的缓存、寄存器等）。</p><p>由此我又联想到了这两年非常火的“卡片笔记法”和双链笔记等概念，仔细思考之后就会发现，他们能火起来的原因就是因为他们符合了人脑记忆学习的过程。卡片盒笔记法中最核心的一个点就是，每新建一个卡片的时候，一定要跟已有的卡片进行连接，这不就是上面提到的大脑记忆东西的过程吗？Roam Research 这样的双链软件最大的特点就是能够配合 daily notes 毫无压力的记下各种灵感，同时只需要打上标签或者说主题，就能够在需要用到指定主题的时候把以往记录的所有灵感想法、收集的素材都关联起来，这不就是通过知识点之间的关联来降低提取强度吗？</p><p>这里我想到，关于到底是用文件夹还是用标签来管理文档，网上已经有非常多的争论了，基于上面的思考，由标签系统展开来进行管理相对来说更符合人类大脑的构造，天然的就能减少知识点的提取成本。这里非常重要的一个因素是知识点之间很少有明确的树状结构，大部分的情况下都是网状结构居多，且网状结构也便于回想，不会出现找不到放在哪个目录下的问题，而且大幅度减少了分类的痛苦，大脑天生就不是很适合干这种分类的活。这也是目前流行的笔记软件中，大多都是采用 daily notes 而不是传统的文档型结构的原因，等你想好这个灵感应该归属于哪个目录，这个目录以前是否有创建好等等，你的灵感已经丢失了或者不完整了。</p><h2 id="世界是网状的"><a href="#世界是网状的" class="headerlink" title="世界是网状的"></a>世界是网状的</h2><p>站在更高层次来想一想，不光是人的大脑，整个世界的万事万物，都是相互联系的。这可不仅仅是口头上说说而已，参考“六度分隔理论”[^4]，不同的两个人之间都可以通过六个人联系到一起（这个说法存在一定争议），而且随着互联网的发展，地球变得越来越小，这个数字还在不断减少，Facebook 的研究表明，在 2016 年的时候，累计 15.9 亿用户，平均间隔为 4.57 人，仅考虑美国的话，这个数字降到 3.46 人。<br>这个模型本身是有数学依据的，假设每个人认识 150 个人的话，150<sup>6</sup> 约等于 11.4 兆，即使消除重复节点，这个数字也远远超过地球上人数的总和。</p><p>而在科学领域，也同样是紧密联系的，《穷查理宝典》中查理·芒格提出了著名的“多元思维模型”[^3]，简单来说就是你需要掌握多种不同学科的基础理论，它们能给你带来远远超过 1+1&gt;2 的收获，他称之为 lollapalooza 效应。<br>只掌握一门基础理论是远远不够的，因为“在拿着锤子的人看来，眼中只有钉子”，这会让你的思维方式严重的被局限。<br>同时，我想到了下午检索了一下现代科学的分支大纲[^5]，发现很多学科其实并没有严格的分界线，而是相互之间都有所联系。例如，如果只知道心理学，可以得出结论，人应该如何控制自己的情绪，如何有效的沟通，但只有同时知道了脑科学，知道了诸如额前叶、杏仁体、多巴胺等概念，才能明白人为什么会生气？为什么人一旦愤怒就会失去理智？人为什么会开心？以及它们背后的生物学原理是什么。所以现在阶段的科学研究，通常是多位不同领域的科学家同时进行配合。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上这些基本都是我在回家路上，脑子里自己突然蹦出来的灵感，一个接着一个，把最近的各种听闻全部串了起来，那种感觉就像是拿到了一把宝藏大门的钥匙。<br>那么这能给我带来什么启示呢？应该如何保持这种状态？<br>首先，学习知识的时候不要急躁，不要急功近利。很多人会问读书有什么用？反正看了也会忘。我以前也不知道，现在我明白，那些你学过的东西其实始终都在你的大脑中，只是缺少一个相互连接、爆发的契机。<br>其次，对学习的方法也有一定的指导作用，需要尽可能的多发挥自己的主观能动性，主动联想，而不是被动学习。每天睡前听 10 分钟单词并不会让你的英语水平有任何提升。这里我又想到了前两天听到的左耳朵耗子在极客时间《程序员练级攻略》中提到的联想学习法，当时并没有太大感触，今天终于才明白他说的是什么。</p><p>本以为只是随笔写点想法，不想写长文，结果碎碎念不小心又写了两个多小时，写成了长文，谢谢你能看到这里，与君共勉。</p><p>[^1]: <a href="https://zh.wikipedia.org/wiki/DIKW%E4%BD%93%E7%B3%BB">DIKW体系 - 维基百科，自由的百科全书</a><br>[^2]: <a href="https://www.thebalancecareers.com/understanding-knowledge-skills-and-abilities-ksa-2275329#:~:text=In%20the%20world%20of%20human,looking%20at%20your%20KSA%20profile.">KSA: Using the Knowledge, Skills and Abilities Model</a><br>[^3]: <a href="https://wiki.mbalib.com/wiki/%E5%A4%9A%E5%85%83%E6%80%9D%E7%BB%B4%E6%A8%A1%E5%9E%8B#:~:text=%E5%A4%9A%E5%85%83%E6%80%9D%E7%BB%B4%E6%A8%A1%E5%9E%8B%E6%98%AF%E7%BE%8E%E5%9B%BD,%E7%B2%97%E9%99%8B%E7%9A%84%E7%B3%BB%E7%BB%9F%E5%AE%8C%E5%85%A8%E4%B8%8D%E5%90%8C%E3%80%82">多元思维模型 - MBA智库百科</a><br>[^4]: <a href="https://zh.wikipedia.org/wiki/%E5%85%AD%E5%BA%A6%E5%88%86%E9%9A%94%E7%90%86%E8%AE%BA">六度分隔理论 - 维基百科，自由的百科全书</a><br>[^5]: <a href="https://zh.wikipedia.org/wiki/%E7%A7%91%E5%AD%A6%E5%A4%A7%E7%BA%B2">科学大纲 - 维基百科，自由的百科全书</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;今天在开车回家的路上又听了一遍《人是如何学习的》，当听到其中讲专家具有普通人所没有的几大特征时，其中第一条就是专家具有“心理表征”。这里解释到什么是心理表征的时候，我突然感到最近所阅读和学习的知识全部串在了一起，有一种不吐不快的感觉，于是在车里构思了这篇文章。&lt;/p&gt;</summary>
    
    
    
    <category term="Thinking" scheme="http://blog.samwei12.cn/categories/Thinking/"/>
    
    
    <category term="学习力" scheme="http://blog.samwei12.cn/tags/%E5%AD%A6%E4%B9%A0%E5%8A%9B/"/>
    
  </entry>
  
  <entry>
    <title>思维导图软件测评</title>
    <link href="http://blog.samwei12.cn/2021/06/05/Utilities/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%84/"/>
    <id>http://blog.samwei12.cn/2021/06/05/Utilities/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%84/</id>
    <published>2021-06-05T02:14:24.000Z</published>
    <updated>2024-08-01T02:44:08.205Z</updated>
    
    <content type="html"><![CDATA[<p>最近连续写了两篇万字长文，有点累了，而且我也知道这种长文基本上也不太会有人阅读，周末写点测评放松一下。</p><p>这篇文章主要是介绍一下这几年我自己所用过的几款思维导图软件。</p><span id="more"></span><h2 id="使用需求"><a href="#使用需求" class="headerlink" title="使用需求"></a>使用需求</h2><blockquote><p><strong>思维导图</strong>（英语：mind map），又称<strong>脑图</strong>、<strong>心智地图</strong>、<strong>头脑风暴图</strong>、<strong>心智图</strong>、<strong>灵感触发图</strong>、<strong>概念地图</strong>、或<strong>思维地图</strong>，是一种用图像整理信息的图解。它用一个中央关键词或想法以辐射线形连接所有的代表字词、想法、任务或其它关联项目。它可以利用不同的方式去表现人们的想法，如引题式、可见形象化式、建构系统式和分类式。</p></blockquote><p>以上是维基百科对思维导图的定义，我相信很多人应该都是听说过或者用过思维导图的，思维导图比起传统的文字列表来说更加直观，更加接近人在思考时的空间想象，非常适合用于任务拆解、项目规划、头脑风暴、记录笔记等。比如我我自己在编写文章之前，通常会先用思维导图构建一下整体大纲，明确论点、论据等要素。</p><p>在进行软件测评之前，我们还是先梳理一下自己在使用思维导图时候具体有哪些诉求：</p><ol><li>简洁直观，编辑功能强大易用性好</li><li>支持的格式丰富。对我自己来说，比较常用的导出包括 PDF 和 Markdown， PDF 是为了跟同事或者其他人分享，Markdown 则是方便进行文本写作。</li><li>跨平台。这个不是特别强诉求，大部分情况下我是苹果全家桶，偶尔会有 Windows 诉求，不过我考虑到后面可能会换成安卓手机使用，选用软件时候要提前纳入筛选条件。</li></ol><h2 id="iThoughts-最近几年关注不多，信息不是最新"><a href="#iThoughts-最近几年关注不多，信息不是最新" class="headerlink" title="iThoughts 最近几年关注不多，信息不是最新"></a>iThoughts <del>最近几年关注不多，信息不是最新</del></h2><p><img src="https://learner.oss-cn-hangzhou.aliyuncs.com/img/20210605103641.jpg" alt="en-mac-a-uses.jpg"></p><ul><li>支持平台： Mac、iOS、Windows</li><li>售价：单平台 360￥</li><li>优势：老牌导图软件，稳定性很强；Native 开发，性能好；支持买断</li><li>劣势：有点小众，界面略丑</li><li>推荐：★★★☆</li></ul><p>iThoughts 可以算是我接触最早的思维导图软件了，大概在12-13 年左右开始使用，最开始的时候感觉还是蛮棒的，颜值一般，但是性能很优秀，编辑撤销、拖拽等都很不错。使用多起来之后发现有点不尽人意了，我当时用的时候只有 Mac 跟 iOS，换 Windows 电脑就无法编辑了（现在已经支持），且样式、模板支持的很少，不支持圈选概要等，逐步不再使用了。</p><h2 id="Mindnode"><a href="#Mindnode" class="headerlink" title="Mindnode"></a>Mindnode</h2><p><img src="https://learner.oss-cn-hangzhou.aliyuncs.com/img/20210605104643.png" alt="img"></p><ul><li>支持平台： Mac、iOS</li><li>售价：订阅制 130￥每年</li><li>优势：界面超级简洁优雅；Native 开发，性能好；任务管理较好；Lock-in 成本低</li><li>劣势：新版本只能订阅； 免费版几乎不可用；仅支持苹果全家桶；不支持选定分支导出</li><li>推荐：★★★★</li></ul><p>Mindnode 是我在抛弃 iThought 之后接触到的软件，同样也是基于 Native 开发的，这种模式的优势在于能够最好的利用原生系统，例如 iOS 上面的各种手势，同时性能通常都很棒，各种拖拽、编辑撤销都不在话下，体验十分顺滑；劣势就是一般跨平台支持不佳，原因在于每个系统都需要进行一套新的开发适配，Mac 跟 iOS 相对是最好打通的了，但是 Windows 和安卓的支持就比较困难，同时不同系统间差异性很大，想要完成迁移且保持跟苹果系统中同样的体验是非常困难的，我想这也是 Mindnode 至今没有出 Windows 版的原因。</p><p>Mindnode 基本上可以说是我用过的导图软件里面颜值最高的，且界面非常克制，简洁的不像话，没有那些花里胡哨的功能，给人十分优雅的感觉。同时，Mindnode 的任务管理是这些软件里面做的最好的，父节点标注为 Task，会直接将全部子节点都标记为 Task，且子节点完成时候会实时更新父节点进度。</p><p>很长一段时间内，我都在 XMind 和 Mindnode 之前纠结徘徊，感觉这两款软件都有做的很棒的地方，不过后面还是 转向了 XMind，毕竟国产软件很大程度上是具有先天优势的。</p><h2 id="XMind"><a href="#XMind" class="headerlink" title="XMind"></a>XMind</h2><p><img src="https://learner.oss-cn-hangzhou.aliyuncs.com/img/20210605110342.png" alt="PC"></p><ul><li>支持平台： 全平台，Mac、Windows、Linux、iOS、安卓</li><li>售价：订阅制 388￥每年</li><li>优势：Electric 开发，跨平台支持好；国产软件，本土化程度最高；功能超级丰富</li><li>劣势：不支持买断；售价不菲；格式 Lock-in 成本较高；图片编辑较差；流畅程度不及 Native 软件</li><li>推荐：★★★★☆</li></ul><p>XMind 可以说是国产之光了，目前国内思维导图这块使用者最多，后来者居上，赶超了各种国内外老牌思维导图软件。</p><p>我最早接触到这款软件是通过 XMind8，当时还是用 Java 开发的，界面不说丑陋反正也不好看，而且操作很容易卡顿，主要是因为公司内置了这款软件，同事间交流很方便，因此被迫使用，当时的主力还是 Mindnode。</p><h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><p>那时候我还不知道 XMind 的开发者在国内，只是突然有一天关注到 XMind 新出了一款替代产品，XMind Zen。最开始确实有点惊为天人的感觉，完全甩 XMind8 不知道几条街，根本看不出来是一款迭代产品，实际上了解下来，基本上可以说是完全重做了，底层的也换成了 electric 开发，最显而易见的好处就是颜值立马在线了，且操作流畅程度大幅度提升，直接进入到了思维导图第一梯队，可以跟 Mindnode 正面抗衡了。</p><img src="https://learner.oss-cn-hangzhou.aliyuncs.com/img/20210605111825.png" alt="image-20210605111825481" style="zoom:50%;" /><img src="https://learner.oss-cn-hangzhou.aliyuncs.com/img/20210605112553.png" alt="image-20210605112553242" style="zoom:50%;" /><p>但不得不说，国内互联网开发者推出的产品最大优势就是本土化程度实在是高出国外软件不知道多少，且国内互联网的另一个特点就是拼，非常的拼（可以说深得内卷精髓），产品迭代速度通常都是碾压国外软件，在最近短短一两年内，XMind 就推出了众多重磅功能，Zen 模式、密码设置，还有接下来还即将要推出<strong>演示模式</strong>，可以说都是非常符合国人诉求的。同时，XMind 中提供了大量丰富的样式与模板，包括矩阵、树状图、时间轴、鱼骨图等等；还提供了一个图库，包含很多非常有用的模板，例如简历、读后感、组织架构图等等，也难怪市场占有率如此之高。</p><h3 id="劣势"><a href="#劣势" class="headerlink" title="劣势"></a>劣势</h3><p>不过 XMind 目前还是存在部分使用上的问题的，我个人比较不爽的就是软件格式的 Lock-In 成本有点高，这也是国产软件的通病。所谓的软件 Lock-in 成本就是指当你想要从该软件迁移到同类其他软件的时候，所需要花费的代价。通常，国外软件不管做的好还是差，一般导出功能都是比较完整的，可以很简单的就将用户数据迁移到其他软件，而国产软件的套路通常是导入功能第一优先级开发，不管你是什么奇奇怪怪的小众格式，只要你有用户，我就支持，且一般支持的都还不错；当用户迁移完毕之后，想要出去就没那么简单了，导出格式较少、bug 很多、导出数据不完整这都算是小意思了，更有甚者，想要导出，可以，买会员先（说的就是你，收趣），真的是把我恶心到了。</p><p>XMind 支持的导出格式倒是不少，PDF、Word、Markdown 等，看起来很够用了，不过这里对于图片的编辑导出实在是太弱了。类似 PDF 这种格式就不提了，只是单向导出，并不能进行编辑。你总不希望你以后所有的导图都是一个只读的 PDF 吧。所以我比较关注的是可以双向读写的 Markdown 格式，Textbundle 本质上就是 Markdown+图片。</p><p>当你粘贴图片的时候，没有任何问题，但当你想要把图片拷贝出来的时候，问题来了， 你会发现你拷贝出来的内容大概是这样的 <code>[&#123;&quot;src&quot;:&quot;xap:resources/4a36ee50ecad8ba5db10a187b23d1024db4c4cbc1527f90fc65251f6499ff926.png&quot;,&quot;width&quot;:756,&quot;height&quot;:702&#125;]</code> ，怎么样，是不是看不懂，看不懂就对了，这个路径是 XMind 自己内部的一个资源库路径，对外根本不可读（而且 XMind 至今都不支持 URL Scheme），这时候你能做的就是将这个图片右键另存为，当你发现你的导图里面保存了几十张图片的时候，是不是要死的心都有了？</p><p>此时你可能想，我直接导出文件不好吗，年轻人，太天真了，当你导出 Markdown 时候会发现根本没有任何图片，此时你可能想到我上面说的，TextBundle 可以啊，然而当你点击 TextBundle 导出的时候，你会看到如下对话框：</p><img src="https://learner.oss-cn-hangzhou.aliyuncs.com/img/20210605114541.png" alt="image-20210605114540987" style="zoom:50%;" /><p>惊不惊喜，意不意外？是不是感觉这个套路很熟悉，好像在哪里见过？于是你不得不接受一个事实，哪怕你可以用它任意编辑，随便白嫖，原本以为只是导出图片有点水印，根本不影响使用，但你想要跳出 XMind 的时候，发现你的套路全部都在意料之中，对方早就预判了你的预判。</p><p><img src="http://img.soogif.com/UdBrosApKOFLptMkiOG45OVe6zj4pVTK.gif"></p><p>这时候你的选择是什么？当然是原谅她，老老实实买个会员再说。</p><h2 id="FreePlane"><a href="#FreePlane" class="headerlink" title="FreePlane"></a>FreePlane</h2><p><img src="https://learner.oss-cn-hangzhou.aliyuncs.com/img/20210605120411.jpeg" alt="Some applications of Freeplane"></p><ul><li>支持平台： 仅支持桌面端，Mac、Windows、Linux</li><li>售价：开源免费</li><li>优势：Java 开发，跨平台；支持 URL Scheme；功能齐全，支持框选、总结等</li><li>劣势：界面实在是下不了手；导出功能太差；中文支持一般；图片编辑非常不好用；不支持预览</li><li>推荐：★★☆</li></ul><p>我是在一个偶然的机会看到知乎上 @临时哈桑 对思维导图的评价中知道 Freeplane 的，原话是 Freeplane 从性能到功能都吊打各种商业产品，唯一的缺点是丑。当时我刚好是想要替换到 XMind 的，除了贵，就是偶尔卡顿，Lock-in 成本较高，于是抱着很期待的心态下载了 Freeplane 进行使用。</p><h3 id="优势-1"><a href="#优势-1" class="headerlink" title="优势"></a>优势</h3><p>先说优点吧，别的不提，Freeplane 是开源免费软件，这一点就足够让人心动了，大部分人的使用频次都没有那么高，为了一个一周用两三次的软件，每年花几百块，说实话是有点贵的。开源的优势在于，不用担心这个软件哪天突然死掉，比如 XMind 现在公司经营不善倒了，可能会良心的提供非会员也导出功能；还有一种可能性是趁倒之前捞一波，劝你赶紧买会员导出。而开源软件就不会有这个问题，大不了自己把代码拉下来编译一次就可以了，该怎么用就怎么用；况且一般这种开源软件不再维护的时候，通常会提供比较完整的善后手段，或者会有其他产品接盘。</p><p>其次，功能是真的齐全，我个人不负责任的猜测 XMind 中的大部分功能可能是有借鉴 Freeplane 的，上图可以看到，支持各种样式、总结、指向等等，甚至编辑框直接内嵌了一个 HTML，可以自由发挥。</p><img src="https://learner.oss-cn-hangzhou.aliyuncs.com/img/20210605122515.png" alt="image-20210605122515228" style="zoom:50%;" /><p>支持 URL Scheme，可以从任意支持 URL 的软件直接跳转到对应的导图甚至节点，配合很多编辑软件或者 GTD 软件有奇效。</p><p>可以说作为一款免费软件，确实功能已经非常丰富了，单从功能上来说，可以碾压之前的 XMind8，部分功能超过现在的 XMind Zen，不过XMind Zen 实在发展太快，已经赶上来甚至部分超越了。</p><h3 id="劣势-1"><a href="#劣势-1" class="headerlink" title="劣势"></a>劣势</h3><p>说完了优点，来聊一下这款软件的缺点。</p><p>首先， 界面是真的丑，软件是使用 Java 开发的，延续了十几年前那种 Java UI 的风格，可以说对比起 Mindnode 和 XMind Zen 来说，完全下不了手，不过这个也在预期内，可以理解，毕竟是开源产品，用爱发电。</p><p>其次，中文支持不够完善，我个人自从学会双拼之后就再也离不开了，可以说双拼极大地提升了我的打字效率，然而，Freeplane 对双拼支持贼差，每次新建节点编辑的时候，都会将双拼的第一个字母也带上输出出来，大概长这样： <img src="https://learner.oss-cn-hangzhou.aliyuncs.com/img/20210605123147.png" alt="image-20210605123147077" style="zoom:50%;" />，测试的双拼是 <code>ceui</code> ，就会把第一个 c 带到文字里面，十分不方便。</p><ul><li>这里我总结出一个小技巧，当你新建节点的时候，先按<code>F2</code> 进入文本编辑模式，之后再进行输入就 OK 了，不过每次都这么搞一下，依然十分蛋疼</li></ul><p>图片编辑很不方便，无法像 XMind 那种，好歹是把图片拷贝到他自己的资源库目录中，Freeplane 的图片只能选择本地文件进行插入，且只是挂了一个链接，大概长这样，可以看到格式是使用的 URI, 也就是标定一个本地路径，<img src="https://learner.oss-cn-hangzhou.aliyuncs.com/img/20210605123922.png" alt="image-20210605123922350">。</p><p>好处是什么呢？保存的导图文件里面不带有原始图片，大小会非常小，同样节点的 XMind 大约是 Freeplane 格式的 <strong>4 倍</strong>大小，算上大图片那就远远不止了；坏处也非常明显，当你本地这个图片的位置发生变更之后，对应的导图文件当然也没有图片了，直接报错，大概长这样：<img src="https://learner.oss-cn-hangzhou.aliyuncs.com/img/20210605124031.png" alt="image-20210605124031113" style="zoom:50%;" />，你应该能想象出来，这是有多么蛋疼。</p><ul><li>小技巧：将图片拷贝到导图目录下，新建一个 assets 文件夹专门用于存放导图资源可以缓解这个问题，不过依然难受。</li></ul><p>文件格式是纯文本，Freeplane 的文件格式采用的是 XML 格式，后缀名为 <code>.mm</code> ，是不是有点熟悉，没错，默认打开方式是 Xcode，让我有种回到之前开发 iOS 的感觉。短暂怀念一下之后你会发现，纯文本格式的劣势就是完全无法预览，我在文件列表里面看到一堆导图的时候，根本不知道每个里面都是什么，除非我一个个打开，会有种拆盲盒的感觉，这时候你才会发现 XMind 这种可以直接在文件列表里面预览全部内容的软件是多么的可爱。</p><p>如果说上面的问题都还是小毛病的话，那么导出问题可以说是非常致命了。看起来 Freeplane 支持的导出格式非常的多，不仅支持PDF、Markdown、XML、PNG，还支持 HTML、SVG，可以说很多格式我听都没听说过，比如 <code>.tji</code> 、 <code>.twi</code> 等等，总之就是非常强大啦。然而实际使用的时候你就会发现，导出 PDF 时候直接整个 App 卡死，这没什么，毕竟它有提示你<img src="https://learner.oss-cn-hangzhou.aliyuncs.com/img/20210605124604.png" alt="image-20210605124604936">，但当你等了一小时之后，依然卡在这里的时候，你大概也会像我一样怀疑人生了。不确定这个 bug 是否跟中文有关。</p><img src="http://img.soogif.com/9IWYiRP2Cz3mvVIlaP8Bhxq9CoFfBck1.jpeg" style="zoom:50%;" /><p>同时它还支持分支导出，嗯，跟整个导图导出支持的格式还不一样，真正常用的 PNG、PDF这时候你会发现全部不支持，OK，这个忍了。继续操作，导出 Markdown 总可以了吧，这时候你会发现，永远提示你导出失败，且重试无效，依然失败。</p><p>吐槽结束，总的来说，Freeplane 在某些地方确实还是有可取之处的，例如内链、支持总结、高度自由的编辑器等等，但作为一个用户来说，说实话我无法接受使用这种产品，如果你不是程序员，你可能接受程度比我还低，根本不知道为什么 <code>.mm</code> 后缀会无法预览，不明白什么是 XML，玩不懂里面的内链。我的结论是这款软件可以把玩一下，但不适合普通用户日常使用。</p><p><del>幕布（未完待续）</del></p><p><del>ProcessOn（未完待续）</del></p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>这里上一个汇总表格，可以比较直观的看出各个软件的差异，目前看起来最能打的依然还是 XMind，希望后面开发者能够多上点心，用产品而不是用小手段吸引用户。</p><p><img src="https://learner.oss-cn-hangzhou.aliyuncs.com/img/20210605130906.png" alt="image-20210605130906530"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近连续写了两篇万字长文，有点累了，而且我也知道这种长文基本上也不太会有人阅读，周末写点测评放松一下。&lt;/p&gt;
&lt;p&gt;这篇文章主要是介绍一下这几年我自己所用过的几款思维导图软件。&lt;/p&gt;</summary>
    
    
    
    <category term="Utilities" scheme="http://blog.samwei12.cn/categories/Utilities/"/>
    
    
    <category term="测评" scheme="http://blog.samwei12.cn/tags/%E6%B5%8B%E8%AF%84/"/>
    
    <category term="Software" scheme="http://blog.samwei12.cn/tags/Software/"/>
    
    <category term="思维导图" scheme="http://blog.samwei12.cn/tags/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>小强升职记-笔记和关于时间管理的思考实践</title>
    <link href="http://blog.samwei12.cn/2021/05/23/Reading/%E5%B0%8F%E5%BC%BA%E5%8D%87%E8%81%8C%E8%AE%B0-%E7%AC%94%E8%AE%B0%E5%92%8C%E5%85%B3%E4%BA%8E%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86%E7%9A%84%E6%80%9D%E8%80%83%E5%AE%9E%E8%B7%B5/"/>
    <id>http://blog.samwei12.cn/2021/05/23/Reading/%E5%B0%8F%E5%BC%BA%E5%8D%87%E8%81%8C%E8%AE%B0-%E7%AC%94%E8%AE%B0%E5%92%8C%E5%85%B3%E4%BA%8E%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86%E7%9A%84%E6%80%9D%E8%80%83%E5%AE%9E%E8%B7%B5/</id>
    <published>2021-05-23T03:56:45.000Z</published>
    <updated>2024-07-31T18:16:36.788Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>五一期间阅读完毕了《小强升职记》一书，感觉收获颇丰，对自己的时间管理进行了更加深入的思考和了解。本文就针对我在阅读过程中所记录的一些笔记以及思考实践进行一个回顾总结。</p><p>这本书的主线是介绍主人公职场菜鸟小强在大牛老付的帮助下，一步步理清楚自己在时间管理方面所犯下的一些错误，并且进行改正完善，之后慢慢从菜鸟走向一名比较成熟合格的技术负责人的整个历程，按照这条成长路线来进行叙述的。可以看出作者在这方面的功底非常深厚，深入浅出的就把时间管理中常犯的一些错误和如何应对逐步的展开来讲述。</p><span id="more"></span><p>作者类比了一棵树苗成长的过程来进行章节划分：</p><ul><li>种子—找到时间黑洞，找出职业价值观</li><li>树苗—学习四象限法则、衣柜整理法</li><li>枝叶—如何战胜拖延，如何要事优先，如何处理临时突发事件</li><li>开花—如何养成一个好习惯</li><li>结果—如何让想法落地</li><li>收获—如何建立高效办公区，逐步走向高效率、慢生活</li></ul><p>我感觉这个类比稍稍有点不是很切合，全文比较干货的是在第二章，详细介绍了一些非常实用的时间管理工具，其中有不少是我之前就一直在实践的，但系统的跟着作者再次学习一遍，感觉自己之前只是了解了一些皮毛。这也给了我一个教训，自己随便网上搜了一下一些概念，然后就上手实践是有一些不太可取的地方的，还是需要通过书籍来深入了解一下背后的思想理念，相比于附带的知识价值来说，书籍真的是非常非常便宜的东西了。</p><p>接下来我简单按照阅读的顺序进行一些重点汇总。</p><h2 id="消灭时间黑洞"><a href="#消灭时间黑洞" class="headerlink" title="消灭时间黑洞"></a>消灭时间黑洞</h2><p>开篇老付先是通过给小强介绍“时间黑洞”的概念来引导小强进行思考和记录，明白时间黑洞在我们日常工作生活中的占比有多高。尤其是当下我们这个信息洪流时代，可以说你的专注力无时无刻不在被周围各种信息所打断所消耗。打个比方说，你只是想要打开手机搜一下某个资料或者文章，解锁手机之后发现有人给你发微信消息，赶紧点进去看看内容，聊了一会之后，收到了新的公众号提醒，翻进去看了一下，又弹出微博或者抖音的推送消息，当你刷了半小时抖音之后，已经完全不记得之前想要查找什么了。可以说这已经成为一个很普遍的现象了，毕竟现在专门有着高薪的产品经理在研究如何做出一个紧紧抓牢你的产品，配合人工智能大数据等，例如抖音会给你疯狂推送你喜欢看的内容，几乎可以做到让你一下午坐在沙发里面刷抖音刷到水都想不起来喝一点。这也是我为什么越来越不喜欢在手机上进行深度阅读和思考的原因，不要太高估你的意志力和专注力，也不要低估你手机上那些 APP 对你的影响。</p><p>老付给出的解决方案是进行时间日志记录，这里有两种记录方式。首先，刚开始使用的时候，可以把自己每天的时间花费在哪些事情上面挨个记录下来，知道自己一天有多少时间是真正工作的时间，有多少是划水、玩手机等；之后，慢慢了解了自己的时间使用分布，可以先设定一下自己今天的时间安排，最好细化到每个小时，然后记录实际完成情况，中断次数等，目的是为了明确自己被打断的频率，自己的高效工作时间。</p><p>这里可以推荐几个我在实践过程中发现的比较切合这个场景的软件。</p><p>首先，Mac 上可以使用”Qbserve”软件，它可以很方便的记录你在使用电脑时候的效率情况，包括每个 APP 的使用时长、浏览的每个网站等，还是蛮细致的，但它有个很明显的缺点，无法记录手机时间，同时跨设备目前还不支持。手机上可以使用“时间块”这款软件搭配使用，用来标注自己每天的时间使用情况，不过它也有个明显的缺点，自动化程度太低，几乎全是要靠手动点击操作，尽管软件已经简化了使用步骤，但每天到了晚上提醒的时候，回想一天的事情，然后一个个点击，其实还是蛮消耗精力的。</p><p>Qbserve 截图：</p><img src="https://learner.oss-cn-hangzhou.aliyuncs.com/img/20210528215926.png" alt="image-20210528215926307" style="zoom:50%;" /><p>时间块截图，可以看到每天实际认真工作的时间比你想象的要少得多：</p><img src="https://learner.oss-cn-hangzhou.aliyuncs.com/img/20210528220125.jpeg" alt="IMG_57AD02BD4850-1" style="zoom:33%;" /><p>其次，需要安排自己每天的工作，细化到下一个小时应该做什么，然后记录下实际完成的情况，包括被打断的情况，坚持一周之后你就可以知道自己的高效时间段在哪里。通常来说，一般人的精力是跟血糖浓度成正比的，所以为什么快到饭点的时候效率很低，就是因为血糖含量较低，所以上午 10-11 点，下午 2-4 点通常效率是比较高的。但是由于白天被打断的频率会比较高，也会有很多人喜欢在晚上甚至夜里工作，这样更容易专注，找到适合你自己的高效时间段是很有必要的，因人而异。比如我自己，最近发现早上效率还蛮高的，没有人打扰，所以我最近在坚持早起，每天 7 点半左右起床，离 9 点出门上班，中间有一个多的专注时间，可以用来进行看书、写作等，同时中午公司一般有午休习惯，我会提前去吃中饭，在吃过中饭之后快速进行一会午休，然后在大家还在休息的时候，可以找到大约半小时左右的专注时间，用来思考下午的工作，或者完成一些比较重要的工作。</p><p>找到高效时间的意义是什么呢？这里有一个原则叫做“三只青蛙”，就是说每天早上梳理出当天必须要完成的三件事情，通常是重要性或者困难度比较高的事情，优先把这几件事情完成，其余的零碎小事做不完也没有关系。所以找到你最高效的时间段，安排“三只青蛙”就显得比较重要了。</p><p>书中讲到一个例子十分发人深思：同事 A 每次重要的事情都能办的很棒，但是在一些零碎小事上经常出问题；同事 B 平时各种小事做的很好，但一旦遇到重要的大事，就出幺蛾子。如果你是老板，会如何对待这两位同事呢？答案很残酷，从老板的角度考虑，重要的事情办的很棒的同事 A 明显是可以委以重任的，可能还会给他安排一个秘书或者助手协助完成一些琐碎的小事；同事 B 一到关键时刻老是掉链子，那么就把各种琐碎小事都分配给他。这样的结果就是同事 A 逐步得到重用，且每天只需要完成一些重要的事情即可；同事 B 逐步被边缘化，永远只能在琐碎的小事中忙的不可开交。所以找到对老板来说比较重要的事情来做，以及锻炼自己完成要事的能力是非常重要的。</p><h2 id="明确自己的职业价值观"><a href="#明确自己的职业价值观" class="headerlink" title="明确自己的职业价值观"></a>明确自己的职业价值观</h2><p>那么如何判断一件事情对你来说有多重要呢？随后作者给出了一个评判标准： 职业价值观。</p><blockquote><p>所谓价值观是指一个人对周围的客观事物（包括人、事、物）的意义、重要性的总评价和总看法。</p></blockquote><p>职业价值观指的就是对于你的职业生涯来说，你对平时遇到的这些客观事物的意义、重要性的评价和看法。听起来是很虚的东西，这里作者提供了一个如何找到职业价值观的方法，是一套职业价值观自测的题目，我在网上找到了对应的网站： <a href="http://www.181du.com/survey/Workvalues/index.aspx">http://www.181du.com/survey/Workvalues/index.aspx</a> 。</p><p>一共 52 道题目，我自己做下来之后，得到的排名前三的价值观分别是：智力刺激、人际关系、社会地位。</p><p>不过思考下来，你就会发现这里作者讲的还是稍微有点不够透彻，价值观跟日常事情的评判中间感觉缺失了一个环节。首先，这个价值观题目你做完之后，会发现并没有特别深的感触，起码对我来说是这样，并不会有那种开悟的感觉，一下子就知道了自己的目标之类的，甚至你可能都觉得它不准；其次，有了这个价值观之后，你就知道如何评判一件事情的重要性和优先级了嘛？好像也并没有，实操性有点差。</p><p>我个人觉得，价值观可能只能作为一个指导思想，引导你进一步进行思考，实际上如果真的想要做到日常事情可评判，还需要一个更近期的目标和工具，为了解决这个问题，通常公司里面都会进行目标管理，一般使用 OKR 或者 KPI 这样的工具进行管理。对于个人来说，也可以设定一个未来 3-5 年的目标，然后逐步拆解，做一个年度计划，月度计划等，这样你就知道现在分配给你的事情对你来说优先级如何，接下来应该做什么。这个目标制定感觉后面讲到的六个高度更加贴近实际使用。</p><h2 id="时间管理工具"><a href="#时间管理工具" class="headerlink" title="时间管理工具"></a>时间管理工具</h2><p>这一章我自己感觉是这本书最精华的部分，起码对于初步开始进行时间管理的我来说是这样，介绍了很多实用的管理工具和思想。我印象最深的就是：</p><blockquote><p>做事要考系统而不是靠感觉</p></blockquote><p>之前虽然也有积累一些自己的小系统，但是并没有这么明确的提出来，看到这句话的时候确实有点共鸣，有点类似于之前看过的《清单革命》一书，后面会注意把自己平时逐步在形成的小系统全部记录下来，真正的做到处理各种事情都有固定套路，这样才能既高效又不容易出错。</p><h3 id="四象限法则"><a href="#四象限法则" class="headerlink" title="四象限法则"></a>四象限法则</h3><p>这篇里面很核心的一个内容就是介绍四象限法则，这个大家应该都已经听过了，所有的待办事项按照重要性和紧急程度可以划分为重要且紧急、重要不紧急、紧急不重要、不重要不紧急四类。</p><p>首先，我们要明确的是，待办事项的重要性和紧急性是如何判断的呢？原则如下：</p><ol><li>重要性可以根据你自身的职业价值观或者职业规划来进行</li><li>紧迫程度取决于任务的截止时间，这个很好理解，毕竟 Deadline 是第一生产力~</li></ol><p>其次，我们要知道如何应对这四个象限的任务：</p><p><img src="https://learner.oss-cn-hangzhou.aliyuncs.com/img/20210531084505.png" alt="img"></p><p>如上图所示，这里的原则是：</p><ol><li>重要且紧急的事情，需要立马去执行</li><li>重要且不紧急的事情，需要制定工作计划，定期去执行</li><li>紧急但不重要的事情，可以委托他人完成</li><li>不重要不紧急的事情，拒绝完成</li></ol><p>下面我们详细展开一下：</p><h4 id="重要且紧急-立刻去做"><a href="#重要且紧急-立刻去做" class="headerlink" title="重要且紧急-立刻去做"></a>重要且紧急-立刻去做</h4><p>这个没什么可说的，应该是去立马完成的。</p><blockquote><p>我们工作中的主要压力就来自于第一象限，我们生活中的主要危机也来自于第一象限。</p></blockquote><p>不过这里有个点需要思考的是，我们需要避免太多事情进入第一象限，原因也很简单，他会毫无原则的排挤开其他任何事情，独占你的时间，那么随着进入这个象限的次数越来越多，你会逐渐被事情推着走，变得毫无目的的不停地忙碌，这当然不是我们想要的。</p><p>那么应该如何减少进入这个象限的次数呢？应该说进入这个象限的任务大多数是由于第二象限没有处理好导致的。例如，下个月要进行一次汇报，正常情况下应该提前完成部分工作，例如整体大纲，部分材料收集等等，但由于人天然的惰性，不到 DDL 绝不动工，那么当你发现明天或者后天就要进行汇报的时候，这个事情就进入到了第一象限，导致你不得不连续熬夜完成它，同时效果必然会打折扣。</p><h4 id="重要不紧急-优先把精力投入到这个象限"><a href="#重要不紧急-优先把精力投入到这个象限" class="headerlink" title="重要不紧急-优先把精力投入到这个象限"></a>重要不紧急-优先把精力投入到这个象限</h4><p>有计划的去完成。通常来说，这个象限的事情都是一些需要长期坚持，且短时间内很难看到明确收益，换句话说也就是延迟满足的事情，例如，阅读一本书、学习一门语言等等。</p><p>第二象限的优先级是最高的，因为它的长期收益最大，对你的成长最有帮助。但大多数情况下都被第一象限或者第三象限那些更紧急的事情阻塞导致没有进展，人总是会优先处理那些简单且有明确时间的事情，这样的好处就是可以得到及时反馈和满足，这个是人类的天性，正常是很难跳出这个坑的。</p><p>那么我们应该如何让自己尽可能的多处于第二象限呢？</p><blockquote><p>消除时间管理的三大杀手——信息不够、拖延、预期结果不明确。</p></blockquote><p>我们需要对收集篮里面的任务或者待办事情进行进一步的处理，针对上面提到的时间管理的几个坑：</p><ol><li>尽可能明确更多信息。包括执行步骤、上下文、起止时间</li><li>步骤拆分的尽可能细。人总是喜欢及时反馈，所以我们要把步骤分解的更细，这样每天都可以完成一小部分</li><li>写清楚最终目标。这点也是我经常忽略的，对于一个长期任务来说，明确任务预期效果是很重要的，这样我们就可以知道完成的情况、是否需要调整以及以后应该如何优化</li><li>计划花费的时间。提前对该工作进行评估，可以使用甘特图等工具辅助</li><li>负责人是谁。明确第一责任人，事情才能推进的更顺利</li></ol><h4 id="紧急不重要-委托别人去做"><a href="#紧急不重要-委托别人去做" class="headerlink" title="紧急不重要-委托别人去做"></a>紧急不重要-委托别人去做</h4><p>委派给他人去完成。通常来说，这个象限经常会出现一些零碎的小事情，可能完成它对你来说并不会有太大成长，但是由于是老板指派或者是某个大项目中的一个不可或缺的环节又或者是他人的一些请求，导致你不得不停掉手上其他事情来完成它。这里有一个很有意思的“猴子法则”可以帮助你跳出这个象限。</p><p><img src="https://learner.oss-cn-hangzhou.aliyuncs.com/img/20210531090937.jpeg" alt="00028"></p><blockquote><p>比尔·翁肯（Bill Oncken）曾经提出一个理论，叫‘背上的猴子’。翁肯教授有一次偶然发现，自己在忙于加班的时候，下属竟然在优哉游哉地打高尔夫。这让他突然领悟到，主管人员之所以时间不够用，一个很重要的原因在于没有做好授权分责，将太多本该下属去做的工作招揽到了自己身上，以至于永远在苦苦追赶工作进度。</p></blockquote><p>这里的猴子，指的就是待办的事情和职责。例如，中午休息的时候突然遇到了愁眉不展的同事，经过询问，原来是被某个技术难题所阻塞了，经过半小时的讨论发现确实是个棘手的问题，你一时半会也没有思路，这时候你说我回去再想想。之后这个猴子就从同事身上跑到了你的身上，然后同事就可能琢磨别的问题了，过半天过来问一下，上次那个问题有方案了吗？这时候你就会发现你的时间慢慢被这些原本不属于你的事情和职责所沾满了，导致你无法完成自己的第二象限甚至第一象限任务。</p><p>当然，帮助他人是有必要的，前提是你要先完成自己的事情，且要注意分寸，明确职责，避免让他人的事情成为你的事情，不要轻易的被他人“赋能”了。</p><blockquote><p>下属问：我们怎么解决项目预算超支的问题？</p><p>你回答：你有什么想法？能不能先请你做一个删减成本的计划案？</p></blockquote><p>不过这里有两个重点一定要明确：</p><ol><li>明确职责，确定这只猴子不是你的。否则就变成了你在推卸责任。</li><li>注意沟通方式，明确、坚决、不生硬。</li></ol><p>那么如果有些时候，确实有一些老板指派的或者他人的事情不得不你来完成，应该如何处理呢？这里需要加上你自己的思考，了解清楚这个任务的上下文背景、明确具体的时间点、同时需要问清楚预期结果，也就是上面提到的“信息不够、拖延、预期结果不明确”。</p><h4 id="不重要不紧急-避免做"><a href="#不重要不紧急-避免做" class="headerlink" title="不重要不紧急-避免做"></a>不重要不紧急-避免做</h4><p>这个没什么可说的， 尽量不做，尤其是尽量别在工作时间进入该象限。比如玩游戏、看电视剧、刷抖音什么的，偶尔忙碌空闲可以稍微放松一下，但是注意分寸，毕竟现在的手机软件太吸引注意力了，很容易就陷入“时间黑洞”中而不自知。</p><h3 id="衣柜整理法（GTD-工作法）"><a href="#衣柜整理法（GTD-工作法）" class="headerlink" title="衣柜整理法（GTD 工作法）"></a>衣柜整理法（GTD 工作法）</h3><p>这篇主要是介绍了一下如何实践 GTD 工作法，作者形象的比作衣柜整理法，之前我对 GTD 也多少有些了解，但并没有知道的这么详细，下面详细记录一下。</p><blockquote><p>GETTING THINGS DONE® is a personal productivity methodology that redefines how you approach your life and work.</p></blockquote><p>GTD 是由 戴维·艾伦 在《搞定》一书中提出的方法论，这里是<a href="https://gettingthingsdone.com/what-is-gtd/">官方网站</a>。它的目的是用来快速整理你的日常生活和工作，把他们从混乱变得井井有条。</p><p>GTD 包含 5 个步骤：</p><h4 id="CAPTURE-捕捉"><a href="#CAPTURE-捕捉" class="headerlink" title="CAPTURE 捕捉"></a>CAPTURE 捕捉</h4><p>捕捉的意思是说，有任何想法、接到新的任务，不要中断当下的事情，而是应该把这些想法和任务记录下来，存放到收集篮（Inbox）中。</p><p>这里需要遵循的原则如下：</p><ol><li>捕捉工具越少越好。避免成为工具控，工具切换的越多，越不容易快速记录，也不容易汇总之后进行组织整理。可以使用笔和纸，也可以使用软件，可以使用绘画板，但是不要同时使用这些工具。</li><li>保证 5 秒钟进入录入状态。确保你的录入流程尽可能的短，这样是为了避免对当前工作产生太大影响。试想一下，如果你记录一下灵感就花了 1 分钟，那么等你回到当前工作时候，还需要重新梳理上下文，进入状态，效率肯定是很低的。</li><li>定期清空收集篮。避免让你的收集篮成为一个永远不打开的仓库（说你呢，Evernote），只收集不执行就没有任何意义。这点也是我当前做的最不好的地方，一起共勉。</li></ol><h4 id="CLARIFY-明确意义"><a href="#CLARIFY-明确意义" class="headerlink" title="CLARIFY 明确意义"></a>CLARIFY 明确意义</h4><p>目的是为了分辨出待办事情中哪些是可以立刻行动的，哪些是需要进一步处理的。</p><p>这里并不是要实际执行行动，而只是单纯的确认这些事情要怎么处理，也就是判断重要性、识别急迫程度、明确优先级、是否可以指派给他人、是否可以在两分钟内完成等。</p><p>原则：</p><ul><li>从最上面一项开始处理<ul><li>确保每件事情都获得均等的机会</li></ul></li><li>一次只处理一件事<ul><li>这点之前做的很不好，经常会过期</li></ul></li><li>永远不要再放回收集篮（被迫中断的事情除外）</li></ul><h5 id="三类不能行动的任务"><a href="#三类不能行动的任务" class="headerlink" title="三类不能行动的任务"></a>三类不能行动的任务</h5><ul><li>垃圾： 这个应该直接过滤掉，不应该进入收集篮浪费时间<ul><li>处理方式： 删除</li></ul></li><li>将来某时：<ul><li>例如整理办公室、收拾屋子等等，并不是特别紧急，</li><li>处理方式：记下来，有空去做</li></ul></li><li>参考资料：<ul><li>处理方式： 分类归档，这里可以参考 PARA方法进行管理，内容较多，后续单独介绍一下。</li></ul></li></ul><h5 id="六类可以行动的任务"><a href="#六类可以行动的任务" class="headerlink" title="六类可以行动的任务"></a>六类可以行动的任务</h5><ul><li>2分钟行动：<ul><li>参考 “两分钟法则”，也就是说某件事情如果两分钟内可以完成，那么就立刻去做</li></ul></li><li>项目： 需要多个步骤，并且多部门协调的事情。</li><li>任务： 需要多个步骤，但可以自己独立完成，拆解为多个行动</li><li>行动： 可以直接去做的事情</li><li>指派给他人：<ul><li>告诉别人这件事的意义、同时明确想要的结果、以及截止时间</li><li>然后在日程表里面加一个定时提醒，用于问询结果</li></ul></li><li>特定时间做的事： 放到日程表里面</li></ul><h5 id="行动、任务、项目的区别"><a href="#行动、任务、项目的区别" class="headerlink" title="行动、任务、项目的区别"></a>行动、任务、项目的区别</h5><ul><li>行动可以直接去做，决定的下一步是具体的时间点</li><li>任务和项目都是由多个行动组成的，但是任务基本由自己独立完成，关注的重点是事情本身；项目关注的重点是人与人的沟通协调。</li><li>决定项目的下一步行动是建立框架，也就是涉及到的资源、干系人等</li><li>行动关注事情的执行，搞定任务的终点是先想清楚结果图像是什么，然后找出实现这个结果的路径，做项目既要知道怎么搞定人，还要把握好这些人的执行情况。</li></ul><h4 id="ORGANIZE-组织整理"><a href="#ORGANIZE-组织整理" class="headerlink" title="ORGANIZE 组织整理"></a>ORGANIZE 组织整理</h4><p>这里主要是按照上面已经明确意义的原则对待办事项进行整理，产出的内容：</p><ul><li>日程表： 这个可以直接同步到系统日历，然后钉钉订阅一下，这样工作日程跟家庭日程都在一起了，便于查看和提醒</li><li>行动清单：每天的工作从这里开始，目前我是使用滴答清单来完成</li><li>项目清单：使用 “甘特图” 进行管理，也可以使用滴答清单</li><li>将来清单： 一般是不紧急，重要性也不是很高的事情，例如体检、洗牙等等。</li></ul><h4 id="REFLECT-深思"><a href="#REFLECT-深思" class="headerlink" title="REFLECT 深思"></a>REFLECT 深思</h4><p>定期的对自己当前的任务进行思考，时间点推荐在每天下班和每个周末完成。包括：</p><ul><li>孵化杂事<ul><li>可以每周对自己的将来清单进行梳理</li></ul></li><li>产生灵感<ul><li>提升高度</li><li>回顾近期的任务完成情况，并且进行归纳总结，制定下一个周期的任务安排</li></ul></li><li>每日回顾：可以参考每日日记<ul><li>今天做了什么？</li><li>对哪些比较满意，哪些不满意？</li><li>推进了哪些重要的事情？</li><li>明天的规划是什么？</li></ul></li><li>每周回顾：<ul><li>清空收集篮</li><li>回顾一下将来清单、行动清单、项目清单<ul><li>将来清单： 是否有可以孵化到行动清单的内容？</li><li>行动清单： 是否有过期任务需要调整？是否需要指定或者变更具体的日期？</li><li>项目清单： 自己下一步应该做什么？现在项目的完成度是多少？项目要取得什么样的成果？</li></ul></li><li>检视日程表</li></ul></li></ul><h4 id="ENGAGE-行动"><a href="#ENGAGE-行动" class="headerlink" title="ENGAGE 行动"></a>ENGAGE 行动</h4><p>确保脑袋里面只装一件事情，这里可以利用 番茄工作法，使用一些例如降噪耳机、白噪声等工具辅助自己提升专注力。</p><p>同时，通过把任务拆分的尽可能细，就可以在每完成一小步的时候就进行打勾消除，这是一种很有成就感的事情，这种正向反馈会激励你进一步完成后面的步骤，不知不觉中就把一个大任务完成掉了。</p><h5 id="灵感收集技巧"><a href="#灵感收集技巧" class="headerlink" title="灵感收集技巧"></a>灵感收集技巧</h5><p>这里有一些技巧可以用于提高行动的效率，主要是在快速记录待办清单的时候，对任务描述的足够清晰，因为在记录事情的时候你是很清楚要做什么的，但等真正开始做可能已经是几天后了，这时候还要拼命回忆之前的对话和上下文，比较费力。所以这里的技巧主要是用于消除不确定性：</p><ol><li>秘诀一：动词开头。例如评估一下 xx 工作工期、去超市买 xx 等。</li><li>秘诀二：内容清晰。标注清楚具体的时间、地点等信息，可以参考 “5W2H原则”。</li><li>秘诀三：描述预期结果。在做这件事之前最好就先想清楚期望的结果，这样效率会更高，避免返工。</li><li>秘诀四：设定开始时间、周期、最后期限是什么，DDL的重要性大家应该都清楚了，没有截止日期的任务几乎等同于不会去完成。</li></ol><h5 id="专注技巧"><a href="#专注技巧" class="headerlink" title="专注技巧"></a>专注技巧</h5><ol><li>关掉 QQ、微信、钉钉等即时通讯软件。也可以使用系统自带的勿扰模式，IM 软件对专注的打断是很要命的。</li><li>给水杯里倒满水，提前去上个厕所。确保接下来的时间不会因为身体需求被中断。</li><li>尽可能的隔离自己。例如使用降噪耳机、白噪声软件、专门找个安静的角落等等，避免走神。</li><li>无法集中精神时先休息一会。这个也是很重要的，毕竟人不是机器，总会有高效和低效的时候，不要强迫自己，给自己太大压力。</li></ol><p>作者对上面的步骤汇总整理了一幅流程图，感觉很好的表达了 GTD 的主要步骤，可以时不时的拿出来翻阅一下：</p><p><img src="https://learner.oss-cn-hangzhou.aliyuncs.com/img/20210516224159.jpeg" alt="20210516224159"></p><h2 id="精力管理"><a href="#精力管理" class="headerlink" title="精力管理"></a>精力管理</h2><p>这部分主要是讲了两块内容，如何解决拖延症和如何使用番茄工作法。</p><p>关于如何解决拖延症这里基本思路类似于养成一个好习惯，在后面详细展开一下，这里略过。</p><h4 id="番茄工作法"><a href="#番茄工作法" class="headerlink" title="番茄工作法"></a>番茄工作法</h4><p><img src="https://learner.oss-cn-hangzhou.aliyuncs.com/img/20210603233210.jpg" alt="img"></p><blockquote><p><strong>番茄工作法</strong>（英语：Pomodoro Technique）是一种**<a href="https://zh.wikipedia.org/wiki/%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86">时间管理</a>法**，在1980年代由<a href="https://zh.wikipedia.org/w/index.php?title=Francesco_Cirillo&action=edit&redlink=1">Francesco Cirillo</a>创立。</p></blockquote><p>番茄工作法是一个易上手难精通的方法，说起来其实很简单，</p><ol><li>设置一个待办任务</li><li>设置专注时间，通常是 25 分钟</li><li>持续专注工作，直到番茄结束</li><li>休息 5 分钟</li><li>进入下一个番茄</li><li>每 4 个番茄，进行一次长时间休息，15~30 分钟</li></ol><p>番茄工作法的原理是人的精力是会随着持续工作不断下降的，所以我们需要通过不断的短暂休息恢复部分精力，确保接下来能够高效工作，示意图如下：</p><p><img src="https://learner.oss-cn-hangzhou.aliyuncs.com/img/20210602220552.jpeg" alt="00058"></p><p>通常来说，这里最难得就是中间的 25 分钟专注工作，一般作为一个社畜，时刻要注意关注钉钉消息、被人当面找到咨询问题等等，很容易就会中断自己的番茄。如何才能最大限度的专注工作呢？</p><p>其实上面行动技巧里面已经基本都提到了，除了通过一些仪式或者建造更好更安静的工作环境以外，就是需要对 GTD 的不断实践，每次遇到中断事件的时候，仔细问一下自己，是否可以忙完手上现在的工作再去评估；最好就是直接先放入收集篮即可。</p><p>更具体的内容可以参考一下《番茄工作法图解》这本书。</p><h2 id="习惯养成"><a href="#习惯养成" class="headerlink" title="习惯养成"></a>习惯养成</h2><p>这部分内容主要是介绍如何养成一个好习惯。我们都知道习惯的力量是很强大的，可以这么说，我们日常生活中有很大一部分行为是完全由习惯控制的。例如你每天早上起来第一件事就是先掏出手机看一下时间，然后刷一会朋友圈，不完全清醒的情况下已经完成了刷牙和洗脸；即使已经换了工位，刚开始几天还是会经常走错，等等。</p><p>同时我们经常会在新的一年给自己立一些“flag”，例如最多的就是，每天坚持跑步、每天坚持读书、坚持早睡早起、学习英语等等。但结果我们也都知道了，大多数人办完健身卡就等同于已经健身完了，之后再也没见过教练。</p><p>这里作者给出的解决方案是这么几个原则：</p><ol><li>找到驱动力。首先你要明确自己为什么要培养这个习惯，只有足够强的自驱能力才能坚持的更久。</li><li>及时奖励自己。人都是喜欢做及时反馈的事情，每完成一个阶段就给自己一个奖励，会让你下阶段更加轻松。</li><li>找到志同道合的人一起培养习惯。找到趣味相投的人，大家相互督促，会比自己一个人坚持更加有效，毕竟人都是有惰性的。</li></ol><p>我再补充一下我自己在实际实践过程当中的一些经验：</p><ol><li>“破窗理论”： 连续坚持 60 天通常比坚持 30 天后中断 3 天再坚持 30 天要简单很多，原因就在于“破窗理论”。以一幢有少许破窗的建筑为例，如果那些窗没修理好，可能将会有破坏者破坏更多的窗户。类比到养成习惯上来，一旦你连续坚持的好习惯，中间有某几天因为一些因素中断了，那么接下来你能继续坚持的概率远小于未中断的时候。可以简单地理解为人们都有保持完美的心理，一旦发现这件事情不是那么完美了，就很容易破罐子破摔，觉得即使后面坚持了也没太大意义了。从这里我得到的启发是尽可能保持你的习惯连续性，真的有不可抗力因素导致中断，也要立马补上。</li><li>“崔西定律”： 任何工作的困难程度与其执行步骤数目的平方成正比。在养成习惯这件事情上，我们可以从这个定律吸收到的经验就是，将坏习惯的步骤尽可能加多，将好习惯的步骤尽可能减少。打个比方，如果你想要戒烟，那么可以把家里的烟统统交给你老婆保管，然后每次藏在不同的地方，甚至可以设置动态密码，这样每次你想要吸烟的时候就需要层层步骤才能最终实现，成本越大，你的动力也就消耗的越快，逐步就失去了想要吸烟的那种冲动；如果你想要培养跑步的习惯，可以提前把跑步鞋、健身的衣服、水等东西提前准备好，放在家门口鞋柜边上，每次回到家放下包就可以直接换衣服出发跑步，那么坚持下来的概率就会大很多，否则你可能就会因为要找鞋子、找水、换衣服等步骤消耗掉了你为数不多的健身冲动。</li><li>“猛火炖，慢火煮”：意思是说在培养习惯这方面，可能不太适合循序渐进，比如坚持早起这件事，坚持一周 8 点半早起，再提前到坚持一周 8 点早起，之后再提前到 7 点半早起，效果可能并不比直接 7 点半起床效果更好。猛火炖的意思就是下定决定要做这件事的话，要立马跟过去告别，做出改变， 比如第二天就开始 7 点半起床；慢火煮的意思就是不要退回原来的状态，想尽办法坚持下去，几天之后效果就会完全不同。如果真的因为早起白天十分没精神，坚持不要睡，晚上回家早点倒头大睡，第二天再 7 点半起床，连续几天之后你就会发现很轻松了。</li></ol><p>更具体的内容可以参考一下《游戏改变世界》这本书。</p><h2 id="如何让想法落地"><a href="#如何让想法落地" class="headerlink" title="如何让想法落地"></a>如何让想法落地</h2><p>这章主要是介绍如何将你的灵感和想法逐步落到实处，对我自己来说，收获最大的是其中提到的“六个高度”。</p><p><img src="https://learner.oss-cn-hangzhou.aliyuncs.com/img/20210602224423.jpeg" alt="00083"></p><blockquote><p>David Allen提出我们的工作和人生是可以划分成六个高度去进行检视和规划的。</p></blockquote><p>具体如下：</p><ol><li>原则：你首先必须要找个时间好好地思考一下自己的价值观、原则和目标，这是你工作的灵魂所在。书中老付的原则是：高效率，慢生活。感觉这个原则很棒，可以用来参考。只有提高效率，才能有更充分的时间去享受生活。</li><li>愿景：这里面包含3～5年的工作目标，可以是职位的，也可以是组织能力、协调能力等。这个阶段找到一个参照物是比较重要的，例如，你想要什么？哪些人已经做到了？他们是如何做到的？有了参照物会让你的目标更加清晰。</li><li>目标：目标是比愿景更细化的东西，通常在一年内就可以有一个阶段性的成果。类似于每年制定一个年度计划，需要有稍微明确一点的目标。</li><li>责任范围：工作上的角色，如销售、管理、产品开发等；生活中的角色，如家庭、个人财务、精神层面等。我们不只是有工作，更重要的是有家庭、有朋友、有日常生活等，这部分讲的是如何在这些角色之间做好平衡</li><li>任务：这包含了任务和项目。</li><li>行动：这是最为细枝末节的事件，我们要将它们全部放进行动清单，然后一一消灭。</li></ol><p>这一部分也可以参考 《ORK 工作法》，使用 OKR 来制定你的个人目标。</p><p>同时这里针对每一个阶段，也有不同的工具可以用来帮助我们梳理目标。</p><p>在梳理个人目标的时候，SMART 原则十分有用，通常是公司里用来制定 KPI 的时候需要用到，他代表的意思是 Specific—目标明确、Measurable—目标可衡量、Attainable—目标可实现、Relevant—目标与其他目标具有相关性、Time-based—目标必须要有截止时间。</p><p>明确自己的角色以及平衡各种角色的时候，九宫格就派上用场了，你制定的目标中，不仅要包含自己的工作计划，还需要考虑过程中其他角色的精力分配，例如如何维持人际关系、如何保持身体健康、如何提升财富水平等等。</p><p><img src="https://learner.oss-cn-hangzhou.aliyuncs.com/img/20210603222044.jpeg" alt="00081"></p><p>接下来的任务和项目维度，可以分别使用思维导图和甘特图来进行梳理。</p><p>思维导图是很适合用来理清楚事情脉的，相比起文字版的待办清单，人对图像的接受程度和记忆力明显更高，因为清单本身是一个列表形式，而导图可以直接看到全貌。同时，也有助于跟他人进行分享演示。这里导图中还有很多分支，例如鱼骨图、时间线等等，适用于更加特定的细分场景。</p><p><img src="https://learner.oss-cn-hangzhou.aliyuncs.com/img/20210603222307.jpeg"></p><p>甘特图是项目管理的利器，通常来说，项目管理管理的就是资源，包括时间、人力等，而甘特图可以很好地进行人力分配，看到全局进度，明确每个人的任务情况。可以很方便的进行周报汇总、风险预警等。</p><h2 id="个人实践"><a href="#个人实践" class="headerlink" title="个人实践"></a>个人实践</h2><p>至此，这篇文章的主要核心点基本已经梳理完毕，不管是从篇幅上来说，还是重要程度上来说，我觉得核心主要在于第二章 GTD 相关部分。</p><p>接下来，我简单分享一下我自己在时间管理方面所形成的小系统以及用到的一些工具。</p><h3 id="时间块记录"><a href="#时间块记录" class="headerlink" title="时间块记录"></a>时间块记录</h3><p>这部分内容其实在上面已经提到了，我目前用下来比较方便的软件分别是</p><ul><li>手机端的时间块</li><li>电脑端（Mac）的 Qbserve</li></ul><p>同时，记录任务完成情况的话，可以通过语雀做一个 Excel 模板，每天进行更新。不过这部分主要是用来明确你自己平时的工作效率是否高效，同时明确你自己的高效工作时间段，我个人觉得靠手工录入时间块或者记录完成情况的方式，几乎是不可持续的，毕竟人都是有惰性的，简单执行一两周达到目标即可。不过类似 Qbserve 这种，如果有类似安卓端的工具，可以直接跟电脑打通，自动记录全部的时间使用信息，还是蛮不错的。</p><h3 id="灵感捕捉"><a href="#灵感捕捉" class="headerlink" title="灵感捕捉"></a>灵感捕捉</h3><p>基于上面提到的灵感捕捉原则，在挑选这方面软件的时候，就必须要满足以下条件：</p><ol><li>跨平台支持优秀</li><li>手机端能够快速输入</li><li>最好可以识别自然语言</li></ol><p>我选择的软件分别是 Cubox 以及 滴答清单，他们各自有着不同的使用场景。</p><p>针对公众号或者 RSS 获取到的信息，如果想要临时记录下来后续抽时间处理，可以使用 Cubox，它最大的优点就是能够直接在微信公众号的浏览过程中通过发送到助手直接进行保存，而不用拷贝链接切换软件保存或者使用捷径保存，打断次数越少越好。</p><p>而滴答清单，不得不说真的是个良心神器，我已经是三四年的老用户了，它的优势包括：</p><ol><li>自然语言识别很强，例如输入明天去超市 xx，每个月写一次总结等都可以设置好对应的任务，十分方便</li><li>跨平台非常优秀，可以在手机端添加桌面小组件，几乎是秒级进入输入状态</li><li>支持智能清单，作用是可以自己使用一些条件进行汇总查询，例如哪些事情重要且紧急、重要不紧急等等，配合 GTD 食用感觉非常棒。</li><li>最重要的一点，绝大部分功能都是免费的，可以说是非常良心了。</li></ol><p><img src="https://learner.oss-cn-hangzhou.aliyuncs.com/img/20210522185811.png"></p><p>更详细的关于 PKM 中信息获取以及整理可以参考之前的一篇文章：  <a href="http://blog.samwei12.cn/2021/05/22/Thinking/%E5%85%B3%E4%BA%8EPKM%E6%94%B6%E9%9B%86%E4%B8%8E%E6%95%B4%E7%90%86%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%80%9D%E8%80%83%E5%92%8C%E5%AE%9E%E8%B7%B5/">万字长文—关于PKM收集与整理系统的思考和实践</a></p><h3 id="组织整理"><a href="#组织整理" class="headerlink" title="组织整理"></a>组织整理</h3><p>这里可以按照作者的方式，将待办事项分为项目清单、将来清单、行动清单。我个人在实际实践过程中，新补充了一些自行添加的清单：</p><img src="https://learner.oss-cn-hangzhou.aliyuncs.com/img/20210603230103.png" alt="image-20210603230103625" style="zoom:50%;" /><ol><li>任务清单：在使用项目清单和行动清单的过程中，我发现如果把任务拆解为细分的行动清单固然可以做到无脑执行下一步行动即可，但是在实际操作过程中，容易丢失上下文，因为不同的任务可能会并行开展，这时候就有可能产生上下文混淆。我个人还是把任务单独作为一个清单拎出来，把一些比较独立，可以直接进行的行动放到行动清单中。</li><li>阅读清单：单独针对阅读梳理了一个清单，定期进行阅读，实际并没有:)</li><li>闲暇清单：这个也是在实践的过程中，发现一个人一天能够保持高效的工作时间通常不超过 4 个小时，那么剩下的时间很多都在划水，这时候可以穿插做一些不是那么消耗精力的事情，例如，整理收集箱、设置行动的截止时间、设置行动的优先级等等。</li></ol><p>我的滴答清单使用完整流程大概是这样：</p><p><img src="https://learner.oss-cn-hangzhou.aliyuncs.com/img/20210603230920.png" alt="image-20210603230920482"></p><p>同时这里，配合项目清单和任务清单的拆解，还需要使用思维导图工具和甘特图工具，这里我选择使用的软件分别是 Xmind 和 Omniplan。XMind 是一款国产的跨平台思维导图软件，目前使用下来最符合我的需求，后面会单独写一篇测评；Omniplan就不说了，Omni 系列属于知名高效工作组件了，目前出的产品几乎各个精品，OmniFocus 也是一款非常棒的 GTD 软件，我之前也使用过一段时间，不过由于功能太强大也就是太复杂，最后还是转投滴答清单了。</p><h3 id="深思"><a href="#深思" class="headerlink" title="深思"></a>深思</h3><p>我目前深思的方式包括每日日记、每周计划及回顾、年度计划等，这里除了 Markdown 以外，强烈推荐 Textexpander 这款软件，这是一款快速输入文字的软件，内置了很多有用的函数，例如当前日期、时间戳，还可以进行不同 snippets 的组合，我几乎每天都在使用。</p><img src="https://learner.oss-cn-hangzhou.aliyuncs.com/img/20210603231546.png" alt="image-20210603231546719" style="zoom:50%;" /><p>这样每次当你输入 <code>;dd</code> 的时候，都会自动展开为今日日记，节约了大量的输入工作。类似的软件还有很多，例如Alfred 也支持快速输入文字，不过时间格式方面自由度太低，其他倒还不错。</p><h3 id="行动"><a href="#行动" class="headerlink" title="行动"></a>行动</h3><p>这里我建议还是入手一个降噪耳机，能够大幅度提升幸福感，避免外界嘈杂的声音干扰你。搭配白噪声软件效果更佳。</p><p>同时这里不得不再次提一下良心的滴答清单，不过支持番茄钟的功能，甚至还支持了白噪声。</p><img src="https://learner.oss-cn-hangzhou.aliyuncs.com/img/20210603232021.png" alt="image-20210603232021684" style="zoom:50%;" /><p>界面大概长这样，使用起来十分方便，而且还支持统计功能，可以自行设置每个番茄的时间，连续 4 个番茄之后的间隔休息时间等等，可以说是非常贴心了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>至此，关于我个人在阅读这本书的心得和笔记，包括我的一些实际实践都已经介绍完了，如果大家也对时间管理感兴趣，欢迎来一起留言讨论~</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;五一期间阅读完毕了《小强升职记》一书，感觉收获颇丰，对自己的时间管理进行了更加深入的思考和了解。本文就针对我在阅读过程中所记录的一些笔记以及思考实践进行一个回顾总结。&lt;/p&gt;
&lt;p&gt;这本书的主线是介绍主人公职场菜鸟小强在大牛老付的帮助下，一步步理清楚自己在时间管理方面所犯下的一些错误，并且进行改正完善，之后慢慢从菜鸟走向一名比较成熟合格的技术负责人的整个历程，按照这条成长路线来进行叙述的。可以看出作者在这方面的功底非常深厚，深入浅出的就把时间管理中常犯的一些错误和如何应对逐步的展开来讲述。&lt;/p&gt;</summary>
    
    
    
    <category term="Reading" scheme="http://blog.samwei12.cn/categories/Reading/"/>
    
    
    <category term="读后感" scheme="http://blog.samwei12.cn/tags/%E8%AF%BB%E5%90%8E%E6%84%9F/"/>
    
    <category term="时间管理" scheme="http://blog.samwei12.cn/tags/%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>万字长文---关于PKM收集与整理系统的思考和实践</title>
    <link href="http://blog.samwei12.cn/2021/05/22/Thinking/%E5%85%B3%E4%BA%8EPKM%E6%94%B6%E9%9B%86%E4%B8%8E%E6%95%B4%E7%90%86%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%80%9D%E8%80%83%E5%92%8C%E5%AE%9E%E8%B7%B5/"/>
    <id>http://blog.samwei12.cn/2021/05/22/Thinking/%E5%85%B3%E4%BA%8EPKM%E6%94%B6%E9%9B%86%E4%B8%8E%E6%95%B4%E7%90%86%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%80%9D%E8%80%83%E5%92%8C%E5%AE%9E%E8%B7%B5/</id>
    <published>2021-05-22T14:29:31.000Z</published>
    <updated>2024-07-31T18:16:36.789Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="http://blog.samwei12.cn/2021/05/22/Thinking/%E5%85%B3%E4%BA%8EPKM%E6%94%B6%E9%9B%86%E4%B8%8E%E6%95%B4%E7%90%86%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%80%9D%E8%80%83%E5%92%8C%E5%AE%9E%E8%B7%B5/">原文链接</a></p></blockquote><p>PKM闭环中有一个很重要的环节就是信息输入，包括各种信息来源，例如微信公众号、博客、知乎、RSS等等，因此也就诞生了一大堆稍后读软件，如何真正有效的获取输入而不是做一只仓鼠是需要思考的。最近看了《小强升职记》很有收获，里面提到最好在每个方面都有一个自己的小系统，“<strong>做事要靠系统而不是靠感觉</strong>”，因此这里简单记录下自己的思考和目前构建起来的信息收集整理系统。</p><span id="more"></span><h2 id="需求场景"><a href="#需求场景" class="headerlink" title="需求场景"></a>需求场景</h2><p>手机在浏览阅读一些比较有价值的文章的时候，无法立马吸收，例如读到一些专业的技术博客、长文等等，此时，就需要将这些内容收藏起来有时间的时候继续深入阅读。</p><h3 id="为什么手机不适合进行深度阅读？"><a href="#为什么手机不适合进行深度阅读？" class="headerlink" title="为什么手机不适合进行深度阅读？"></a>为什么手机不适合进行深度阅读？</h3><ol><li>干扰太多。比如阅读时候弹出微信消息、短信等等，此时跳到微信再回来已经过去了半个小时，更别提现在微信公众号已经占据我信息来源的50%以上，这种打断就显得尤为浪费时间。</li><li>没有大块时间。一般在排队、等车等情况下进行阅读，可能只能判断出这篇文章是否需要进一步学习。</li><li>不适合标注笔记。这个也很好理解，手机毕竟屏幕太小，但很多专业性很强的文章如果不配合笔记甚至实操，是根本无法吸收内化的。</li></ol><p>手机的使用场景决定了它本身只能进行一些文章价值的快速筛选，辨别出这篇文章是否需要进一步深入学习，仅此而已。</p><p>所以我给自己定的一个小目标就是每天的手机使用时间不要超过3小时，微信、知乎中发现的有价值的内容都第一时间收藏到稍后读中，电脑上统一进行整理，手机只作为一个收集器和过滤器，用于快速识别出哪些文章需要进一步研究。</p><h3 id="关于碎片化时间的思考"><a href="#关于碎片化时间的思考" class="headerlink" title="关于碎片化时间的思考"></a>关于碎片化时间的思考</h3><p>关于这点，收到了简悦作者的部分观点启发。</p><p>个人观点：不要有太多碎片化时间，利用碎片化阅读本身就是个伪命题，原因上面也有讲到。</p><p>很多人恨不得自己24小时都在进行阅读，可能是为了造成一种自己很努力错觉，也有可能是因为现在这个时代知识焦虑实在被贩卖的太严重，如果不让自己时刻在学习在阅读就会被淘汰？实际上这样做并不会对个人提升有太大帮助。很多人(包括我)都会利用走路、吃饭时间进行手机阅读，这种只能用来看看新闻，我理解是无法进行自我提升的。</p><p>那有些人说就是会有很多碎片化时间应该如何处理呢？比如通勤时间较长，或者一些工作性质导致会有很多碎片化时间。</p><p>我最近的感受下来，这种小块时间宁可放空，进行思考和回顾。拿我自己来说，之前每次上下班开车的时候总是喜欢听一点书、或者听一些专业相关的教程，例如喜马拉雅、极客时间、得到等，实际上听完一遍，根本没有吸收，最多只能做到，知道有这么本书，大概讲的是个什么东西，但具体到如何讲的一概不知。最近这段时间尝试放空自己，开车就好好开车，什么也不听，发现经常会有各种灵感从脑袋里面冒出来，比如对工作的回顾、对自己日常的思考等等（同时也会让我更加专注开车，更加安全）。大家也可以尝试一下，定期放空回顾自己说不定会让你走的更快更远，PS：这里也可以学习一下如何进行冥想，我自己也在尝试。</p><h2 id="工具挑选"><a href="#工具挑选" class="headerlink" title="工具挑选"></a>工具挑选</h2><h3 id="工具选择的原则"><a href="#工具选择的原则" class="headerlink" title="工具选择的原则"></a>工具选择的原则</h3><p>知道了需求背景，我们就开始真正开始进行软件挑选了，经过我这么多年的软件使用实践，我发现大多数时候其实我们并不知道自己需要什么软件，外加现在这个时代，开发一个软件成本实在有点低，一旦有个热点，同类型产品几乎是雨后春笋般冒出来（参考最近大火的Roam类双向链接笔记）。如果不建立一个自己的筛选甄别系统，很容易就被各种工具迷花了眼。</p><p>这里我简单列举一下我自己这些年总结的一些选择软件的原则，其中很多在我的<a href="http://blog.samwei12.cn/2020/05/02/Thinking/%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AAPKM%E7%B3%BB%E7%BB%9F/">旧文</a>中都有提到，仅供大家参考：</p><ol><li>尽可能不要全部依赖免费工具。 </li><li>格式越简单越好。深入表述一点就是软件的 Lock-in 成本越低越好，目前这个时代，软件更迭速度实在快的惊人，大家可以仔细想一下有哪些软件使用时间超过了5年？或者说3年？所以构建自己的个人系统时，尽可能不要强依赖软件，做到快速迁入迁出最好了。这里不得不提到国产很多软件，真的是没有什么节操，导入功能支持的完美的一笔，导出功能就是个渣渣，就差明说我要抢你们的用户，但你们谁也抢不走我的用户。开发者真的是多没自信才能干出这种事情？</li><li><del>除非是网络实在不可用，否则尽可能选用国外产品</del>。 这一点原文已经提到了，不过说实话，这两年国内产品质量越来越高了，很多软件在使用体验上已经超越了国外软件。如果遇到比较良心比较有节操的开发者，这条原则可以作废了。</li><li>你一定要明确你的需求。这点上面有提到过，如果你不明白你真的需要什么，那也一定要清楚自己不需要什么。只有这样，你才能够从不停地切换软件中挣脱出来，避免成功“工具人”（字面意思，被工具奴役）。</li></ol><h3 id="收集类软件需求分析"><a href="#收集类软件需求分析" class="headerlink" title="收集类软件需求分析"></a>收集类软件需求分析</h3><p>对于我来说稍后读软件方面个人的诉求点包括：</p><ol><li>手机端随时能够快速保存。尤其是微信公众号文章，很多稍后读软件在微信公众号文章上面体验都很差</li><li>能够跨平台使用。多平台的支持很重要，我平时使用网页版很少，喜欢使用客户端，一般是iOS跟Mac使用</li><li>能够持久化保存，网站无法访问也能正常使用。这点相比大家也都明白，网站不能打开的因素实在是太多了</li><li>能够进行标注，并且能导出标注并进行检索关联。阅读过程中对于精华部分进行标注是一个很必要的功能，且需要能够对其进行分类打标，使其成为素材笔记(卡片盒笔记中的术语，字面意思)，并且能够跟现有的知识进行结合。你学到的每个知识点，只有跟现有的知识点进行关联，才有可能真的内化吸收变为你自己的知识，一个个的孤岛知识点是没有任何意义的。</li></ol><h3 id="我用过的那些收集类产品测评"><a href="#我用过的那些收集类产品测评" class="headerlink" title="我用过的那些收集类产品测评"></a>我用过的那些收集类产品测评</h3><p>搞明白为什么需要一个信息收集系统跟它需要具备哪些能力之后，我们就可以开始进行一些工具的筛选和鉴别了。目前笔记软件和稍后读软件实在是太多了，很容易就挑花了眼，我这里只简单介绍一下我自己深度使用过的一些软件和工具，当然我自己在使用过程中也并不是一下子就想清楚需要哪些能力再开始进行挑选的，也是逐步使用过程中发现哪些适合自己哪些不适合自己，因此现在把使用过程中的一些经验简单说一下，希望能减少大家的时间成本，同时由于每个人情况不同，需求也不一样，这方面主观因素比较强，最好是梳理出你自己的需求点，建立最适合你的小系统。</p><p>这里我把目前用过的工具简单分为两类，一类是笔记类，一类是收藏类，他们的定位有所区别。笔记类，偏向剪藏、管理、检索、写作；收集类，偏向快速收集、标注、阅读。</p><h4 id="笔记类"><a href="#笔记类" class="headerlink" title="笔记类"></a>笔记类</h4><h5 id="印象笔记"><a href="#印象笔记" class="headerlink" title="印象笔记"></a>印象笔记</h5><p>老牌仓鼠专用笔记，只收藏不老牌仓鼠专用笔记，只收藏不处理。我从11年左右就开始在用印象笔记，当时还没有国内版，同步速度比较一般，不过真的是稳，最强大的就是剪藏功能，能够完整保存网页内容，选区可以调整，不过一般来说自动识别完全够用；其次是搜索功能，甚至能利用OCR，搜索图片内容。</p><p>优点：</p><ul><li>剪藏功能简直逆天，仓鼠党必备</li><li>搜索功能很强大</li><li>稳定性很强</li></ul><p>缺点：</p><ul><li>大公司通病，迭代速度过于缓慢，一个Markdown支持好几年都没上，很长一段时间只能用 马克飞象 等替代；最近一两年有所好转，从推出超级笔记开始，功能迭代速度明显变快，前几天甚至出了双向链接，不过有点为时已晚的感觉，毕竟现在笔记市场已经不是几年前了</li><li>在现在双链笔记横行的时代，印象笔记之前的笔记模式已经过于落伍，缺失了收藏到输出中间最重要的一个组织整理功能，也就无法使知识内化，逐步沦为一个收藏仓库，永远也不会打开。当然不排除有些人用印象笔记也用的很棒，但那需要个人比较强的组织管理知识的能力，一般人达不到</li><li>剪藏过慢，这可能跟实现方式有关，印象笔记需要等完整网页内容转换保存下来之后再提示成功，一般的微信文章大约需要3-5秒，有点接受不了。完全可以改为后台通过链接下载创建笔记，用户只需要粘贴链接即可离开，不需要在界面停留等待。</li><li><strong>微信公众号支持不佳</strong>，现在很多软件都是通过提供服务号来实现微信文章收藏，我只想问问他们实际使用过这个功能吗？槽点实在太多，实际收藏场景通常在用户浏览公众号文章列表时候发现这篇文章不错，想要收藏一下，此时需要：右上角拷贝链接，退出公众号，打开服务号，粘贴链接，返回公众号继续浏览下一篇文章。不得不说这实在是个迷幻操作，这中间的打断次数多的我都不想继续使用了。当然有一些办法可以简单规避这个问题，例如使用iOS捷径，但实际体验过之后槽点也真的够多。首先，使用捷径创建笔记时候需要进行授权，这个没啥可说的，但骚就骚在这里有个严重bug，即使授权完成，在桌面的快捷方式中点击收藏，一样会频繁提示授权失败，最终解决方案，<strong>重启手机</strong>；其次，官方那个捷径有点蛋疼，每次收藏完笔记，会自动打开该链接，也就是跳到印象笔记手机端该笔记中，这是为了手机端打开次数和时长KPI？解决方案，删除捷径中这些多余步骤；最后就是收藏速度了，经常有的文章我收藏一下，要等待大概10-15秒，不确定是不是文章里面有大量图片之类的，可以参考上一点，这里还有个恶心的点就是捷径本身都是同步的，也就是说这15秒时间内，你只能在桌面傻等着，一旦有了其他点击事件，就会取消掉本次操作，每天浪费大量时间。</li><li>公司网络屏蔽，无法使用，这个是我个人原因</li></ul><h5 id="为知笔记"><a href="#为知笔记" class="headerlink" title="为知笔记"></a>为知笔记</h5><p>大概在15、16年左右，由于实在受不了印象笔记对于Markdown的支持力度，同时不愿意进行太多付费，转而开始使用为知笔记，但不得不说，使用体验比起印象笔记简直是天上地下，服务响应不及时、开发进度缓慢、客户端经常卡死等问题一点点再消耗我的耐心，终于还是舍弃了它。</p><p>编写本文的时候我还专门去下载了为知笔记，发现网上能够搜索到的资料基本都是16、17年的了，为知笔记的官网中，Linux跟Mac客户端在20年之后更是完全没有更新过，不得不说还是挺可惜的， 其实它本来很有机会超越印象笔记的。</p><h5 id="Onenote"><a href="#Onenote" class="headerlink" title="Onenote"></a>Onenote</h5><p>微软出品，必属精品。大部分情况下这句话没啥毛病，很多人对Onenote十分狂热，我简单试用过一段时间，实在有点不太习惯，放弃了。</p><p>优点：</p><ul><li>继承了微软产品的一贯作风，操作上手门槛极低，任何灵感都可以随时记录</li></ul><p>缺点：</p><ul><li>同步极不稳定，懂得都懂。貌似现在好一些了，近期没有使用过。</li><li>排版实在有点迷，习惯了 Markdown 的简洁，我有点受不了，更不提对于程序员来说，没有代码高亮支持极其难受</li></ul><h5 id="有道云笔记"><a href="#有道云笔记" class="headerlink" title="有道云笔记"></a>有道云笔记</h5><p>待补充，这个软件已经好几年没用过了，最新情况已经不太清楚</p><h5 id="Bear"><a href="#Bear" class="headerlink" title="Bear"></a>Bear</h5><p>在iOS跟Mac上发家的一款新兴笔记软件，最近也开启了双链功能支持，我简单使用过。现在已经改名叫做熊掌记了，国内化做的不错。</p><p>优点：</p><ul><li>界面简洁易用</li><li>支持文档互链</li><li>对Markdown支持的较好，可以当做一个轻度任务管理软件使用，配合子弹笔记可以玩出花</li></ul><p>缺点：</p><ul><li>只支持苹果系</li><li>不支持买断，订阅制，这点其实不完全算是缺点，个人不是很喜欢吧</li><li>记录个人灵感还是蛮舒服的，但是无法当做文章收集软件来使用</li></ul><h5 id="VNote"><a href="#VNote" class="headerlink" title="VNote"></a>VNote</h5><p>不想补充了</p><h4 id="收集类"><a href="#收集类" class="headerlink" title="收集类"></a>收集类</h4><p>对于大多数场景，这类软件才是真正能够用于收藏的，笔记类软件能够当收藏使用说实话是被印象笔记一手带起来的风气。</p><h5 id="Instapaper"><a href="#Instapaper" class="headerlink" title="Instapaper"></a>Instapaper</h5><p>国外老牌稍后读软件，与Pocket齐名，以排版优雅、界面简洁著称</p><p>优点：</p><ul><li>阅读格式精心调校过，比较适合长时间阅读，但说实话手机上我不太想深度阅读</li><li>阅读界面清爽，没有广告</li><li>免费版就可以永久保存</li></ul><p>缺点：</p><ul><li>不支持标签</li><li>微信公众号的文章支持不友好，无法直接微信内收藏， 可以通过iOS捷径等手段使用，不过体感比印象笔记还是好多了。不过有个很要命的问题，微信公众号的文章，解析时候经常会提示未授权，PC 端无法查看图片，只能点击打开原文</li></ul><h5 id="Pocket"><a href="#Pocket" class="headerlink" title="Pocket"></a>Pocket</h5><p>同上，国外老牌稍后读软件，感觉相比Instapaper对国内的优化更好一点，但社交元素有点多，我只想安安静静的阅读个文章，不想有这么多干扰</p><p>优点：</p><ul><li>国内优化相对好一点</li><li>支持微信文章保存</li></ul><p>缺点：</p><ul><li>免费版不支持永久保存</li><li>干扰元素太多，很多用户比较排斥</li></ul><h5 id="Pinboard"><a href="#Pinboard" class="headerlink" title="Pinboard"></a>Pinboard</h5><p>国外的一款比较有名的网页收集类软件，收费理念比较特殊，随着使用人数增加，费用逐步提高，我知道的比较早，但购买的比较晚，当时购买的时候已经到了一年40刀，说实话我觉得有点太贵了。好在支持退款，用了几天之后毫不犹豫的退款了，不是很适合我。</p><p>优点</p><ul><li>可以持久化保存网页快照</li></ul><p>缺点</p><ul><li>界面比较丑，阅读体验不是很好</li><li>老外的软件，更新迭代很慢，英文不好可能有点吃力</li><li>稍微有点贵， 40 刀一年</li></ul><h5 id="Pinbox"><a href="#Pinbox" class="headerlink" title="Pinbox"></a>Pinbox</h5><p>国产类似 Pinboard 的软件，做的很蛮不错，且针对国人习惯加了很多新功能，例如支持直接保存文字、图片等。价格也比较公道，但移动端体验实在有点糟糕。产品定位是一个纯网页保存类软件，基本类似于浏览器的收藏夹， 不过支持标签、检索等，对稍后读的支持力度其实一般，或者说没有，不支持阅读模式、标注等。</p><p>优点：</p><ul><li>界面好看</li><li>同步速度很快，比较稳定</li><li>价格实惠，会员一年 69￥，免费版支持300个书签</li><li>支持图片和文字收藏</li><li>支持导出html，还算方便</li></ul><p>缺点：</p><ul><li>移动端版本可用性太差</li><li>排序功能较差</li><li>不支持网页快照</li><li>无法跟微信公众号打通，必须要复制链接，然后切换到 Pinbox 中新增</li><li>不支持阅读模式跟标注，基本上无法作为深入阅读软件使用</li></ul><h5 id="Raindrop-io"><a href="#Raindrop-io" class="headerlink" title="Raindrop.io"></a>Raindrop.io</h5><p>国外一款书签收集软件，之前有段时间蛮喜欢的，界面比较清爽，后来因为网络因素改为使用收趣云了。</p><p>优点</p><ul><li>免费版可以无限制创建文件夹和收藏</li></ul><p>缺点</p><ul><li>国内同步速度太慢，偶尔网络会抽风，经常想收藏一下文章，5秒钟过去了，还在转圈</li></ul><h5 id="Cubox"><a href="#Cubox" class="headerlink" title="Cubox"></a>Cubox</h5><p>国产软件，基于 Linnk 重构升级而来，可以说是目前用下来最符合快速收藏文章诉求的软件了。跟作者有过简短的几次邮件对话，交流下来比较省心，回复很快，也很能接受用户意见，促使我毫不犹豫的购买会员。 会员价格一年78￥，可以说很良心了。</p><p>优点：</p><ul><li>免费版即可文章模式支持永久保存，支持200个收藏。</li><li>网络同步速度贼快，国产软件必备技能</li><li>支持的导入方式很多，国产软件必备技能</li><li>导出很方便，对标Instapaper、Pocket，说明产品设计的比较合理，且有一定信心，比那些生怕用户跑了的产品好多了(对，说的就是你，收趣)。毕竟留住用户靠的不是想办法把转出门槛提高，而是产品质量</li><li>可以直接在微信中分享到指定账号进行收藏，不需要切换软件或者打断公众号浏览</li></ul><p>缺点：</p><ul><li>标注功能还比较弱，免费版支持3个标注，但导出很差</li><li>不支持快速收集想法，只支持网页收藏</li></ul><h5 id="滴答清单"><a href="#滴答清单" class="headerlink" title="滴答清单"></a>滴答清单</h5><p>国产软件里面很优秀的GTD工具，甚至个人觉得没有之一。用来收集灵感十分方便，配合桌面小插件，基本可以做到手机上3s内记录想法。同时各平台支持都很到位， 价格定位也很良心，平时轻度使用完全可以不购买会员。</p><ul><li><img src="https://learner.oss-cn-hangzhou.aliyuncs.com/img/20210522185811.png" alt="20210522185811"></li></ul><p>以下是会员专有功能</p><ul><li>支持摘要汇总，用来查看本周完成了哪些事项，写周报时候很方便</li><li>支持日历视图，可以在日历中安排每天的工作，查看本周哪些天会比较忙等</li><li>支持智能清单，需要会员，可以自定义一些例如重要且紧急、重要不紧急等清单，定期处理</li></ul><p>优点：</p><ul><li>支持自然语言识别，可以快速输入例如明天上午8点做某事的事项</li><li>列表和事项没有限制，免费版完全足够日常使用</li><li>内置习惯养成，虽然功能比较弱，聊胜于无，适合轻度用户</li><li>支持番茄钟，配合番茄工作法还是蛮有用的</li></ul><p>缺点：</p><ul><li>如果用来当做稍后读软件的链接收藏，稍微有点不太合适，链接不会去重，但这个说实话不是它的问题，毕竟软件定位也不是这个</li><li>苹果用户需要注意下，这里有个坑就是苹果本身交易抽成30%，也就是说你在Mac和iOS上面购买会比原价贵30%，官网直接购买会员只有 139￥可以说非常良心了；直接在iOS上面购买你会发现是 168￥，而且还是到期自动订阅！！！，我之前就没注意被坑了两年。</li><li>没了，在我心里已经是一款十分完美的GTD软件了。</li></ul><h5 id="简悦"><a href="#简悦" class="headerlink" title="简悦"></a>简悦</h5><p>起先是靠做网页上面的阅读模式起家，支持油猴插件，作者对于深度阅读有比较深入的思考，有过对话，对我挺有启发的。最近2.0版本之后，迭代速度飞速提高，更是紧跟潮流，在双链笔记结合上花了大量心思，包括各种标注导出、文章导出、稍后读上都较之前版本有很大提升，重点是，大版本买断只需要18￥，真的非常划算了，建议大家入手一个。</p><p>优点：</p><ul><li>阅读模式很棒，支持超多网站，最重要的是可以自己进行圈选和隐藏</li><li>标注功能非常强大，可以说是我目前用过的最强大的了，没有之一，包括高亮、备注、打标签等，而且支持各种导出</li><li>用户隐私方面做得很好，通过各种同步盘本地文件等形式保存信息，简悦自身并不保存相关信息</li><li>平台支持和导出功能可以说是非常强了，支持超多网盘导出、超多格式导出(md、pdf、epub等等)</li><li>新版本的稍后读功能很强大，这跟作者的理念是分不开的，基本上不会变成一个仓库，而是各种鼓励你进行阅读。</li></ul><p>缺点：</p><ul><li>功能实在有点太庞杂臃肿，我身为一个程序员，而且是很喜欢研究各种软件的，说实话尝试新软件能力还算比较强了，但是实际使用下来，各种冗长的配置(真的不止几十项)，配合上部分含糊不清的文档，真的有点难以上手，我前后大概花了至少一个下午左右的时间，才算勉强会使用了，使用门槛可以说非常高了(基本的阅读模式不包含在内，上手还是比较方便的)，后面有机会单独写一篇我自己的简悦的使用心得。</li><li>对用户动手能力要求很高，里面会员支持的各种功能，基本上没有编程基础或者很强动手能力基本可以说是没啥卵用。比如说各种token申请、API使用、自定义模板等等。</li><li>移动端支持很差，iOS上很难用， 可能也跟iOS本身的封闭有关系，需要使用很多trick手段。跟作者沟通下来之后表示并不是想要做一个快速收藏然后当做仓库的软件，就是想要提高使用门槛，鼓励用户真正的自己进行深度阅读。这个我可以理解，但说实话，这样逼迫我不得不再配合一个其他收藏软件一起使用了，单独使用简悦，全平台打通能力真的不行。</li></ul><h5 id="收趣云"><a href="#收趣云" class="headerlink" title="收趣云"></a><del>收趣云</del></h5><p>国产稍后读软件，大概16年左右还是火了一阵子的，毕竟国内软件大多针对国人使用习惯做过优化，再加上网络同步速度远快于国外软件。但缺点也很明显，一般Lock-in都比较高，想办法让你从其他各种软件导入进来，导入方式支持的很到位；但想要导出？没门，各种加门槛，要么要求付费，要么干脆不支持。后来由于找不到太好的赢利点，且会员收费策略做的不好，现在已经很少有人用了。</p><p>优点：</p><ul><li>国内网站，速度较快</li><li>对国内微信公众号等支持较好 ，可以跟微信打通，直接在微信发送到指定账号即可收藏，很方便</li></ul><p>缺点：</p><ul><li>广告太多，还添加了大量社交元素</li><li>不支持自由导出，需要会员付费</li><li>已经很久没维护了</li></ul><h5 id="Linnk"><a href="#Linnk" class="headerlink" title="Linnk"></a><del>Linnk</del></h5><p>已经升级成为Cubox，不再赘述。</p><h2 id="个人实践"><a href="#个人实践" class="headerlink" title="个人实践"></a>个人实践</h2><p>经过以上各个软件的简要分析，相信大家也看出来我的一些偏向了。目前个人的PKM流程大概如下，算是个人PKM2.0版本(<a href="http://blog.samwei12.cn/2020/05/02/Thinking/%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AAPKM%E7%B3%BB%E7%BB%9F/">PKM1.0版本</a>，有关2.0版本输出部分后面有机会再介绍一下)：</p><ul><li><img src="https://learner.oss-cn-hangzhou.aliyuncs.com/img/20210522210816.jpg" alt="20210522210816"></li></ul><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><p>如果是外部输入，例如通过微信公众号、知乎等发现的一些有价值的文章，快速通过 Cubox 保存，不要在手机上花费太多时间。</p><p>如果是日常的一些灵感和任务相关，随手记在滴答清单的收集箱中。</p><h3 id="组织整理"><a href="#组织整理" class="headerlink" title="组织整理"></a>组织整理</h3><p>单纯的收集是没有意义的，不能满足于当一只仓鼠，在整个知识内化过程中，有一个很重要的步骤就是组织整理，这个跟GTD的理念也是相同的。我会设定一个闹钟，例如每天晚上或者每周末抽出一定的时间来清空收集箱。</p><p>对于Cubox中收藏的文章，花费1-2分钟快速明确是否跟当下的关注点和Areas重叠(这里涉及到PARA工作法，有机会再单独整理一篇），如果是需要近期关注的，那么进入简悦稍后读或者直接开始进行阅读，完成阅读后，把笔记备注和标注导出为素材笔记(卡片盒笔记中的概念，也可以理解为PARA工作法中的Resources)，存入Logseq中</p><p>对于滴答清单中的待办项，根据四象限法则进行排序整理，如果不是当前需要立马完成的事情，纳入到将来清单中， 定期回顾即可(这里可以参考小强升职记中的概念)。</p><p>在这个环节中，双向链接笔记是一个很重要的工具，我对它的定位是一个信息输入输出的枢纽。所有的灵感、外部输入都在简单筛选之后进入到素材笔记中进行打标签、分类、链接，同时需要输出某个特定主题的时候，可以通过双向链接快速查找到相关的笔记内容，整理归纳到博客或者其他外部输出中。</p><p>最近这一两年，双向链接笔记已经火的不行了，但目前真正国内稳定可用的软件屈指可数，目前我个人在使用的是Logseq这款，关于双向链接笔记的使用选择方面，完全可以单独再整理一篇了，先挖坑，后面一定补上 :)</p><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p>将信息快速内化为知识的一个有效手段就是传授给他人，这其中输出博客是一个很好的方案。现在搭建维护个人博客的成本极低，同时又有很多类似于飞书、语雀这样的平台用来进行输出，唯一限制你的可能就只有你的懒惰了(说的就是我自己)。</p><p>我目前采用的方案是Hexo，这方面可以参考 <a href="http://blog.samwei12.cn/2015/09/01/Utilities/Writing/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-Hexo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/?highlight=%E5%8D%9A%E5%AE%A2">如何使用 Hexo 搭建个人博客</a> ，这里不再赘述，值得一提的一款软件是MWeb，这是一款博客写作发布软件，目前支持很多平台，包括语雀、少数派、Wordpress 等等，值得一提的是，它还支持使用 Metablog API，这样就可以同时在多个博客平台进行发布。</p><p>关于我个人的PKM实践，大体方案就介绍到这里，希望对大家有所帮助，关于PKM的更多信息可以参考我的<a href="http://blog.samwei12.cn/2020/05/02/Thinking/%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AAPKM%E7%B3%BB%E7%BB%9F/">旧文</a>，虽然很多工具软件已经过时或者需要更新了，但整体的思路是没有大变的。这里的一个很重要的原则就是不要太过热衷于折腾工具，都是小术而已，只有真正了解了道，才能做到各种工具都能随心所欲的驾驭，最终的目的是为了学习知识，而不是学习工具。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.samwei12.cn/2021/05/22/Thinking/%E5%85%B3%E4%BA%8EPKM%E6%94%B6%E9%9B%86%E4%B8%8E%E6%95%B4%E7%90%86%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%80%9D%E8%80%83%E5%92%8C%E5%AE%9E%E8%B7%B5/&quot;&gt;原文链接&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;PKM闭环中有一个很重要的环节就是信息输入，包括各种信息来源，例如微信公众号、博客、知乎、RSS等等，因此也就诞生了一大堆稍后读软件，如何真正有效的获取输入而不是做一只仓鼠是需要思考的。最近看了《小强升职记》很有收获，里面提到最好在每个方面都有一个自己的小系统，“&lt;strong&gt;做事要靠系统而不是靠感觉&lt;/strong&gt;”，因此这里简单记录下自己的思考和目前构建起来的信息收集整理系统。&lt;/p&gt;</summary>
    
    
    
    <category term="Thinking" scheme="http://blog.samwei12.cn/categories/Thinking/"/>
    
    
    <category term="PKM" scheme="http://blog.samwei12.cn/tags/PKM/"/>
    
    <category term="稍后读" scheme="http://blog.samwei12.cn/tags/%E7%A8%8D%E5%90%8E%E8%AF%BB/"/>
    
    <category term="测评" scheme="http://blog.samwei12.cn/tags/%E6%B5%8B%E8%AF%84/"/>
    
    <category term="思考成长" scheme="http://blog.samwei12.cn/tags/%E6%80%9D%E8%80%83%E6%88%90%E9%95%BF/"/>
    
  </entry>
  
  <entry>
    <title>使用Logseq构建GTD系统</title>
    <link href="http://blog.samwei12.cn/2021/05/08/Utilities/%E4%BD%BF%E7%94%A8Logseq%E6%9E%84%E5%BB%BAGTD%E7%B3%BB%E7%BB%9F/"/>
    <id>http://blog.samwei12.cn/2021/05/08/Utilities/%E4%BD%BF%E7%94%A8Logseq%E6%9E%84%E5%BB%BAGTD%E7%B3%BB%E7%BB%9F/</id>
    <published>2021-05-08T07:07:34.000Z</published>
    <updated>2024-07-31T18:16:36.792Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>2021-05-08： 1.0版本初步完成，待完善已完成任务回顾<br>2021-05-10： 1.1版本完成，修改不重要不紧急为将来清单，且新增每周回顾</p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近在阅读《小强升职记》，感觉里面讲到的时间管理工具和方法十分有用，自己之前虽然也了解一些工具，例如四象限原则、两分钟方法等，但看完这本书之后感觉之前的理解还是太肤浅了。是时候升级一下自己的时间管理系统了。</p><span id="more"></span><p>在此之前我的工具大致包括： 稍后读软件、GTD工具（滴答清单）、写作工具（一般是VSCode+Hexo）。最近半年沉迷于使用双链笔记软件，目前在用的是 Logseq，后面专门展开介绍一下。目前在尝试将GTD工具、笔记都整合到 Logseq 里面，主要是受了这篇文章的启发 <a href="https://www.bmpi.dev/self/okr-gtd-note-logseq/">OKR + GTD + Note &#x3D;&gt; Logseq</a>，下面就详细介绍一下我的实践过程。</p><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><h3 id="Datalog"><a href="#Datalog" class="headerlink" title="Datalog"></a>Datalog</h3><p>首先，需要简单学习一下Datalog语法。Logseq是基于Clojure开发的，它的底层可以简单地理解为是类似于数据库的结构，因此可以天然的支持各种查询，这也是我们能够利用它来实现 GTD 管理的前提。因此这里如果需要掌握如何使用 Logseq 来进行查询的话，最好先学习一下如何使用 Datalog。可以参考 <a href="https://logseq.github.io/#/page/advanced%20queries">官方的查询教程</a> 以及这篇 <a href="http://www.learndatalogtoday.org/">Learn Datalog Today</a>，粗略扫一遍，能够看懂大概意思就可以了。</p><h3 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h3><p>其次，Logseq本身是列表大纲形式，无法直接支持四象限这种样式，因此需要一些 CSS功底，这里我是直接参考了 <a href="https://www.bmpi.dev/self/okr-gtd-note-logseq/">OKR + GTD + Note &#x3D;&gt; Logseq</a> 里面的样式，原始版本在 <a href="https://discuss.logseq.com/t/css-template-eisenhower-matrix/526">[css+template] eisenhower matrix</a>，可以简单看下。</p><h2 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h2><h3 id="块属性"><a href="#块属性" class="headerlink" title="块属性"></a>块属性</h3><p>《小强升职记》里面提到日常待办事项是分为项目、任务、行动三种的，只有行动才是可以立马去执行的，项目和任务都需要进行分解，拆成行动。</p><p>结合Logseq，我目前考虑使用属性来解决，也可以考虑使用标签，不过我认为会对内容有一定的污染，各有利弊吧。</p><p>针对一个新的行动或者任务，添加属性type字段，然后根据具体的类型添加行动、任务、项目字段。</p><p>样例：<img src="https://learner.oss-cn-hangzhou.aliyuncs.com/img/20210508175442.png" alt="20210508175442"></p><h3 id="四象限查询条件"><a href="#四象限查询条件" class="headerlink" title="四象限查询条件"></a>四象限查询条件</h3><p>注意：<strong>所有的待办都必须要有明确的优先级和截止日期</strong>，这么做有几个原因：<br>    1. 要求自己对每个待办都设置明确的时间点，避免添加到收集箱中一直不处理<br>    2. 添加了优先级之后才好进行四象限统计<br>    3. 目前还没有找到Logseq的query条件中如何同时查找DDL在限定时间内以及无DDL限制的任务，只能查找其中一种case，这个后续解决</p><p>实际使用过程中，可以把一下的查询条件汇总到一个模板中，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">## #.v-eisenhower-matrix （用于CSS选择器，最好不要改）</span><br><span class="line">:PROPERTIES:</span><br><span class="line">:template: 四象限</span><br><span class="line">:END:</span><br><span class="line">#### [[重要且紧急]]</span><br><span class="line">##### </span><br><span class="line">#+BEGIN_QUERY</span><br><span class="line">...</span><br><span class="line">#+END_QUERY</span><br><span class="line">#### [[重要不紧急]]</span><br><span class="line">#### [[紧急不重要]]</span><br><span class="line">#### [[不重要不紧急]]</span><br></pre></td></tr></table></figure><p>具体查询语句如下：可以根据自己的实际使用需求将属性限制移除或者修改时间限制，代码中均已经添加注释。</p><blockquote><p>2021-05-10 补充： 将设置为Later的事项移动到第四象限，这样就可以定期回顾；同时新增一个每周回顾的query语句，由于目前Logseq还不支持查询当前时间戳，因此用了个笨办法，每次查询的时候手动输入当前时间戳ms进行查询。</p></blockquote><h4 id="重要且紧急-避免太多进入该象限"><a href="#重要且紧急-避免太多进入该象限" class="headerlink" title="[[重要且紧急]] &#x3D;&#x3D;(避免太多进入该象限)&#x3D;&#x3D;"></a>[[重要且紧急]] &#x3D;&#x3D;(避免太多进入该象限)&#x3D;&#x3D;</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#+BEGIN_QUERY</span><br><span class="line">&#123;:query [:find (pull ?b [*])</span><br><span class="line">            :in $ ?end</span><br><span class="line">            :where</span><br><span class="line">            [?b :block/marker ?marker]</span><br><span class="line">            [?b :block/priority &quot;A&quot;] ;; 优先级在A的才认为是重要</span><br><span class="line">            [?b :block/properties ?p]</span><br><span class="line">            [(get ?p &quot;type&quot;) ?t]</span><br><span class="line">            [(contains? #&#123;&quot;任务&quot; &quot;行动&quot; &quot;项目&quot;&#125; ?t)] ;; 属性中type字段包含这三种</span><br><span class="line">            [(contains? #&#123;&quot;TODO&quot; &quot;DOING&quot; &quot;NOW&quot;&#125; ?marker)] ;; 不包含已完成任务，不包含LATER</span><br><span class="line">            (or</span><br><span class="line">            [?b :block/scheduled ?d]</span><br><span class="line">            [?b :block/deadline ?d])</span><br><span class="line">            [(&lt;= ?d ?end)]</span><br><span class="line">            ]</span><br><span class="line">    :inputs [:5d-after] ;; 时间跨度，5天内的算作紧急</span><br><span class="line">    &#125;</span><br><span class="line">#+END_QUERY</span><br></pre></td></tr></table></figure><h4 id="重要不紧急-优先完成此象限"><a href="#重要不紧急-优先完成此象限" class="headerlink" title="[[重要不紧急]] &#x3D;&#x3D;(优先完成此象限)&#x3D;&#x3D;"></a>[[重要不紧急]] &#x3D;&#x3D;(优先完成此象限)&#x3D;&#x3D;</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#+BEGIN_QUERY</span><br><span class="line">&#123;    :query [:find (pull ?b [*])</span><br><span class="line">            :in $ ?end</span><br><span class="line">            :where</span><br><span class="line">            [?b :block/marker ?marker]</span><br><span class="line">            [?b :block/priority &quot;A&quot;] ;; 优先级在A的才认为是重要</span><br><span class="line">            [?b :block/properties ?p]</span><br><span class="line">            [(get ?p &quot;type&quot;) ?t]</span><br><span class="line">            [(contains? #&#123;&quot;任务&quot; &quot;行动&quot; &quot;项目&quot;&#125; ?t)] ;; 属性中type字段包含这三种</span><br><span class="line">            [(contains? #&#123;&quot;TODO&quot; &quot;DOING&quot; &quot;NOW&quot;&#125; ?marker)] ;; 不包含已完成任务，不包含LATER</span><br><span class="line">            (or</span><br><span class="line">            [?b :block/scheduled ?d]</span><br><span class="line">            [?b :block/deadline ?d])</span><br><span class="line">            [(&gt; ?d ?end)]  ;; DDL在5天以上</span><br><span class="line">    ]</span><br><span class="line">    :inputs [:5d-after] ;; 时间跨度，5天内的算作紧急</span><br><span class="line">    &#125;</span><br><span class="line">#+END_QUERY</span><br></pre></td></tr></table></figure><h4 id="紧急不重要-尽量委派给其他人"><a href="#紧急不重要-尽量委派给其他人" class="headerlink" title="[[紧急不重要]] &#x3D;&#x3D;(尽量委派给其他人)&#x3D;&#x3D;"></a>[[紧急不重要]] &#x3D;&#x3D;(尽量委派给其他人)&#x3D;&#x3D;</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#+BEGIN_QUERY</span><br><span class="line">&#123;    :query [:find (pull ?b [*])</span><br><span class="line">            :in $ ?end</span><br><span class="line">            :where</span><br><span class="line">            [?b :block/marker ?marker]</span><br><span class="line">            [?b :block/properties ?p]</span><br><span class="line">            [?b :block/priority ?priority]</span><br><span class="line">            [(get ?p &quot;type&quot;) ?t]</span><br><span class="line">            [(contains? #&#123;&quot;任务&quot; &quot;行动&quot; &quot;项目&quot;&#125; ?t)] ;; 属性中type字段包含这三种</span><br><span class="line">            [(contains? #&#123;&quot;TODO&quot; &quot;DOING&quot; &quot;NOW&quot;&#125; ?marker)] ;; 不包含已完成任务，不包含LATER</span><br><span class="line">            [(!= &quot;A&quot; ?priority)] ;; 优先级在A的才认为是重要</span><br><span class="line">            (or</span><br><span class="line">            [?b :block/scheduled ?d]</span><br><span class="line">            [?b :block/deadline ?d])</span><br><span class="line">            [(&lt;= ?d ?end)]</span><br><span class="line">            ]</span><br><span class="line">    :inputs [:5d-after] ;; 时间跨度，5天内的算作紧急</span><br><span class="line">    &#125;</span><br><span class="line">#+END_QUERY</span><br></pre></td></tr></table></figure><h4 id="待办清单-不紧急不重要，定期回顾确认"><a href="#待办清单-不紧急不重要，定期回顾确认" class="headerlink" title="[[待办清单]] &#x3D;&#x3D;(不紧急不重要，定期回顾确认)&#x3D;&#x3D;"></a>[[待办清单]] &#x3D;&#x3D;(不紧急不重要，定期回顾确认)&#x3D;&#x3D;</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#+BEGIN_QUERY</span><br><span class="line">&#123;    :query [:find (pull ?b [*])</span><br><span class="line">            :where</span><br><span class="line">            [?b :block/marker ?marker]</span><br><span class="line">            [(contains? #&#123;&quot;LATER&quot;&#125; ?marker)]</span><br><span class="line">            ]</span><br><span class="line">    &#125;</span><br><span class="line">#+END_QUERY</span><br></pre></td></tr></table></figure><h4 id="本周已完成-近七天统计"><a href="#本周已完成-近七天统计" class="headerlink" title="[[本周已完成]] &#x3D;&#x3D;(近七天统计)&#x3D;&#x3D;"></a>[[本周已完成]] &#x3D;&#x3D;(近七天统计)&#x3D;&#x3D;</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#+BEGIN_QUERY</span><br><span class="line">&#123;   :query [:find (pull ?b [*])</span><br><span class="line">            :where</span><br><span class="line">            [?b :block/marker ?marker]</span><br><span class="line">            [?b :block/properties ?p]</span><br><span class="line">            [(get ?p &quot;done&quot;) ?finishedTime]</span><br><span class="line">            [(- 1620657776000 604800000) ?weekbefore] ;; 由于目前Logseq不支持直接获取当前时间戳，只能使用trick的方式，每次查询前手动输入当前时间戳ms值,算出一周前的时间戳</span><br><span class="line">            [(&gt;= ?finishedTime ?weekbefore)] ;; 一周内完成的工作</span><br><span class="line">            [(= &quot;DONE&quot; ?marker)]</span><br><span class="line">            ]</span><br><span class="line">    &#125;</span><br><span class="line">#+END_QUERY</span><br></pre></td></tr></table></figure><h3 id="CSS优化"><a href="#CSS优化" class="headerlink" title="CSS优化"></a>CSS优化</h3><p>这里直接照抄了 <a href="https://www.bmpi.dev/self/okr-gtd-note-logseq/">OKR + GTD + Note &#x3D;&gt; Logseq</a>， 不过它的CSS中内容较多，我单独提取了四象限相关的部分，放在 <a href="https://github.com/samwei12/LogseqMisc/blob/master/%E5%9B%9B%E8%B1%A1%E9%99%90.css">四象限CSS</a> 中，查询模板也都放在这里，便于大家使用。</p><h3 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h3><p>目前我的每日笔记大概长这样：</p><p><img src="https://learner.oss-cn-hangzhou.aliyuncs.com/img/20210508181043.png" alt="20210508181043"></p><blockquote><p>1.1 版本已经解决</p></blockquote><p><del>可以算是1.0 版本，目前存在的问题包括：</del></p><ol><li><del>没有地方定期回顾那些没有设置DDL和优先级的任务</del></li><li><del>缺少查看已完成任务和行动的地方（做周报时候很有用）</del></li></ol><p>Logseq是个很棒的工具，期待尽快稳定下来，后面长期使用，作为笔记+GTD一站式平台~</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;2021-05-08： 1.0版本初步完成，待完善已完成任务回顾&lt;br&gt;2021-05-10： 1.1版本完成，修改不重要不紧急为将来清单，且新增每周回顾&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;最近在阅读《小强升职记》，感觉里面讲到的时间管理工具和方法十分有用，自己之前虽然也了解一些工具，例如四象限原则、两分钟方法等，但看完这本书之后感觉之前的理解还是太肤浅了。是时候升级一下自己的时间管理系统了。&lt;/p&gt;</summary>
    
    
    
    <category term="Utilities" scheme="http://blog.samwei12.cn/categories/Utilities/"/>
    
    
    <category term="Logseq" scheme="http://blog.samwei12.cn/tags/Logseq/"/>
    
    <category term="GTD" scheme="http://blog.samwei12.cn/tags/GTD/"/>
    
  </entry>
  
  <entry>
    <title>如何构建一个PKM系统</title>
    <link href="http://blog.samwei12.cn/2020/05/02/Thinking/%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AAPKM%E7%B3%BB%E7%BB%9F/"/>
    <id>http://blog.samwei12.cn/2020/05/02/Thinking/%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AAPKM%E7%B3%BB%E7%BB%9F/</id>
    <published>2020-05-02T03:00:44.000Z</published>
    <updated>2024-07-31T18:16:36.790Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="http://blog.samwei12.cn/2020/05/02/Thinking/%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%20PKM%20%E7%B3%BB%E7%BB%9F/">原文链接</a></p></blockquote><ul><li>这篇文章是个人知识总结相关的第一篇文章，主要目的是为了阐述我们为什么需要一个 PKM 系统，并且简单对自己这几年亲身形成的PKM 系统进行总结。</li></ul><h2 id="PKM-是什么？"><a href="#PKM-是什么？" class="headerlink" title="PKM 是什么？"></a>PKM 是什么？</h2><ul><li>PKM 是 Personal Knowledge Management 的缩写，我们先来看一下 Wikipedia 中的描述：</li></ul><blockquote><p>Personal knowledge management (PKM) is a process of collecting information that a person uses to gather, classify, store, search, retrieve and share knowledge in their daily activities (Grundspenkis 2007) and the way in which these processes support work activities (Wright 2005). It is a response to the idea that knowledge workers need to be responsible for their own growth and learning (Smedley 2009). </p></blockquote><ul><li>这个解释已经非常清晰了，PKM 就是一套个人知识管理系统，包括知识检索、收集、分类、分享等等，可以说我们在日常生活中每个人都在不停的使用 PKM，例如看新闻、刷抖音、刷微信公众号等等，都是一个不停获取信息的过程，那么我们为什么要梳理搭建属于自己的 PKM 呢？</li></ul><span id="more"></span><h2 id="为什么要构建自己的-PKM-系统？"><a href="#为什么要构建自己的-PKM-系统？" class="headerlink" title="为什么要构建自己的 PKM 系统？"></a>为什么要构建自己的 PKM 系统？</h2><ul><li>大家都知道，我们目前处在一个知识爆炸的时代，虽然说各种信息和知识随手可以检索查看，但是对于绝大部分人来说，这其实并不是一件好事，相反，我认为弊端是大于好处的。</li><li>为什么这么说呢？<ol><li>大家可以思考一下自己每天使用手机的时间和次数，你可以先自己猜测一个数字，然后再使用一些手机时间追踪软件看一下真实数据，我相信大部分人猜测的时间都会比自己实际使用时间少很多。这里我推荐使用 <strong>OffScreen</strong> 这款软件，比起苹果系统自带的追踪多了很多指标，例如每天拿起多少次、走路时看手机的时间、晚上在床上玩了多久手机（这个维度很扎心，大家可以关注下）等等。我自己平均使用时长一般在 2~3 小时左右，每天拿起次数在 50 次左右。</li><li>当然，手机使用时长并不能说明所有问题，但是手机上干扰因素实在是太多，这个大家可以看下系统自带的屏幕使用时间，里面有一栏是每天收到的通知次数，我自己基本上手机每天推送通知次数超过 300次，比如在写代码、学习的时候，微信推送了一条信息，打开手机回复完毕之后，顺便刷一会朋友圈，再看看公众号，链接点进去发现有个好玩的视频，不小心跳到了抖音，然后一天就过去了。是不是觉得这个场景似曾相识？大家要知道，目前有一大堆大公司聘请了高薪产品经理和数据挖掘工程师，他们做的事情就是想办法吸引你的注意力，让你不停地黏在手机上，他们通过收集你在各个页面、软件停留的数据，分析一下之后，对你喜欢看什么（比如抖音里面的大长腿）、喜欢玩什么等等一清二楚，这也就是为什么刷抖音之类的很难停下来，你会发现看到的视频很多都是喜欢看的，这种东西靠意志力很难克服。</li><li>慢慢地，你就会发现自己的手机其实替代了你进行思考，比如今天要看什么、学什么，你以为是你主动控制的，其实都是手机里面各种软件操控你完成的，不信你可以回想一下自己每天使用手机的路径，是不是不自觉的解锁之后就会打开微信、微博看两眼？，<strong>习惯的力量是很可怕的，而且对于大部分来说受到的都是坏习惯的影响。</strong></li></ol></li><li>怎么避免自己淹没在无谓知识的浪潮里面呢？这里简单介绍一下 <strong>DIKW 模型</strong> 和 <strong>学习金字塔</strong>。<ul><li>DIKW：<ul><li><img src="https://learner.oss-cn-hangzhou.aliyuncs.com/img/20200502102007.png" alt="20200502102007"></li><li>它的核心思想其实也很简单， Data-&gt;Information-&gt;Knowledge-&gt;Wisdom 是符合金字塔模型的，尤其是从 Information 到 Knowledge 这里，平时大家刷的微信公众号、看的各种鸡汤文、背的单词，看似也都在努力学习，其实他们大部分都停留在信息这一步，并没有转换成你的知识，而知道了这些知识之后，真正到把它们转换为自己的技能，中间又有一个非常大的 gap，所以其实花了大量的时间，自我成长提升却非常少。</li></ul></li><li>学习金字塔：<ul><li><img src="https://learner.oss-cn-hangzhou.aliyuncs.com/img/20200502114143.png" alt="20200502114143"></li><li>学习效率从低到高大体上分别是文字阅读、音频、视频、演示 Demo、实践、分享教学。</li></ul></li></ul></li><li>这里的核心其实总结下来就是几点：<ol><li><strong>不要把别人的知识当做自己的</strong>，很多人（包括我自己）喜欢收藏各种知识，比如买书、买教程、看到好文章先收藏再稍后读（其实根本不读）。</li><li><strong>没有输出的知识是很难转换为技能的</strong>，很多东西明明自己是看过的，但是仅限于知道理论知识，很快就忘了，下次遇到还是需要 Google，这里需要养成分享的习惯，试想一下，如果你正在看的书或者知识点，老板过来让你下周准备一次分享，是不是立马就更认真了，为了不出丑，不被挑战，你必然会花费更多的心思学习，同时会主动思考大家会问什么问题，提前做好准备，那么经历这么一次分享之后，对应的知识点，过来听讲的人说不定很快就忘了，但是你自己一定可以牢牢记住很久。</li><li><strong>定期 Review</strong>，这个也很好理解，知识的记忆是符合 <strong>艾宾浩斯记忆曲线</strong> 的，可以自行 Google 一下，定期复习确保不会遗忘。</li></ol></li></ul><h2 id="我是如何搭建自己的-PKM-系统的？"><a href="#我是如何搭建自己的-PKM-系统的？" class="headerlink" title="我是如何搭建自己的 PKM 系统的？"></a>我是如何搭建自己的 PKM 系统的？</h2><ul><li>俗话说，”工欲善其事必先利其器“，说了这么多，终于到了本文的核心内容，简单分享总结一下我这几年形成的一套 PKM 体系。</li><li>通过前面的介绍，大家应该也都明白，如果想要把信息和他人的知识变为自己的知识和技能，那么最起码需要完成一个闭环，就是 收集-&gt;整理-&gt;输出-&gt;复习。只有自己实践完成之后，能够归纳整理并且分享给他人的知识才能进一步巩固。</li><li><img src="https://learner.oss-cn-hangzhou.aliyuncs.com/img/20200502134625.png" alt="20200502134625"></li><li>下面就分别对这其中的环节进行详细展开，这里事先说明下，我平时的工作环境是 Mac 全家桶，尽管我这里推荐的都是一些跨平台软件，但是部分 case 可能有所不同。</li></ul><h3 id="信息输入"><a href="#信息输入" class="headerlink" title="信息输入"></a>信息输入</h3><ul><li><p>在当下这么一个信息爆炸的时代，我们所缺少的不是如何收集知识，而是如何主动获取知识和辨别整理。我个人通常的信息来源有这些：<strong>Google（是的没错）、RSS 订阅、微信公众号</strong>。</p></li><li><p>这些信息大部分是通过手机获取的，也可以利用碎片时间阅读，例如等公交、排队等等（不建议吃饭或者上厕所时候看，会影响身体监控）。核心功能诉求如下：</p><ol><li><strong>跨平台</strong>，尤其是手机端，体验一定要好</li><li><strong>速度要快</strong>，这里的速度快包括几个方面，网络速度、文章保存速度等，例如 Raindrop.io 这种，保存一个书签需要转圈 3s 左右，且还需要关心分类文件夹等，基本上可以直接排除，我理解大部分情况下只保存网址即可，哪怕你把网址复制下来贴到滴答清单都可以</li><li>部分重要信息需要能够离线保存查看，不是强诉求</li></ol></li><li><p>这里有几个过滤筛选信息的原则：</p><ol><li>尽可能收集英文资料，原因大家应该都能想到，目前大部分的知识分享都是由英语世界的牛人们发起的，国内各种博客公众号基本都是看了一遍之后自己转手翻译或者加工之后分享的，当然这样的好处就是对于新手来说，更加便于理解，坏处更是显而易见，你收集到的知识都是别人咀嚼过一次的，可能会有很多偏差。所以这里首先你要有一个能够任意查阅国外优质资源的途径（原因大家都懂），然后尽可能使用一些英文关键词进行检索。</li><li>尽可能主动获取知识，否则一定要做好<strong>过滤</strong>。这一点我目前做的也很不好，正在逐步改善，什么意思呢？不要让自己被信息淹没，而是要主动去检索。这里一个比较好的方式就是通过 RSS 订阅或者关注一些优质博客，毕竟个人的精力是有限的，最忌讳看到什么都想学一下，关注几百个微信公众号，每天沉迷在刷各种热门知识的快感中，比如区块链、机器学习等等，实际上工作中根本用不到。<strong>热点是永远跟不完的，尽量学会掌握核心知识，这些知识大部分都是通用的。</strong></li><li>快速区分出哪些信息需要进一步跟进。由于大部分时间这类文章或者咨询都是在等公交、排队等碎片时间接触到的，那么就需要有一个快速鉴别和定期检阅的机制，也就是决定哪些资料需要 Read Later。</li><li><strong>避免 Read Later 变成 Read Never</strong>。这点我也在努力改进，目前 Pocket 里面堆积了 300+ 文章没有看。</li></ol></li><li><p>这里推荐几款我自己在使用的软件：</p><ul><li><del>GFW</del>：不可说。</li><li>RSS： <strong>Reeder4</strong>，老牌应用了，不多说，体验很好，可以使用美国区账号购买 Redeem Code，价格还是比较划算的，印象中十几块钱就可以。</li><li>信息收集类软件：<strong>Pinbox</strong>，这类软件非常多，大体上分为两种，一种是以 Pinboard 为主的书签收集类，同类产品还有 PinBox、Raindrop.io 等；另一种以 Pocket 为首的正宗稍后读类，还有 Instapaper、收趣云等等，Evernote 也算是这类软件，当然它本身是做笔记的，只是网页剪切功能太强大了而已。从阅读体验上来说当然是 Pocket 这类软件更好，不过由于它本身带有的一些社交属性及归档功能，很容易让它变成第二个 Evernote，让你变成一只仓鼠。所以这里我选择了 Pinbox 作为我自己的收集工具，其实单从功能上来说，Pinboard 和 Raindrop.io 做的都比 Pinbox 更好，但是他们的服务器都在国外，网络实在是不够稳定，就这一点上已经被排除了，收趣各方面都不错，但是免费版不支持导出是致命伤，且现在感觉有点凉了，基本没在维护，上一次更新已经是一年多前了，于是只剩下 Pinbox 可选。关于这类软件的测评可以单独写一篇文章了，后面有时间我会更新。</li><li>清单待办类：<strong>滴答清单</strong>，免费版已经足够使用，我比较看重的是它的自然语言识别和跨平台快速实时同步功能，至于其他的类似番茄钟、日历视图等高级功能属于锦上添花，如果你不打算专门为此付费，完全不影响使用。另外它还有一个比较好的亮点功能就是可以把任务以看板视图查看，比较方便。</li><li>书籍类：<strong>MarginNote</strong>，针对深度阅读的诉求，例如阅读书籍等，推荐使用电子书，原因是 IT 类书籍更新迭代较快，，当然一些经典书籍，例如《代码大全》、《重构》等，是可以买一本时时翻阅的，MarginNote 阅读电子书十分方便，可以导入 PDF 批注，同时可以配合 Pad 版本手写批注等，还支持导出笔记为脑图、复习卡片导出为 Anki 等等，功能十分强大。</li></ul></li></ul><h3 id="整理归纳"><a href="#整理归纳" class="headerlink" title="整理归纳"></a>整理归纳</h3><ul><li>获取到自己需要的信息之后需要做的事情就是对这些信息进行分门别类。这里有两种方式进行分类，一种按照目录结构进行分类；另一种是按照标签系统进行分类。有很多关于这方面的话题，在这里我不多赘述，我个人更倾向于使用目录结构，可以配合标签使用，单目录+搜索是必不可少的，通常来说，如果你连搜索的关键词都想不起来，那么说明这个知识点根本就还没在你的大脑里面形成初步印象，那么退回到上一步是更合适的。</li><li>这一步主要的诉求有这么几个：<ol><li>需要对已经存入稍后读的文章进行细品，或者需要实践，之后把核心信息提取出来，进行归纳，这里需要一个<strong>快速整理大纲</strong>的软件。</li><li>如果是看到一些比较好的书单或者类似于学习计划等，需要汇总到自己的个人学习计划中，并且转换为年度、月度、周计划，定期 check，这里有一个模型叫做 <strong>PDCA</strong>，大家可以检索下，它是 Plan、DO、 Check、Action 的缩写，意思是说针对某个目标，需要先进行计划，之后实践，定期 check 学习成果，最后总结反馈，以便下一次学习计划使用。下图就是我自己在用的周报模板。<img src="https://learner.oss-cn-hangzhou.aliyuncs.com/img/20200502180750.png" alt="20200502180750"></li></ol></li><li>在这里我主要使用的是 <strong>Dynalist</strong> 这款软件，它是大纲类笔记软件的一种，同类型的软件还有 Workflowy、幕布等等，其实思维导图也是一种大纲类软件，不过更倾向于平铺对某个知识进行介绍，不适合查看过长的列表，当然你可以加 N 个节点，但是这样无法做到一眼浏览完整体结构，也就失去了导图的意义；Dynalist 这类列表型笔记的好处就是可以一直添加列表项，缺点就是不够直观，不过它的 Pro 版本可以查看导图，一定程度上弥补了这个问题。</li><li>之前我的大量笔记框架都是基于 Xmind 处理的，用了大概两年的样子，但是一直有点不爽的地方在于，Xmind 无法支持 Markdown 格式，插入图片十分不方便，且多个知识点之间联动也比较麻烦。有的知识点可能归属于多个分类，Xmind 只能做到树状结构，无法支持网状知识点关联，也没有办法对所有的导图中某个知识点进行检索。之前的解决方案是使用 Xmind 作为大纲，具体的叶子节点，通过本地 Markdown 链接的方式处理，终归比较麻烦。Dynalist 很完美的解决了这个问题，它支持大部分 Markdown 语法，包括图片、链接等，同时内置了快速链接内部节点的方式，同时可以在所有笔记中全文检索，还支持标签系统，这些都是 Xmind 或者 VSCode 解决不了的问题。</li><li>关于 Dynalist 的测评文章网上有很多，后续有机会我会把导图、列表笔记、 VSCode + Markdown 笔记的优劣对比详细再写一篇文章，Dynalist唯一的缺点就是 Pro 版本太贵，如果大家有兴趣，可以使用我的邀请链接注册，你可以得到一个月的 Pro 时间（价值 10 刀），而我可以获得 5 刀的抵扣券, <a href="https://dynalist.io/invite/pxG1VA">https://dynalist.io/invite/pxG1VA</a> 。</li></ul><h3 id="输出分享"><a href="#输出分享" class="headerlink" title="输出分享"></a>输出分享</h3><ul><li>当你梳理完知识点之后，还需要进一步实践并且输出，这样它才能变成你自己的观点或者知识。Dynalist 或者导图只适合于梳理思路，整理大纲等，并不适合长文书写，如果你需要对某个知识点进行自己的阐述、或者需要写一篇读后感等等，你一定还需要一套专门用于写作的工具，它需要这些功能：<ol><li>绘图工具，很多时候，我们如果想要把知识点清晰的说明出来，就需要绘制成各种图表，例如常见的示意图、阅读源码用到的流程图、时序图等等。这里我使用的软件分别是 <strong>edrawmax</strong> 和 <strong>astah</strong>。<ol><li>edrawmax 提供了大量的绘图模板，例如金字塔、瀑布流、流程图等等，大大的提升了绘图效率。同类型的软件还有 Google 的 draw.io，OmniGraffle 等，也很好用，不过模板方面不尽人意。</li><li>astah 是专门用于软件开发设计使用的工具，绘制 UML、流程图、ER 图等十分专业，界面略简陋，但是功能十分强大，而且比较全面，不需要来回切换软件。</li></ol></li><li>图床：有了自己绘制的各种图片，我们还需要一个图床用于上传图片，这里我选择使用的是阿里云 OSS，优点是性能稳定、上传速度极快，基本上是秒传，同时价格比较便宜，平均一个月 10 块钱左右，用于个人博客足够了。搭配使用 <strong>PicGo</strong> 效果就更棒了，或者可以配合 Typora 直接在粘贴图片时候自动上传。</li><li>Markdown 编辑器：Markdown 编辑器是近几年一个很火爆的话题，同类型的软件大概有好几十个，我自己用过的就包括 MacDown、Marked、MWeb、Typora、Bear 等等。最终选择使用 VSCode+Markdown 插件的形式，比较简洁清晰，而且 VSCode 查找文件、使用命令行操作 Git 等十分方便，不用来回切换。</li><li>个人博客：这里其实不一定需要自己建站，现在博客方案很多种，可以使用博客园、CSDN、简书，也可以建立个人微信公众号，等等。说到底，重要的是产出的内容和是否能够坚持下来，中间的工具都是辅助而已，博客搭建的再漂亮没有文章也是白扯。我个人是用的 GitHub 的 page + Hexo 搭建的博客，好处是归档比较方便，有 Git 提交记录，有分类有 tag，可以再自己买一个域名，也可以直接使用 GitHub 的域名。这部分内容可以参考我之前的文章：<a href="http://blog.samwei12.cn/2015/09/01/Utilities/Writing/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-Hexo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/">如何使用 Hexo 搭建个人博客</a>。</li></ol></li></ul><h3 id="定期-Review"><a href="#定期-Review" class="headerlink" title="定期 Review"></a>定期 Review</h3><ul><li>按照”艾宾浩斯记忆曲线“理论，我们已经学会的知识需要定期回顾整理，才能牢牢记住，这一步我通常的做法是制作记忆卡片，使用的软件是 <strong>Anki</strong>，网上教程很多，这里不再赘述。</li><li>需要说明的一点是，定期 Review 的核心在于 <strong>定期</strong>，如何能够坚持下来是很关键的，这里推荐一款名为 <strong>Streaks</strong> 的软件，它的功能十分简单单一，就是用于养成习惯，亮点是可以跟苹果的健康系统打通，自动读取你的起床时间、睡眠时间进行打卡。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>经过上面这些介绍，现在简单总结一下我个人的一个学习工作流程：<ol><li>首先是信息输入，分为碎片信息、日常待办及书籍阅读。针对碎片信息，先进行过滤筛选，看看是不是要进一步了解学习，如果需要再放到 <strong>Pinbox</strong> 中；日常待办事项，通常我使用 <strong>滴答清单</strong> 处理，可以配合番茄钟使用；深度书籍阅读，电子书我一般使用 <strong>MarginNote</strong> 进行阅读，便于提取信息和整理导图。这里不建议在手机上进行深入阅读，手机也不是很合适，干扰因素太多，尽量减少手机使用时长，还是应该每天专门抽时间在电脑前查看整理收集到的碎片信息。</li><li>之后是归纳整理，这一步需要将各个信息来源所收集到的信息知识进行分门别类，这里按照功能会划分一些固定的目录，例如编程、个人思考、旅行、日常等等，目前使用 <strong>Dynalist</strong> 用来整理大纲。对于一些碎片文章，如果已经整理完毕大纲，则根据是否需要归档来决定要不要将对应的网页进行本地保存，这里推荐一款 Chrome 的插件 <strong>SingleFile</strong>，用于将网页内容全部下载到本地一个单独的 html 文件中，即使网站挂了也能继续翻阅；如果不需要保存，那么仅作为一个参考资料，贴个链接即可。这样可以最大程度上避免 Pinbox 中的信息堆积如山，以至于再也不去查看。同时，目前我也在使用 <strong>Dynalist</strong> 进行个人工作学习计划的整理，而没有采用专门的 Trello 之类的软件，避免来回切换产生的成本。</li><li>然后就是最重要的输出分享，对于一些编程类知识，还需要进行实践，可以针对每个分类单独建一个 GitHub 仓库，用于记录学习，同时把一些知识点归纳成图表，发到自己的博客上，对外进行输出，这里也可以采用跟其他同事同学一起讨论的方式，效率更高。如果觉得需要分享给其他人看，并且要有交流，推荐使用<strong>博客园</strong>，可以配合 MWeb 的 Metablog 支持同时发布到多个博客平台上。</li><li>最后就是把自己已经学习到的知识点，录入到 <strong>Anki</strong> 中，进行定期复习，避免遗忘。</li></ol></li></ul><h2 id="PKM-常见误区"><a href="#PKM-常见误区" class="headerlink" title="PKM 常见误区"></a>PKM 常见误区</h2><ul><li>这里总结一下 PKM 容易进入的误区：</li></ul><ol><li><strong>折腾工具</strong>：尽可能开始明确一套工具体系，然后一直用下去。这个我觉得是绝大部分人会犯的的主要错误（当然包括我）。由于我个人比较喜欢尝试各种新鲜的工具，这些年也浪费了大量的时间，先后使用过 Evernote、为知笔记、MWeb、Xmind 等等，中间各种迁移，花了很多精力不说，部分信息还出现了丢失。目前在逐步克服这个毛病，希望大家不要走我的老路。这里列一下我自己这些年折腾工具摸出来的经验，希望对大家明确合适自己的工具起到帮助：<ol><li><strong>尽可能不要全部依赖免费工具</strong>：现在大家对软件的付费意愿原来越强了，我这里还是简单提一下，不要只是因为某个软件免费而使用它，<strong>Pinboard</strong> 的作者就坚持提供付费服务，产品定价随着购买用户增多而提高，目前已经是每年 22 刀，并且做的越来越好，<strong>免费的往往是最贵的</strong>，我现在越来越能理解这一点。因为免费通常是要付出代价的，比如开发者一直拿不到收获，停止更新了，这时候你就不得不寻找下一个合适的工具，同时还要进行大量的迁移工作，中间会浪费大量的时间，世界上大部分事情都是不公平的，但只有时间，对每个人都是最公平的，所以最宝贵的是你的时间，而不是购买软件的那几十或者几百块钱。写到这里我不得不再次强推一下 Mac 下的 <strong>Manico</strong> 这款软件，它的功能很单一，就是可以帮助你快速切换软件，任意时刻快速按一个快捷键就能打开编辑器、打开钉钉、打开网页，而不是打开 Spotlight 或者 Alfred 再敲软件名，或者用鼠标在 Dock 中寻找，每次大约能节省 1~2 秒，每天大约能节省 5-6 分钟的样子，它现在是我使用频率最高的软件，没有之一，而且很良心的只要 25￥，这个钱是我花过最值的一次。附上我的近 30 天使用截图。 <img src="https://learner.oss-cn-hangzhou.aliyuncs.com/img/20200502182226.png" alt="20200502182226"></li><li><strong>格式越简单越好</strong>：就像很多人现在还喜欢用笔和纸记录笔记一样，互联网发展的速度相当之快，但是兼容性也随之变差，记录想法的工具，最好是足够简单，这也是近些年 Markdown 能够这么火爆的原因。这么多年过去了，txt 格式一样是任何软件都可以支持的，而不是各种奇怪的软件自定义格式，所以尽量避开那些自定义自己格式和规范的软件，尤其是创业公司的，软件或者公司随时可能会倒闭，到时候倒霉的还是用户。这也是我为什么没有选择使用 <strong>Bear</strong>、<strong>Ulysses</strong> 等软件的原因，他们都定义了自己的 Markdown 语法，未来切换迁移成本会比较高。当然现在也还有一些软件走了极端，类似 <strong>Taskpaper</strong> 这种，全部使用文本文件，不是不可以，而是没有必要，如何在易用性和兼容性中间做取舍，要看大家各自的选择了。我个人建议，对于一些价值不是很大的，比如购物清单、待办事项等，可以优先考虑易用性和稳定性；而对于一些需要长久保存翻看的，例如个人博客、年度总结、工作思考等，选用一些相对通用的格式，类似 Markdown、Opml、HTML 等等。</li><li><strong>除非是网络实在不可用，否则尽可能选用国外产品</strong>：倒不是说崇洋媚外，但是我这些年使用软件的心得告诉我，大部分情况下，国产软件不好用。这里指的并不是说功能不够好，而是国内软件氛围普遍较差，大部分软件免费版本砍掉了一些核心功能，逼着你必须付费，然而付费之后发现核心功能还是不够稳定。另一方面，国内产品通常没有足够的克制性，这点上做的最好的是微信，这么多年来，新增功能屈指可数，但是核心功能稳定的一比，假如微信也每年新增 n 个功能，各种摇一摇、视频号强制推广，但是聊天会丢失消息、偶尔连不上网，它绝对做不到如今的规模。反例太多了，比如我前两年用的收趣，刚开始出来的时候真的是好用，同步速度很快，且跟微信打通，直接在微信里面就可以保存文章，解决了一个大难题，但是逐渐就变味了，推出会员制、免费版不允许导出、加了各种花里胡哨的功能，于是我只能放弃它，更恶心的在于如果我想从它上面退出，必须要先买一个会员，否则我的内容导出不了，只能一个个打开拷贝链接，再迁移到 Raindrop.io 或者 Pinbox。国内产品通常都存在这个问题，你在上面产生的任何数据都是归属于他们，而不是你自己，国外公司的产品基本都没这个问题，哪怕是免费版本，你的各种数据在需要的时候都可以自行导出，可能是国内外对数据隐私的看法不同吧。另一个反例就是百度云盘，真的是喂屎给用户，为了不吃屎，只能花钱，而不是说确保核心功能可用的情况下，让用户自愿付费购买额外功能。</li></ol></li><li><strong>仓鼠党</strong>：这个问题想必也有大部分人存在（包括我自己），曾经我的 Evernote 里面保存了上千篇文章和网页，以致于我后面都不想打开它，因为它剪切保存文章功能实在是太方便了，网上随便看到一篇文章就点击保存，动动手指头，分分钟就保存几十篇，然而一篇文章就需要花费几十分钟仔细阅读，有时候还要敲代码，时间就更久了，慢慢的，你会发现文章堆积如山，再也不想看了。我现在也同样存在这个问题，目前缓解的做法之一，就是把那些不能立马用到的或者曾经觉得有用现在用不到的文章全部删掉，不要觉得心疼或者可惜，换个角度考虑，这种文章网上一搜一大把，尽量做到关注到某个主题的时候，主动检索相关信息和知识，而不是推送过来的消息全部保存，然后 <strong>Read Never</strong>，共勉。</li><li>停止打 tag：标签系统并不是很符合人类的思维习惯，可能你并没有注意到，你打的那些标签大部分从来没有检索过，反正我自己平时查阅个人知识的时候就是直接在整个知识库里面全文搜索，直接使用 VSCode 或者 Dynalist 的搜索功能即可。</li><li>停止笔记分类焦虑：看到一篇文章的时候，不要一直纠结它的分类，或者动不动隔段时间就要对笔记进行一次大扫除，确保所有的笔记都在合适的目录下，很多时候有些知识点是很难讲清楚放在 A 还是放在 B 下面，它可能都涉及到。这时候不得不提一下，Dynalist 的内链十分方便，而且对每一个节点都会生成一个唯一链接，如果不是经常改变节点名称的话（大部分情况下改节点名也没问题），即使挪动了目录，对应的内链都不会失效，这点比自己用 Markdown 生成本地文件链接要好太多了。之前我尝试过用 Xmind + 本地文件链接跳转方式管理各种导图，后来就是因为文件位置或者名称一改，链接全部失效，只能作罢。所以使用 Dynalist 可以让你忽略目录分类变更，不用一开始就想尽办法把笔记放在合适的位置，别在这上面浪费时间。</li><li>尽可能简化你的工作流，不要增加太多步骤，步骤越长，越难坚持。</li></ol><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><ul><li>这篇文章基本上总结到了我这几年个人知识管理的关键点，包括一些工具的挑选原则、具体的使用心得、一些常见的误区等等，希望对大家有所帮助。</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://en.wikipedia.org/wiki/Personal_knowledge_management">Wikipedia</a></li><li><a href="https://medium.com/@axtonliu/how-to-build-an-efficient-personal-knowledge-management-system-355332ae5991">How To Build an Efficient Personal Knowledge Management System</a></li><li><a href="https://dynalist.io/d/2pKguSbUt4PK58fuinbTsdWj#z=wCvySzD71orXrlkYhGM2x9OR">PKM 常见误区</a></li><li><a href="https://zhuanlan.zhihu.com/p/39630918">清单笔记</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.samwei12.cn/2020/05/02/Thinking/%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%20PKM%20%E7%B3%BB%E7%BB%9F/&quot;&gt;原文链接&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;这篇文章是个人知识总结相关的第一篇文章，主要目的是为了阐述我们为什么需要一个 PKM 系统，并且简单对自己这几年亲身形成的PKM 系统进行总结。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;PKM-是什么？&quot;&gt;&lt;a href=&quot;#PKM-是什么？&quot; class=&quot;headerlink&quot; title=&quot;PKM 是什么？&quot;&gt;&lt;/a&gt;PKM 是什么？&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;PKM 是 Personal Knowledge Management 的缩写，我们先来看一下 Wikipedia 中的描述：&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;Personal knowledge management (PKM) is a process of collecting information that a person uses to gather, classify, store, search, retrieve and share knowledge in their daily activities (Grundspenkis 2007) and the way in which these processes support work activities (Wright 2005). It is a response to the idea that knowledge workers need to be responsible for their own growth and learning (Smedley 2009). &lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;这个解释已经非常清晰了，PKM 就是一套个人知识管理系统，包括知识检索、收集、分类、分享等等，可以说我们在日常生活中每个人都在不停的使用 PKM，例如看新闻、刷抖音、刷微信公众号等等，都是一个不停获取信息的过程，那么我们为什么要梳理搭建属于自己的 PKM 呢？&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Thinking" scheme="http://blog.samwei12.cn/categories/Thinking/"/>
    
    
    <category term="PKM" scheme="http://blog.samwei12.cn/tags/PKM/"/>
    
    <category term="DIKW" scheme="http://blog.samwei12.cn/tags/DIKW/"/>
    
  </entry>
  
  <entry>
    <title>JDBC学习一---JDBC入门</title>
    <link href="http://blog.samwei12.cn/2020/03/07/Server/JDBC%E5%AD%A6%E4%B9%A0%E4%B8%80/"/>
    <id>http://blog.samwei12.cn/2020/03/07/Server/JDBC%E5%AD%A6%E4%B9%A0%E4%B8%80/</id>
    <published>2020-03-07T09:54:52.000Z</published>
    <updated>2024-07-31T18:16:36.789Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="http://blog.samwei12.cn/2020/03/07/Server/JDBC%E5%AD%A6%E4%B9%A0%E4%B8%80/">原文链接</a></p></blockquote><p>今天开始会写一系列 Java 后端学习的笔记，一方面是为了以后翻阅查看，更主要的原因是通过写作输出的方式让自己的印象更深，避免遗忘。</p><p>首先是简单记录下自己学习使用 JDBC 的历程，由于目前基本都是通过一些类似 MyBatis 的框架来进行数据库操作，所以 JDBC 的使用不需要掌握太深入，仅作为了解即可。</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>首先我们学习任何东西之前都需要先了解几个问题，基本上的思路是：<br>    1. xxx 是什么？<br>    2. 有什么作用？也就是为什么需要 xxx？<br>    3. 怎么使用（简单入门即可）？<br>    4. 分别就主要链路进行知识补充<br>之后，可以根据实际情况决定是否要进一步深入了解，还是只作为简单学习即可。</p><p>JDBC 也不例外。</p><span id="more"></span><h3 id="什么是-JDBC？"><a href="#什么是-JDBC？" class="headerlink" title="什么是 JDBC？"></a>什么是 JDBC？</h3><blockquote><p>Java数据库连接，（Java Database Connectivity，简称JDBC）是Java语言中用来规范客户端程序如何来访问数据库的应用程序接口，提供了诸如查询和更新数据库中数据的方法。JDBC也是Sun Microsystems的商标[1]。JDBC是面向关系型数据库的。</p></blockquote><p>上面是维基百科的解释，从这里我们获取到的几个有用信息：</p><ol><li>简单来说，JDBC 就是 Java 定义的一套用来规范和约束客户端程序如何访问数据库的<strong>接口</strong>，尤其是需要注意接口一词</li><li>JDBC 是面向关系型数据库的，也就是说对于非关系型数据库用这一套接口是不行的。</li></ol><h3 id="为什么需要-JDBC？"><a href="#为什么需要-JDBC？" class="headerlink" title="为什么需要 JDBC？"></a>为什么需要 JDBC？</h3><p>回答类似这种问题其实套路也比较简单，我们思考一下，假如没有 JDBC 会怎么样？</p><p>我们知道，关系型数据库是有很多分类的，例如常见的 MySQL、Oracle、SQL Server等等，那么如果没有一套标准接口的话，意味着我们如果开发 MySQL 数据库，不光需要引入 MySQL 的官方驱动，还需要引入官方的 Jar 包，根据对应的 CRUD 接口编写数据库操作代码，如果这时候你还有另一个使用 Oracle 项目，那么同样的工作需要重新进行一次，可想而知，这个适配成本是随着数据库厂商的增多逐渐上升的。</p><p>那么怎么解决这类问题呢？有一句名言是这么说的，<strong>“计算机科学领域的任何问题都可以通过增加一个简介的中间层来解决。”</strong>，回到我们的问题上，Java 开发者就提供了这么一个中间层，也就是 <strong>JDBC</strong>。</p><p><a href="https://learner.oss-cn-hangzhou.aliyuncs.com/img/20200301214356.png"><img src="https://learner.oss-cn-hangzhou.aliyuncs.com/img/20200301214356.png" alt="20200301214356"></a></p><p>通过这个图可以看到，由于有了这么一个中间层，我们在开发代码时，只需要使用 JDBC 相关的接口即可，不需要关心具体实现底层的是 MySQL 还是 Oracle。</p><h2 id="如何使用-JDBC？"><a href="#如何使用-JDBC？" class="headerlink" title="如何使用 JDBC？"></a>如何使用 JDBC？</h2><p>接下来我们看下如何快速搭建一个 JDBC 的demo。通常在 Java 后端开发中，我们只需要掌握几个核心点就可以快速上手一个框架，它们分别是：</p><ol><li>jar 包或者 maven坐标</li><li>关键的配置文件和属性</li><li>核心的类和 API</li></ol><p>下面我们就从这个几方面入手快速了解一下：</p><h3 id="jar-包或者-maven坐标"><a href="#jar-包或者-maven坐标" class="headerlink" title="jar 包或者 maven坐标"></a>jar 包或者 maven坐标</h3><p>使用数据库需要这么几个比较重要的包：</p><ol><li><code>java.sql</code>：所有与 JDBC 访问数据库相关的接口和类,可以说有了这里面提供的接口和类已经足够搭建一个 demo 实现基本功能</li><li><code>javax.sql</code>：数据库扩展包，提供数据库额外的功能，如：连接池。接下来我们只是实现基本功能，可以不使用这个包。</li><li>数据库的驱动：由各大数据库厂商提供，需要额外去下载，是对 JDBC 接口实现的类。</li></ol><p>这里面只有数据库的驱动是需要我们自己使用 jar 包或者 maven 依赖的。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.17<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里由于我本地的 MySQL 是 8.x 版本，因此使用了 8.0.17， 如果你的 MySQL 是 5.x 版本可以使用 5.1.39。</p><h3 id="关键的配置文件和属性"><a href="#关键的配置文件和属性" class="headerlink" title="关键的配置文件和属性"></a>关键的配置文件和属性</h3><p>JDBC 中可以通过使用配置文件来加载数据库相关配置，例如指定数据库 URL、账户、密码等，这个等下详细介绍。</p><h3 id="核心的类和-API"><a href="#核心的类和-API" class="headerlink" title="核心的类和 API"></a>核心的类和 API</h3><p>JDBC 中几个比较核心的类和作用如下：</p><ul><li>DriverManager 类<ul><li>管理和注册数据库驱动</li><li>得到数据库连接对象</li></ul></li><li>Connection 接口<ul><li>一个连接对象，可用于创建 Statement 和 PreparedStatement 对象</li></ul></li><li>Statement 接口<ul><li>一个 SQL 语句对象，用于将 SQL 语句发送给数据库服务器。</li></ul></li><li>PreparedStatemen 接口<ul><li>一个 SQL 语句对象，是 Statement 的子接口</li></ul></li><li>ResultSet 接口<ul><li>用于封装数据库查询的结果集，返回给客户端 Java 程序</li></ul></li></ul><p>简单了解即可，等下具体搭建工程会详细介绍。</p><h3 id="搭建测试工程"><a href="#搭建测试工程" class="headerlink" title="搭建测试工程"></a>搭建测试工程</h3><p>这里我们先简单建一个表，然后插入几条数据用于查看。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `bank` (</span><br><span class="line">    `name` <span class="type">varchar</span>(<span class="number">10</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `money` <span class="keyword">double</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> bank</span><br><span class="line"><span class="keyword">values</span> (money <span class="operator">=</span> <span class="number">100</span>, name <span class="operator">=</span> <span class="string">&#x27;张三&#x27;</span>),</span><br><span class="line">       (money <span class="operator">=</span> <span class="number">200</span>, name <span class="operator">=</span> <span class="string">&#x27;李四&#x27;</span>),</span><br><span class="line">       (money <span class="operator">=</span> <span class="number">300</span>, name <span class="operator">=</span> <span class="string">&#x27;王五&#x27;</span>),</span><br><span class="line">       (money <span class="operator">=</span> <span class="number">400</span>, name <span class="operator">=</span> <span class="string">&#x27;赵六&#x27;</span>);</span><br></pre></td></tr></table></figure><p>这样我们的表就建好了，数据也有了，我们就正式开始通过编写代码查找表中的数据。</p><p><a href="https://learner.oss-cn-hangzhou.aliyuncs.com/img/20200307202152.png"><img src="https://learner.oss-cn-hangzhou.aliyuncs.com/img/20200307202152.png" alt="20200307202152"></a></p><p>其实说白了使用 JDBC 的核心步骤就是这些：</p><ol><li>导入驱动jar包</li><li>注册驱动</li><li>获取数据库连接对象</li><li>定义sql</li><li>获取执行sql语句的对象 Statement</li><li>执行sql，接受返回结果</li><li>处理结果</li><li>释放资源</li></ol><p>那么我们看下，这里其中导入 jar 包我们已经通过引入 maven 坐标解决了，接下来看看如何注册驱动。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class.forName(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);</span><br></pre></td></tr></table></figure><p>这不就是加载类吗？哪里有注册驱动呢？别着急，我们看下源码。跳到 <code>com.mysql.cj.jdbc.Driver</code> 中，我们发现 <code>Driver</code> 中的静态代码块调用了 <code>DriverManager</code> 的<code>registerDriver</code>方法，然后创建了一个<code>Driver</code>对象作为入参传入。这也跟我们之前提到的 <code>DriverManager</code> 有管理和注册驱动的作用是吻合的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        DriverManager.registerDriver(<span class="keyword">new</span> <span class="title class_">Driver</span>());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException var1) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Can&#x27;t register driver!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看下 <code>DriverManager</code> 的官方文档，可以看到</p><blockquote><p>JDBC 4.0 Drivers must include the file META-INF&#x2F;services&#x2F;java.sql.Driver. This file contains the name of the JDBC drivers implementation of java.sql.Driver.</p></blockquote><blockquote><p>Applications no longer need to explicitly load JDBC drivers using Class.forName(). Existing programs which currently load JDBC drivers using Class.forName() will continue to work without modification.</p></blockquote><p>这几句话是什么意思呢？简单来说就是可能 JDK 觉得大家老是这么加载驱动比较繁琐，在 JDBC4.0 之后新增了一个约定，数据库驱动实现方必须要在 jar 包的 <code>META-INF/services/java.sql.Driver</code> 路径里面写明指定的 <code>Driver</code> 类，这样 JVM 会自动将对应的驱动进行加载，而不再需要程序员在开发过程中手动调用 <code>Class.forName()</code> 了，当然已经调用了的代码可以正常运行而不会受到影响，所以这一步我们可以省略了。</p><p>接下来是获取数据库连接对象 <code>Connection</code>，前面我们已经提到，这个类是用来创建 <code>Statement</code> 对象的，而 <code>Statement</code> 对象就是真正进行数据库操作的类，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> DriverManager.getConnection(<span class="string">&quot;jdbc:mysql://localhost:3306/samwei12&quot;</span>, <span class="string">&quot;root&quot;</span>,<span class="string">&quot;root&quot;</span>);</span><br></pre></td></tr></table></figure><p>通过调用 <code>DriverManager</code> 的<code>getConnection</code>方法，我们就得到了一个 <code>Connection</code> 对象。它的几个入参也比较显而易见，就是数据库连接时的 url、账户、密码等信息。这也是 <code>DriverManager</code> 的第二个功能，就是获取数据库连接对象 <code>Connection</code> 的实例。</p><p>接下来是定义 sql 语句，这个最好理解，这里我们把张三的存款设置成 1000。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;update bank set money=1000 where name=&#x27;张三&#x27;&quot;</span>;</span><br></pre></td></tr></table></figure><p>接下来是创建 <code>Statement</code> 对象，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">Statement</span> <span class="variable">statement</span> <span class="operator">=</span> connection.createStatement();</span><br></pre></td></tr></table></figure><p>执行 sql 语句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> statement.executeUpdate(sql);</span><br></pre></td></tr></table></figure><p>入参代表我们需要执行的 sql 语句，出参代表本条 update 语句影响的行数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(count);</span><br></pre></td></tr></table></figure><p>这里我们简单打印下就可以，如果查询到的是需要封装的对象，那么还需要其他处理，这里不展开。</p><p>最后就是释放资源，这个一定要记住。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">statement.close();</span><br><span class="line">connection.close();</span><br></pre></td></tr></table></figure><p>之后我们执行一下，可以看到打印结果是 1，同时数据库中对应数据也发生了变动。</p><p><a href="https://learner.oss-cn-hangzhou.aliyuncs.com/img/20200307192219.png"><img src="https://learner.oss-cn-hangzhou.aliyuncs.com/img/20200307192219.png" alt="20200307192219"></a></p><p>示例代码地址：</p><ul><li><a href="https://github.com/samwei12/jdbc-demo">https://github.com/samwei12/jdbc-demo</a></li></ul><h2 id="详细-API-了解"><a href="#详细-API-了解" class="headerlink" title="详细 API 了解"></a>详细 API 了解</h2><h3 id="DriverManager"><a href="#DriverManager" class="headerlink" title="DriverManager"></a>DriverManager</h3><p>前面已经讲得比较清楚，它的主要作用就是注册驱动+管理数据库连接，这里只说一下 MySQL 的 URL 写法。</p><ul><li><code>jdbc:mysql://ip地址(域名):端口号/数据库名称</code><ul><li>例子：<code>jdbc:mysql://localhost:3306/samwei12</code></li><li>细节：如果连接的是本机mysql服务器，并且mysql服务默认端口是3306，则url可以简写为：<code>jdbc:mysql:///数据库名称</code></li></ul></li></ul><h3 id="Connection"><a href="#Connection" class="headerlink" title="Connection"></a>Connection</h3><p>数据库连接对象，它的主要功能包括创建一个 <code>Statement</code> 和管理事务。</p><ol><li>获取执行sql 的对象<ul><li><code>Statement createStatement()</code></li><li><code>PreparedStatement prepareStatement(String sql)</code></li></ul></li><li>管理事务：<ul><li>开启事务：<code>setAutoCommit(boolean autoCommit)</code> ：调用该方法设置参数为false，即开启事务</li><li>提交事务：<code>commit()</code></li><li>回滚事务：<code>rollback()</code></li></ul></li></ol><h3 id="Statement"><a href="#Statement" class="headerlink" title="Statement"></a>Statement</h3><p>执行sql的对象，CRUD 都可以执行：</p><ol><li><code>boolean execute(String sql)</code> ：可以执行任意的sql语句</li><li><code>int executeUpdate(String sql)</code> ：执行DML（insert、update、delete）语句、DDL(create，alter、drop)语句<ul><li>返回值：影响的行数，可以通过这个影响的行数判断DML语句是否执行成功 返回值&gt;0的则执行成功，反之，则失败。</li></ul></li><li><code>ResultSet executeQuery(String sql)</code>：执行DQL(select) 语句</li></ol><p>这里我们最常用的的一般就是最后一个方法了，示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//4. 定义sql</span></span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from bank&quot;</span>;</span><br><span class="line"><span class="comment">// 5. 获取执行sql语句的对象 Statement</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">Statement</span> <span class="variable">statement</span> <span class="operator">=</span> connection.createStatement();</span><br><span class="line"><span class="comment">// 6. 执行sql，接受返回结果</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">ResultSet</span> <span class="variable">resultSet</span> <span class="operator">=</span> statement.executeQuery(sql);</span><br><span class="line"><span class="comment">// 7. 处理结果</span></span><br><span class="line"><span class="keyword">while</span> (resultSet.next()) &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">double</span> <span class="variable">money</span> <span class="operator">=</span> resultSet.getDouble(<span class="string">&quot;money&quot;</span>);</span><br><span class="line">    <span class="keyword">final</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> resultSet.getString(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">    System.out.println(name+<span class="string">&quot;银行账户：&quot;</span>+money);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 <code>ResultSet</code> 的 <code>next</code> 方法遍历结果，之后得到的就是一行的数据，分别取出每一列的数据处理即可。</p><h3 id="ResultSet"><a href="#ResultSet" class="headerlink" title="ResultSet"></a>ResultSet</h3><p>结果集对象，封装查询结果</p><ul><li><code>boolean next()</code>: 游标向下移动一行，判断当前行是否是最后一行末尾(是否有数据)，如果是，则返回false，如果不是则返回true</li><li><code>getXxx(参数)</code>:获取数据<ul><li>Xxx：代表数据类型，如： <code>int getInt() , String getString()</code></li></ul></li></ul><ul><li>具体的使用方法 <code>executeQuery</code> 这里已经展示过了</li></ul><h3 id="PreparedStatement"><a href="#PreparedStatement" class="headerlink" title="PreparedStatement"></a>PreparedStatement</h3><p>执行sql的对象，继承自 <code>Statement</code>。看到这里你可能会比较奇怪，我们不是已经有了 <code>Statement</code> 类了嘛，为什么还需要再搞一个子类出来呢？我们先通过一个示例介绍一下什么是 <strong>SQL 注入</strong>。</p><p>创建一个用户登录信息表，包括用户名和密码。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">user</span> (</span><br><span class="line"></span><br><span class="line">id <span class="type">int</span> <span class="keyword">primary</span> key auto_increment,</span><br><span class="line"></span><br><span class="line">name <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line"></span><br><span class="line">password <span class="type">varchar</span>(<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">user</span> <span class="keyword">values</span> (<span class="keyword">null</span>,<span class="string">&#x27;jack&#x27;</span>,<span class="string">&#x27;123&#x27;</span>),(<span class="keyword">null</span>,<span class="string">&#x27;rose&#x27;</span>,<span class="string">&#x27;456&#x27;</span>);</span><br></pre></td></tr></table></figure><p>然后模拟一下用户的登录，如果用户输入的用户名和密码能够匹配到一条记录，那么我们认为登录成功，否则认为登录失败。</p><p>代码比较简单，核心代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from user where name=&#x27;&quot;</span>+userName+<span class="string">&quot;&#x27; and password=&#x27;&quot;</span>+password+<span class="string">&quot;&#x27;&quot;</span>;</span><br><span class="line"><span class="keyword">final</span> <span class="type">Statement</span> <span class="variable">statement</span> <span class="operator">=</span> connection.createStatement();</span><br><span class="line"><span class="keyword">final</span> <span class="type">ResultSet</span> <span class="variable">resultSet</span> <span class="operator">=</span> statement.executeQuery(sql);</span><br><span class="line"><span class="keyword">if</span> (resultSet.next()) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;登录成功，欢迎您：&quot;</span> + userName);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;登录失败&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>验证一下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">请输入用户名：</span><br><span class="line">JACK</span><br><span class="line">请输入用户密码：</span><br><span class="line">123</span><br><span class="line">登录成功，欢迎您：JACK</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">请输入用户名：</span><br><span class="line">jack1</span><br><span class="line">请输入用户密码：</span><br><span class="line">123</span><br><span class="line">登录失败</span><br></pre></td></tr></table></figure><p>看起来好像一切正常，没毛病，那么我们尝试一下如下输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">请输入用户名：</span><br><span class="line">我是一个不存在的用户</span><br><span class="line">请输入用户密码：</span><br><span class="line">我是密码<span class="string">&#x27; or &#x27;</span>a<span class="string">&#x27;=&#x27;</span>a</span><br></pre></td></tr></table></figure><p>这时我们发现，神奇的事情出现了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">登录成功，欢迎您：我是一个不存在的用户</span><br></pre></td></tr></table></figure><p>这是为什么呢？？？其实我们 debug 一下就会发现，原因很简单，我们传给 <code>Statement</code> 对象的是一个字符串，那么上述参数真正执行的 SQL 语句是 <code>select * from user where name=&#39;我是一个不存在的用户&#39; and password=&#39;我是密码&#39; or &#39;a&#39;=&#39;a&#39;</code>。 大家发现了吗？我们的原始 SQL 只是查询用户名和密码信息，但是如果用户输入了类似上面这种奇怪的密码，在我们的 SQL 后面拼接上其他字符串，就可以绕过我们的检查，随意输入任何用户名和密码都可以获得登录授权，这无疑是很危险的。</p><blockquote><p>SQL注入（英语：SQL injection），也称SQL注入或SQL注码，是发生于应用程序与数据库层的安全漏洞。简而言之，是在输入的字符串之中注入SQL指令，在设计不良的程序当中忽略了字符检查，那么这些注入进去的恶意指令就会被数据库服务器误认为是正常的SQL指令而运行，因此遭到破坏或是入侵。</p></blockquote><p>以上是维基百科对应的词条解释，那么怎么解决这种问题呢？JDK 的作者们提供的 <code>PreparedStatement</code> 就是用来处理这种问题的。我们来看一下它的用法。</p><ol><li>Connection 接口中的方法<ol><li><code>PreparedStatement prepareStatement(String sql)</code>: 指定预编译的 SQL 语句，SQL 语句中使用占位符 <code>?</code> 创建一个语句对象</li></ol></li><li>PreparedStatement 接口中的方法<ol><li><code>int executeUpdate()</code>: 执行 DML，增删改的操作，返回影响的行数。</li><li><code>ResultSet executeQuery()</code>: 执行 DQL，查询的操作，返回结果集</li></ol></li></ol><p>使用步骤：</p><ol start="3"><li>编写 SQL 语句，未知内容使用?占位：<code>&quot;SELECT * FROM user WHERE name=? AND password=?&quot;;</code></li><li>获得 <code>PreparedStatement</code> 对象</li><li>设置实际参数：<code>setXxx(占位符的位置, 真实的值)</code><ol><li>对应一系列重载的方法</li></ol></li><li>执行参数化 SQL 语句</li><li>关闭资源</li></ol><p>具体的代码示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 构造一个带参数的 SQL 语句，这里不需要加单引号了，而是使用占位符 ？</span></span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from user where name=? and password=?&quot;</span>;</span><br><span class="line"><span class="comment">// 2. 获取 PreparedStatement 对象</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">PreparedStatement</span> <span class="variable">preparedStatement</span> <span class="operator">=</span> connection.prepareStatement(sql);</span><br><span class="line"><span class="comment">// 3. 设置参数，这里需要注意的是索引是从 1 开始的，而不是 0</span></span><br><span class="line">preparedStatement.setString(<span class="number">1</span>, userName);</span><br><span class="line">preparedStatement.setString(<span class="number">2</span>, userName);</span><br><span class="line"><span class="comment">// 4. 执行参数化 SQL 语句，这里由于 sql 语句已经准备好了，不再需要传入参数，直接执行即可</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">ResultSet</span> <span class="variable">resultSet</span> <span class="operator">=</span> preparedStatement.executeQuery();</span><br><span class="line"><span class="keyword">if</span> (resultSet.next()) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;登录成功，欢迎您：&quot;</span> + userName);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;登录失败&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用起来还是比较简单的，需要注意的几个点已经写在了注释里面。<br>执行结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">请输入用户名：</span><br><span class="line">我是一个不存在的用户</span><br><span class="line">请输入用户密码：</span><br><span class="line">我是密码<span class="string">&#x27; or &#x27;</span>a<span class="string">&#x27;=&#x27;</span>a</span><br><span class="line">登录失败</span><br></pre></td></tr></table></figure><p>可以看到使用 <code>PreparedStatement</code> 有效的解决了 SQL 注入的问题，它还有以下好处：</p><ol><li><code>prepareStatement()</code> 方法会先将 SQL 语句发送给数据库预编译。<code>PreparedStatement</code> 会引用着预编译后的结果。 可以多次传入不同的参数给 <code>PreparedStatement</code> 对象并执行。减少 SQL 编译次数，提高效率。</li><li>提高了程序的可读性</li></ol><p>所以我们尽可能全部都使用 <code>PreparedStatement</code> 的方式，而不是 <code>Statement</code> 类。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>至此，一个简单的 JDBC demo 就搭建完毕了。由于目前已经不会有人直接使用 JDBC 进行数据库操作了，我们只是为了接下来学习 MyBatis 进行一个铺垫，简单了解即可，不需要深入。</p><p>示例代码地址：</p><ul><li><a href="https://github.com/samwei12/jdbc-demo">https://github.com/samwei12/jdbc-demo</a></li></ul><h2 id="Relations"><a href="#Relations" class="headerlink" title="Relations"></a>Relations</h2><ul><li><a href="https://zh.wikipedia.org/wiki/Java%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5">https://zh.wikipedia.org/wiki/Java%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5</a></li><li><a href="https://zh.wikipedia.org/wiki/SQL%E6%B3%A8%E5%85%A5">https://zh.wikipedia.org/wiki/SQL%E6%B3%A8%E5%85%A5</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.samwei12.cn/2020/03/07/Server/JDBC%E5%AD%A6%E4%B9%A0%E4%B8%80/&quot;&gt;原文链接&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;今天开始会写一系列 Java 后端学习的笔记，一方面是为了以后翻阅查看，更主要的原因是通过写作输出的方式让自己的印象更深，避免遗忘。&lt;/p&gt;
&lt;p&gt;首先是简单记录下自己学习使用 JDBC 的历程，由于目前基本都是通过一些类似 MyBatis 的框架来进行数据库操作，所以 JDBC 的使用不需要掌握太深入，仅作为了解即可。&lt;/p&gt;
&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;首先我们学习任何东西之前都需要先了解几个问题，基本上的思路是：&lt;br&gt;    1. xxx 是什么？&lt;br&gt;    2. 有什么作用？也就是为什么需要 xxx？&lt;br&gt;    3. 怎么使用（简单入门即可）？&lt;br&gt;    4. 分别就主要链路进行知识补充&lt;br&gt;之后，可以根据实际情况决定是否要进一步深入了解，还是只作为简单学习即可。&lt;/p&gt;
&lt;p&gt;JDBC 也不例外。&lt;/p&gt;</summary>
    
    
    
    <category term="Server" scheme="http://blog.samwei12.cn/categories/Server/"/>
    
    
    <category term="JDBC" scheme="http://blog.samwei12.cn/tags/JDBC/"/>
    
  </entry>
  
  <entry>
    <title>Cocoapods插件机制浅析</title>
    <link href="http://blog.samwei12.cn/2020/03/04/Ruby/Cocoapods%E6%8F%92%E4%BB%B6%E6%9C%BA%E5%88%B6%E6%B5%85%E6%9E%90/"/>
    <id>http://blog.samwei12.cn/2020/03/04/Ruby/Cocoapods%E6%8F%92%E4%BB%B6%E6%9C%BA%E5%88%B6%E6%B5%85%E6%9E%90/</id>
    <published>2020-03-04T15:16:48.000Z</published>
    <updated>2024-07-31T18:16:36.789Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="http://blog.samwei12.cn/2020/03/04/Ruby/Cocoapods%E6%8F%92%E4%BB%B6%E6%9C%BA%E5%88%B6%E6%B5%85%E6%9E%90/">原文链接</a></p></blockquote><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>虽然做iOS开发的过程中使用过 **<a href="https://cocoapods.org/">Cocoapods</a>**， 但是对里面的细节了解其实不算太多，直到这两年做织女项目时，通过对Cocoapods进行Qt支持改造才开始深入了解部分细节，这个过程中，网上没有找到太多相关资料，本文就简单介绍下我对Cocoapods提供的插件机制的一个简单了解，希望能给大家带来一些帮助。</p><h3 id="Ruby-Open-Classes"><a href="#Ruby-Open-Classes" class="headerlink" title="Ruby Open Classes"></a>Ruby Open Classes</h3><p>在此之前，我们简单看下 <code>Ruby Open Classes</code> ，这部分是为未接触过Ruby的同学准备的，熟悉的同学可以直接略过。</p><p>在Ruby中，类永远是开放的，你总是可以将新的方法加入到已有的类中，除了你自己的代码中，还可以用在标准库和内置类中，这个特性被称为<code>Ruby Open Classes</code>。下面我们通过一个示例简单看下。</p><span id="more"></span><p>首先，我们自定义一个类<code>Human</code>，放在<code>human.rb</code>文件中:</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Human</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">greeting</span> </span><br><span class="line">        puts <span class="string">&quot;hello everybody&quot;</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hungry</span> </span><br><span class="line">        puts <span class="string">&quot;I am hungry&quot;</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>接着，我们新增一个<code>main.rb</code>：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">require_relative <span class="string">&#x27;human&#x27;</span></span><br><span class="line"></span><br><span class="line">john = <span class="title class_">Human</span>.new</span><br><span class="line"></span><br><span class="line">john.greeting </span><br><span class="line"><span class="comment"># hello everybody</span></span><br><span class="line"></span><br><span class="line">john.hungry</span><br><span class="line"><span class="comment"># I am hungry</span></span><br></pre></td></tr></table></figure><p>之后，我们在<code>main.rb</code>中重新定义<code>hungry</code>方法，</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Human</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hungry</span> </span><br><span class="line">        puts <span class="string">&quot;I could eat a horse&quot;</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">john.hungry</span><br><span class="line"><span class="comment"># I could eat a horse</span></span><br></pre></td></tr></table></figure><p>可以看到，这里在我们新增<code>hungry</code>方法之后，所有的<code>Human</code>类的实例均调用我们的新实现了，即使是已经创建好的实例，这里故意放到两个文件中是想说明这个特性是可以跨文件甚至跨模块的，对Ruby内置方法的替换也是可以的（谨慎使用）</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">puts <span class="string">&quot;hello&quot;</span>.size</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">String</span> </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">size</span></span><br><span class="line">        puts <span class="string">&quot;goodbye&quot;</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 5</span></span><br><span class="line"><span class="comment"># goodbye</span></span><br><span class="line">puts <span class="string">&quot;hello&quot;</span>.size</span><br></pre></td></tr></table></figure><p>这个特性是十分强大的，让我们可以很容易的对三方模块进行扩展，也是<code>Cocoapods</code>的插件体系所依赖的基础。</p><h2 id="流程分析"><a href="#流程分析" class="headerlink" title="流程分析"></a>流程分析</h2><p><code>Cocoapods</code>的插件体系整体流程还是比较清晰的，下面我们就来逐步看下。</p><h3 id="CLAide"><a href="#CLAide" class="headerlink" title="CLAide"></a>CLAide</h3><p>首先，<code>Cocoapods</code> 提供了一个便捷的命令行工具库 <a href="https://github.com/CocoaPods/CLAide">CLAide</a>，这个库包含很多功能，例如，一套命令基类，一套插件加载机制等。</p><h3 id="Command基类"><a href="#Command基类" class="headerlink" title="Command基类"></a>Command基类</h3><p>Command基类在<code>lib/claide/command.rb</code>中，这里提供了大量基础功能，包括 <code>run</code> 、 <code>options</code>、 <code>help</code>等等。</p><p>首先，当我们每次执行 <code>pod xxx</code> 命令时候，会执行 <code>bin</code>目录下的可执行文件<code>pod</code>。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">require</span> <span class="string">&#x27;cocoapods&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> profile_filename = <span class="variable constant_">ENV</span>[<span class="string">&#x27;PROFILE&#x27;</span>]</span><br><span class="line">    <span class="comment"># 忽略不相关内容... </span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="title class_">Pod</span><span class="symbol">:</span><span class="symbol">:Command</span>.run(<span class="variable constant_">ARGV</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>这里实际上是 <code>Pod</code> 模块从<code>CLAide</code>继承了子类<code>Command &lt; CLAide::Command</code>，我们执行Pod命令时候，就会调用</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">self</span>.run(argv)</span><br><span class="line">    help! <span class="string">&#x27;You cannot run CocoaPods as root.&#x27;</span> <span class="keyword">if</span> <span class="title class_">Process</span>.uid == <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    verify_minimum_git_version!</span><br><span class="line">    verify_xcode_license_approved!</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">super</span>(argv)</span><br><span class="line"><span class="keyword">ensure</span></span><br><span class="line">    <span class="variable constant_">UI</span>.print_warnings</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>实际上只是扩展了一些检测git版本、xcode证书等，真正核心部分还是调用的<code>CLAide</code>的实现：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">self</span>.run(argv = [])</span><br><span class="line">    plugin_prefixes.each <span class="keyword">do</span> |<span class="params">plugin_prefix</span>|</span><br><span class="line">        <span class="title class_">PluginManager</span>.load_plugins(plugin_prefix)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    argv = <span class="variable constant_">ARGV</span>.coerce(argv)</span><br><span class="line">    command = parse(argv)</span><br><span class="line">    <span class="variable constant_">ANSI</span>.disabled = !command.ansi_output?</span><br><span class="line">    <span class="keyword">unless</span> command.handle_root_options(argv)</span><br><span class="line">        command.validate!</span><br><span class="line">        command.run</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">rescue</span> <span class="title class_">Object</span> =&gt; exception</span><br><span class="line">    handle_exception(command, exception)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>可以看到这里真正执行命令之前会遍历所有的插件前缀，并进行插件加载，回过头来再查看 <code>cocoapods/command.rb</code> 会发现，这里指定了约定的插件前缀</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">self</span>.plugin_prefixes = <span class="string">%w(claide cocoapods)</span></span><br></pre></td></tr></table></figure><p>可以看到这里的插件分为两种，我们目前只关心文件名为<code>cocoapods</code>前缀的插件。</p><h3 id="PluginManager"><a href="#PluginManager" class="headerlink" title="PluginManager"></a>PluginManager</h3><p>我们深入<code>PluginManager</code>的具体实现看下，</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">self</span>.load_plugins(plugin_prefix)</span><br><span class="line">    loaded_plugins[plugin_prefix] |<span class="params"></span>|=</span><br><span class="line">    plugin_gems_for_prefix(plugin_prefix).map <span class="keyword">do</span> |<span class="params">spec, paths</span>|</span><br><span class="line">        spec <span class="keyword">if</span> safe_activate_and_require(spec, paths)</span><br><span class="line">    <span class="keyword">end</span>.compact</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">self</span>.plugin_gems_for_prefix(prefix)</span><br><span class="line">    glob = <span class="string">&quot;<span class="subst">#&#123;prefix&#125;</span>_plugin<span class="subst">#&#123;<span class="title class_">Gem</span>.suffix_pattern&#125;</span>&quot;</span></span><br><span class="line">    <span class="title class_">Gem</span><span class="symbol">:</span><span class="symbol">:Specification</span>.latest_specs(<span class="literal">true</span>).map <span class="keyword">do</span> |<span class="params">spec</span>|</span><br><span class="line">        matches = spec.matches_for_glob(glob)</span><br><span class="line">        [spec, matches] <span class="keyword">unless</span> matches.empty?</span><br><span class="line">    <span class="keyword">end</span>.compact</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">self</span>.safe_activate_and_require(spec, paths)</span><br><span class="line">    spec.activate</span><br><span class="line">    paths.each &#123; |<span class="params">path</span>| <span class="keyword">require</span>(path) &#125;</span><br><span class="line">    <span class="literal">true</span></span><br><span class="line">    <span class="comment"># 不相关代码略去</span></span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>为了减小篇幅，这里只贴了核心相关代码，整体的流程大致是：</p><ol><li>调用<code>PluginManager.load_plugins</code>并传入插件前缀</li><li><code>PluginManager.plugin_gems_for_prefix</code>对插件名进行处理，取出我们需要加载的文件，例如<code>cocoapods</code>前缀在这里会转换为所有包含<code>cocoapods_plugin.rb</code>的gem spec 信息及文件信息，例如<code>~/cocoapods-qt/lib/cocoapods_plugin.rb</code></li><li>调用<code>PluginManager.safe_activate_and_require</code> 进行对应的 gem spec 检验并对每个文件进行加载</li></ol><p>至此，基本的插件加载流程大致梳理清楚了。</p><h2 id="实操"><a href="#实操" class="headerlink" title="实操"></a>实操</h2><p>下面我们看下如何自己扩展一个插件，关于这部分，Cocoapods其实也基本已经帮我们做了很多事情了，主要是 <a href="https://github.com/CocoaPods/cocoapods-plugins">cocoapods-plugins</a>， 它提供了一个插件创建的完整生命周期，包括新增、发布、检索等。</p><h3 id="Cocoapods-plugins"><a href="#Cocoapods-plugins" class="headerlink" title="Cocoapods-plugins"></a>Cocoapods-plugins</h3><p>执行 <code>pod plugins create cocoapods-test</code> 之后，发现自动帮我们创建了一个gem工程，其中的 lib 文件夹下果然存在了一个 <code>cocoapods_plugin.rb</code> 文件，整体的目录结构如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">├── Gemfile</span><br><span class="line">├── LICENSE.txt</span><br><span class="line">├── README.md</span><br><span class="line">├── Rakefile</span><br><span class="line">├── cocoapods-test.gemspec</span><br><span class="line">├── lib</span><br><span class="line">│   ├── cocoapods-test</span><br><span class="line">│   │   ├── <span class="built_in">command</span></span><br><span class="line">│   │   │   └── test.rb</span><br><span class="line">│   │   ├── command.rb</span><br><span class="line">│   │   └── gem_version.rb</span><br><span class="line">│   ├── cocoapods-test.rb</span><br><span class="line">│   └── **cocoapods_plugin.rb**</span><br><span class="line">└── spec</span><br><span class="line">    ├── <span class="built_in">command</span></span><br><span class="line">    │   └── test_spec.rb</span><br><span class="line">    └── spec_helper.rb</span><br></pre></td></tr></table></figure><p>这里最核心的就是<code>cocoapods_plugin.rb</code> ，我们前面分析过，执行pod命令时候会主动加载所有<code>cocoapods_plugin.rb</code>文件，那么只要我们将需要扩展的类加到这里面，执行命令时候就会生效。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &lt; <span class="title class_ inherited__">Command</span></span><br><span class="line">    <span class="variable language_">self</span>.summary = <span class="string">&#x27;Short description of cocoapods-test.&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="variable language_">self</span>.description = <span class="string">&lt;&lt;-DESC</span></span><br><span class="line"><span class="string">        Longer description of cocoapods-test.</span></span><br><span class="line"><span class="string">    DESC</span></span><br><span class="line"></span><br><span class="line">    <span class="variable language_">self</span>.arguments = <span class="string">&#x27;NAME&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">initialize</span>(<span class="params">argv</span>)</span><br><span class="line">        <span class="variable">@name</span> = argv.shift_argument</span><br><span class="line">        <span class="variable language_">super</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">validate!</span></span><br><span class="line">        <span class="variable language_">super</span></span><br><span class="line">        help! <span class="string">&#x27;A Pod name is required.&#x27;</span> <span class="keyword">unless</span> <span class="variable">@name</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span></span><br><span class="line">        <span class="variable constant_">UI</span>.puts <span class="string">&quot;Add your implementation for the cocoapods-test plugin in <span class="subst">#&#123;<span class="variable constant_">__FILE__</span>&#125;</span>&quot;</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>可以看到这里其实只是新增了一个 <code>Test</code> 命令，并加了一些描述信息。为了让我们的扩展能生效，我们可以通过几种方式，</p><ol><li>本地gem源码依赖</li><li>安装gem产物</li></ol><p>为了更贴近实际生产发布流程，这里我们采用第二种方式。</p><p>首先，我们编译生成gem产物，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gem build cocoapods-test.gemspec</span><br></pre></td></tr></table></figure><p>其次，本地安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gem install ~/CocoapodsQt/cocoapods-test/cocoapods-test-0.0.1.gem  --<span class="built_in">local</span></span><br></pre></td></tr></table></figure><p>此时，我们再执行 pod 命令</p><p><img src="https://img.alicdn.com/tfs/TB1I3Ova8Cw3KVjSZR0XXbcUpXa-2116-1076.jpg"></p><p>可以看到我们扩展的命令已经生效，接下来就可以开始愉快的coding了。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>至此，我们对Cocoapods的整体插件流程应该有了一个比较清晰的认识了，希望能给大家带来一些帮助。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.samwei12.cn/2020/03/04/Ruby/Cocoapods%E6%8F%92%E4%BB%B6%E6%9C%BA%E5%88%B6%E6%B5%85%E6%9E%90/&quot;&gt;原文链接&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;虽然做iOS开发的过程中使用过 **&lt;a href=&quot;https://cocoapods.org/&quot;&gt;Cocoapods&lt;/a&gt;**， 但是对里面的细节了解其实不算太多，直到这两年做织女项目时，通过对Cocoapods进行Qt支持改造才开始深入了解部分细节，这个过程中，网上没有找到太多相关资料，本文就简单介绍下我对Cocoapods提供的插件机制的一个简单了解，希望能给大家带来一些帮助。&lt;/p&gt;
&lt;h3 id=&quot;Ruby-Open-Classes&quot;&gt;&lt;a href=&quot;#Ruby-Open-Classes&quot; class=&quot;headerlink&quot; title=&quot;Ruby Open Classes&quot;&gt;&lt;/a&gt;Ruby Open Classes&lt;/h3&gt;&lt;p&gt;在此之前，我们简单看下 &lt;code&gt;Ruby Open Classes&lt;/code&gt; ，这部分是为未接触过Ruby的同学准备的，熟悉的同学可以直接略过。&lt;/p&gt;
&lt;p&gt;在Ruby中，类永远是开放的，你总是可以将新的方法加入到已有的类中，除了你自己的代码中，还可以用在标准库和内置类中，这个特性被称为&lt;code&gt;Ruby Open Classes&lt;/code&gt;。下面我们通过一个示例简单看下。&lt;/p&gt;</summary>
    
    
    
    <category term="Ruby" scheme="http://blog.samwei12.cn/categories/Ruby/"/>
    
    
    <category term="Cocoapods" scheme="http://blog.samwei12.cn/tags/Cocoapods/"/>
    
  </entry>
  
  <entry>
    <title>如何创建一个 Cocoapods 插件</title>
    <link href="http://blog.samwei12.cn/2019/04/22/Ruby/Gem/%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AACocoapods%20%E6%8F%92%E4%BB%B6/"/>
    <id>http://blog.samwei12.cn/2019/04/22/Ruby/Gem/%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AACocoapods%20%E6%8F%92%E4%BB%B6/</id>
    <published>2019-04-22T03:07:35.000Z</published>
    <updated>2024-07-31T18:16:36.789Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="http://blog.samwei12.cn/2019/04/22/Ruby/Gem/%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AACocoapods%20%E6%8F%92%E4%BB%B6/">原文链接</a></p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>我们在使用 Cocoapods 过程中,如果发现它未能满足我们的要求该怎么办呢? </li><li>最简单的粗暴的办法就是 fork 一份 Cocoapods 源码,然后自己公司内部或者个人直接针对源码进行部分修改或者新增功能,但这样做完全没有兼容性和扩展性,如果后续 Cocoapods 升级版本,你是无法兼容的,还需要重新进行一次修改,费力不讨好.</li><li>其实 Cocoapods 提供了一套很方便的插件机制,只需要符合插件规则,即可定制各种自定义需求,接下来我们就看下应该如何自定义一个自己的插件.</li></ul><span id="more"></span><h2 id="How"><a href="#How" class="headerlink" title="How"></a>How</h2><ol><li>确保 Gem 中安装了 <code>cocoapods-plugins</code> 模块,这个按理讲是安装 Cocoapods 时自带的,可以使用命令 <code>gem install cocoapods-plugins</code>进行安装</li><li>新增插件 <code>pod plugins create NAME</code></li><li>针对 gemspec 进行部分修改  <figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这里是对外暴露的文件</span></span><br><span class="line">s.files = <span class="title class_">Dir</span>[<span class="string">&quot;lib/**/*.rb&quot;</span>] + <span class="string">%w&#123; bin/pod bin/sandbox-pod README.md LICENSE CHANGELOG.md &#125;</span></span><br><span class="line">s.files = <span class="title class_">Dir</span>[<span class="string">&quot;lib/**/*.rb&quot;</span>] + <span class="string">%w&#123; README.md LICENSE.txt &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可执行文件, 没有的话可以使用默认生成的</span></span><br><span class="line">s.executables   = <span class="string">%w&#123; pod sandbox-pod &#125;</span></span><br><span class="line"><span class="comment"># 查找路径</span></span><br><span class="line">s.require_paths = <span class="string">%w&#123; lib &#125;</span></span><br></pre></td></tr></table></figure></li><li>开发过程直接在 <code>lib/cocoapods_plugin</code> 文件中加载你 hook 的文件即可</li><li>最终对外发布可以通过提 PR 给 <code>cocoapods-plugins</code> ,也可以放到自己公司的内部 Gem 源中</li></ol><h2 id="Relations"><a href="#Relations" class="headerlink" title="Relations"></a>Relations</h2><h3 id="书籍"><a href="#书籍" class="headerlink" title="书籍"></a>书籍</h3><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul><li><a href="https://github.com/CocoaPods/cocoapods-plugins">https://github.com/CocoaPods/cocoapods-plugins</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.samwei12.cn/2019/04/22/Ruby/Gem/%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AACocoapods%20%E6%8F%92%E4%BB%B6/&quot;&gt;原文链接&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;我们在使用 Cocoapods 过程中,如果发现它未能满足我们的要求该怎么办呢? &lt;/li&gt;
&lt;li&gt;最简单的粗暴的办法就是 fork 一份 Cocoapods 源码,然后自己公司内部或者个人直接针对源码进行部分修改或者新增功能,但这样做完全没有兼容性和扩展性,如果后续 Cocoapods 升级版本,你是无法兼容的,还需要重新进行一次修改,费力不讨好.&lt;/li&gt;
&lt;li&gt;其实 Cocoapods 提供了一套很方便的插件机制,只需要符合插件规则,即可定制各种自定义需求,接下来我们就看下应该如何自定义一个自己的插件.&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Ruby" scheme="http://blog.samwei12.cn/categories/Ruby/"/>
    
    
    <category term="Cocoapods" scheme="http://blog.samwei12.cn/tags/Cocoapods/"/>
    
  </entry>
  
  <entry>
    <title>如何恢复 iCloud 已删除文件</title>
    <link href="http://blog.samwei12.cn/2019/04/21/Utilities/Mac/%E5%A6%82%E4%BD%95%E6%81%A2%E5%A4%8D%20iCloud%20%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6/"/>
    <id>http://blog.samwei12.cn/2019/04/21/Utilities/Mac/%E5%A6%82%E4%BD%95%E6%81%A2%E5%A4%8D%20iCloud%20%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6/</id>
    <published>2019-04-21T14:58:09.000Z</published>
    <updated>2024-07-31T18:16:36.791Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="http://blog.samwei12.cn/2019/04/21/Utilities/Mac/%E5%A6%82%E4%BD%95%E6%81%A2%E5%A4%8D%20iCloud%20%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6/">原文链接</a></p></blockquote><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ul><li>今天在查找之前的 C++ 笔记时,突然发现之前的资料全没了,整个 Cpp 文件夹内就只剩下了三个文件,怎么形容当时的心情呢,应该说是一下就跌倒了谷底,感觉之前的心血全白费了,有种深深的挫败感.</li></ul><span id="more"></span><h2 id="思考路径"><a href="#思考路径" class="headerlink" title="思考路径"></a>思考路径</h2><ul><li>这时候,我第一反应是想到了前几天我进行过一次文件夹整理,中间有个操作就是把另一个同名 Cpp 文件夹拷贝到了原本的 Cpp 文件夹中,这里有一个深坑,是把我原本的文件夹整个替换掉了!!!具体原因我等下再讲.</li><li>突然有点六神无主,这时候想到的第一个解决方案是使用 Mac 数据恢复软件,网上迅速搜了一把,找到了 Disk Drill,嗯,无奈发现这个是收费软件,而且并没有能找到我想恢复的内容,因为我是误删了整个文件夹,且已经删除大概一周左右,我其实并想不起来里面具体都有几个文件,每个文件名叫什么,可能这个软件更适合于单个文件恢复吧,而且查找速度略慢,等了大概5-8分钟,结果告诉我没找到相关资料.(后面发现这货出现在我的 Setapp 里面,然而我暂时没有想用它的欲望了.)</li><li>就在这时,我想起来苹果貌似有个文件恢复, 找到 <a href="https://www.icloud.com/#iclouddrive">https://www.icloud.com/#iclouddrive</a> 点击右下角最近删除,这时突然发现,嗯,里面是空的,告诉我最近没有任何文件删除! 此时我的内心有点小绝望,猜测应该是删除文件时间过久,苹果已经放弃他了,</li><li>如果结果是这样,那么也就不会有这篇文章了,再次不甘尝试,换个关键词搜索,嗯,貌似有戏</li><li><img src="https://i.loli.net/2019/04/21/5cbc8868cfb12.png" alt="CleanShot 2019-04-21 at 23.10.58@2x.png"></li></ul><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><ul><li>再次打开 iCloud, 这次进入的是 <a href="https://www.icloud.com/#settings">https://www.icloud.com/#settings</a> 这个页面,此时,果然发现左下角有个高级-&gt;恢复文件,半信半疑的点开</li><li><img src="https://i.loli.net/2019/04/21/5cbc886607019.png" alt="CleanShot 2019-04-21 at 23.11.29@2x.png"></li><li>耐心等待了大约10分钟左右,这次真的有文件列表出来了!!!天知道我此刻心里有多么的激动,这种失而复得的感觉是很棒的.</li></ul><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><ul><li>这里补充下,为什么当时粘贴时候没注意点了一下 OK,就差点(其实已经酿成了,不过勉强救回来了)酿成悲剧呢?</li><li>原因在于拷贝跟剪切是完全不一样的,当你拷贝一个文件夹,然后粘贴时遇到同名文件夹,会提示:</li><li><img src="https://i.loli.net/2019/04/21/5cbc8a9ac9e8d.png" alt="CleanShot 2019-04-21 at 23.21.32@2x.png"></li><li>看到吧,这里会很明显告诉你要不要进行合并还是选择替换,但是当你使用了剪切之后,会提示什么呢?</li><li><img src="https://i.loli.net/2019/04/21/5cbc8a9ac5216.png" alt="CleanShot 2019-04-21 at 23.21.47@2x.png"></li><li>坑就在这里了, <strong>剪切时候,并不会提示合并,而是直接替换!!!</strong>,我就是在这里没有注意,手一抖,点了一个替换,然后就悲剧了.</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>所以,iCloud Drive 中的恢复文件,貌似时间是更短一点的,具体多久还没测试,但是看起来我超过3天的文件已经无法看到了,只有当天删除的可以显示,这时候千万不要气馁,找到 iCloud Setting 里面的高级-&gt;恢复文件, 这个时间限制就久很多了,可以恢复不超过<strong>30天</strong>的文件,一般情况下都足够使用了,这里稍微吐槽下,苹果云盘的这个恢复功能远不如国内坚果云做的好,考虑到每个月只要6块钱,我忍了.</li><li>另外,<strong>剪切功能使用的时候一定要小心,注意是没有合并提示的!!!</strong></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.samwei12.cn/2019/04/21/Utilities/Mac/%E5%A6%82%E4%BD%95%E6%81%A2%E5%A4%8D%20iCloud%20%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6/&quot;&gt;原文链接&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;今天在查找之前的 C++ 笔记时,突然发现之前的资料全没了,整个 Cpp 文件夹内就只剩下了三个文件,怎么形容当时的心情呢,应该说是一下就跌倒了谷底,感觉之前的心血全白费了,有种深深的挫败感.&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Mac" scheme="http://blog.samwei12.cn/categories/Mac/"/>
    
    
    <category term="iCloud" scheme="http://blog.samwei12.cn/tags/iCloud/"/>
    
  </entry>
  
</feed>
